#+TITLE: Práticas Computacionais I (~v0.0.3~)
#+AUTHOR: Daniel R. Cassar & James M. de Almeida
#+EXPORT_FILE_NAME: PC1/PC1
#+STARTUP: overview
#+PROPERTY: header-args:python :results output
#+OPTIONS: TeX:t LaTeX:t toc:t html-style:t e:t
#+LATEX_HEADER: \usepackage[brazilian]{babel}
#+LATEX_HEADER: \addto\captionsenglish{\renewcommand\contentsname{Conteúdo}}
#+HTML_HEAD:<style>
#+HTML_HEAD:.linenr {color: #669999; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}
#+HTML_HEAD:</style>
#+todo: TODO(t) DANIEL(d) JAMES(j) | DONE(x)


* Introdução
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_intro
:EXPORT_OPTIONS: toc:nil
:ID:       be365bdb-8e61-4ed3-89ae-397c7855cdeb
:END:

#+HTML: Bem-vinda(o) à disciplina de Práticas em Ciência de Dados.

#+LATEX: Você está lendo o caderno de práticas da disciplina Práticas Computacionais I. Como o próprio nome sugere, aqui você encontrará as práticas que serão realizadas durante a disciplina Práticas Computacionais I da Ilum. As práticas estão apresentadas na ordem de construção do conhecimento e é altamente recomendado realizá-las em sequência sem pular nenhuma etapa.

A maioria das práticas contém um breve texto introdutório e uma ou mais questões. As questões são marcadas com uma letra em negrito e entre chaves. *[A]* Por exemplo, aqui seria o enunciado da questão *A* se estivéssemos dentro do escopo de uma prática.

Realize as práticas seguindo as instruções discutidas em sala de aula. Lembre-se que a capacidade de ler, entender, escrever, e depurar seu próprio código de computador é /fundamental/ para realizar diversas disciplinas da Ilum (incluindo, obviamente, todas as disciplinas de computação). Por este motivo, se atente às dicas abaixo:

+ A maioria das práticas são individuais. Tente resolver as questões no seu computador antes de discutir em grupo. Depois de tentar resolver, fique à vontade para discutir em grupo e observar outras formas de resolver o mesmo problema;

+ Algumas práticas te convidam a executar algum código pronto para ver o que acontece. Mesmo sendo possível copiar e colar o código, é fortemente recomendado /escrever/ o código pois aprendemos mais quando escrevemos do que quando copiamos e colamos;

+ Praticamente todos os problemas computacionais que serão explorados nesta disciplina já foram resolvidos por alguém e a solução pode ser encontrada em livros ou na internet. Isso é inevitável para problemas /simples/. Mais adiante no curso (ou na vida) iremos nos deparar com problemas mais /difíceis/ e mais específicos, que não têm soluções prontas. Para resolver problemas difíceis precisamos ter uma base sólida que só adquirimos resolvendo problemas mais simples. Aproveite esse momento de aprendizado e evite buscar respostas prontas /antes/ de tentar resolver o problema! Depois que você tentou resolver, fique à vontade para procurar e estudar outras soluções.

Ao fim de todas as práticas é necessário enviar o seu caderno de notas Jupyter na plataforma Moodle. Preencha seu caderno de notas seguindo o modelo fornecido. O nome do arquivo deve conter seu nome, sobrenome, e RA.

* Jupyter, variáveis, e como buscar ajuda
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_jupyter
:EXPORT_OPTIONS: toc:t
:ID:       60b5365d-1c0c-4944-bb64-dcbb673a2e4f
:END:

** Meu primeiro caderno de notas Jupyter

Usualmente, a primeira prática quando se está aprendendo uma linguagem de programação nova é a chamada "Olá, mundo!". Nesta prática, o objetivo é criar seu primeiro programa na linguagem Python que, quando executado, exiba a mensagem "Olá, Mundo!".

*[A]* Crie um caderno de notas Jupyter seguindo o modelo discutido na Introdução. Neste caderno, crie uma célula de código contendo o código abaixo. Execute esta célula e observe o que acontece. Escreva brevemente sobre o que você observou.

#+begin_src python
  print("Olá, mundo!")
#+end_src

Observe que no código acima temos três elementos: o comando ~print~, um conjunto de parênteses, e um texto delimitado por aspas duplas. O comando ~print~ é o que chamamos de função. Veremos funções mais adiante, mas por hora basta saber que funções são "apelidos" para executar códigos que já foram escritos. Neste caso, ~print~ é uma função embutida de Python cujo código já foi escrito pelos próprios criadores do Python, por isso você pode usar esta função sem a necessidade de defini-la. A palavra /print/ poderia ser traduzida para o português como /imprimir/, porém o termo /exibir/ se encaixa melhor no uso corriqueiro desta função.

Para executar funções precisamos chamá-las usando os parênteses. Se tiver curiosidade, tente criar e executar uma célula no Jupyter apenas com a palavra ~print~ para ver o que acontece quando escrevemos o nome de uma função sem chamá-la com o parênteses.

Por fim, dentro dos parênteses que usamos para chamar a função ~print~ nós escrevemos os argumentos da função. Neste caso, temos apenas um argumento e ele foi o texto "Olá, mundo!".

Aprender qualquer linguagem, seja ela de programação ou não, requer treino. Não se preocupe se as regras de Python parecem esquisitas, com o passar do tempo você irá ler e escrever códigos em Python com mais facilidade. Afinal, você não aprendeu português de um dia para o outro, não é?

** Criando variáveis de diferentes tipos

É comum em programação situações onde precisamos armazenar informações em variáveis para usá-las mais tarde. Python oferece diversos tipos de variáveis como, por exemplo, números inteiros (~int~), números reais (~float~), e variáveis que armazenam texto (~string~).

*[A]* O código abaixo cria diversas variáveis. Reescreva e execute este código em uma célula do Jupyter. Veja que para atribuir valores à variáveis nós usamos o sinal de igual (~=~). Note que para o Python, o separador decimal é o ponto (~.~) e não a vírgula (~,~); muita atenção com essa distinção pois a vírgula tem outro significado em Python e não necessariamente vai acusar um erro no seu código!! _Lembrete_: mesmo sendo possível copiar e colar o código, sugiro fortemente /escrever/ o código abaixo pois aprendemos muito mais quando escrevemos do que quando copiamos e colamos.

Usando a função ~type~ e a função ~print~, identifique os tipos das variáveis definidas no código que você escreveu. Exemplo: ~print(type(numero_inteiro))~. Quantos tipos diferentes você identificou? Quais foram eles?

#+LATEX: \par\noindent\rule{\textwidth}{0.4pt}
#+begin_src python
  texto_com_aspas_simples = 'Olá, Mundo!'
  texto_com_aspas_duplas = "Olá, Mundo!"
  texto_com_aspas_triplas = '''Olá, Mundo!'''

  numero_inteiro = 10
  numero_inteiro_positivo = +10
  numero_inteiro_negativo = -10

  numero_real = 10.0
  numero_real_sem_digitos_depois_do_ponto = 10.
  numero_real_positivo = +10.0000
  numero_real_negativo = -10.0000
  numero_real_base_dez = 1.5e7
  pi = 3.1415

  numero_complexo = 2 + 3j
  numero_complexo_apenas_parte_imaginaria = 5j
  numero_complexo_apenas_parte_real = 1 + 0j

  variavel_booleana_verdadeiro = True
  variavel_booleana_falso = False

  variavel_nula = None
#+end_src

#+RESULTS:

#+LATEX: \par\noindent\rule{\textwidth}{0.4pt}

*[B]* Em uma célula de texto responda as perguntas:

1) Existe diferença de se criar uma string usando aspas simples, duplas, ou triplas? Reflita sobre a resposta e busque informações na internet antes de escrever. Não se esqueça de colocar as fontes na sua resposta.
2) Qual a diferença entre um número real e um número inteiro? Pelos exemplos do código acima, qual seria a regra para definir números inteiros e números reais?
3) Qual a regra para declarar números complexos? O que é o ~j~ na declaração dos números complexos?
4) Na sua opinião, existe diferença entre as variáveis ~numero_inteiro~ e ~numero_inteiro_positivo~? Explique brevemente seu raciocínio.
5) Na sua opinião, existe diferença entre as variáveis ~numero_real~, e ~numero_real_positivo~, e ~numero_real_sem_digitos_depois_do_ponto~? Explique brevemente seu raciocínio. De que forma você faria para confirmar a sua resposta?

*[C]* O código abaixo /supostamente/ cria novas variáveis. No entanto, algumas das declarações parecem... diferente... quem sabe até estranhas! Seu objetivo é testar cada uma destas declarações e separar as que funcionam das que não funcionam. Para as declarações que não funcionam, descreva o erro que ocorreu e proponha uma correção.

#+begin_src python
  variavel_que_o_nome_termina_com_numero_100 = 1
  100_variavel_que_o_nome_comeca_com_numero = 1
  numero_do_agente_secreto = 007

  nome_da_variável_com_acento = True
  booleano_sem_primeira_letra_maiuscula = true

  espaco_entre_os_numeros = 100 000
  numero_com_sublinhado = 10_000_000

  numero_com_muitos_sinais_de_menos = -----10
  numero_com_muitos_sinais_de_mais = +++++10
  numero_com_muitos_sinais_de_mais_e_menos = +--++-10

  muitos_espacos_entre_o_sinal_de_igual     =      10
  nenhum_espaco_entre_o_sinal_de_igual=10

  texto = Olá, Mundo!
  texto = "Olá, Mundo!'
#+end_src

#+RESULTS:

** Buscando ajuda

Nas práticas anteriores usamos a função ~print~ para exibir informações na forma de texto dentro do próprio caderno de notas do Jupyter. A função ~print~ é uma /função embutida/ do Python. Isto que dizer que qualquer usuário que tenha o Python instalado (idealmente na mesma versão que a sua) terá acesso a esta função sem a necessidade de executar nenhum comando adicional.

Na prática, nós já sabemos que a função ~print~ recebe como argumento o texto ou variável que será exibido. Argumentos de funções são as informações que estão dentro dos parênteses quando executamos as funções; o argumento da função ~print~ em ~print(1234)~ é o número 1234. Funções podem receber um ou mais argumentos, bem como podem receber zero argumentos (tente rodar ~print()~ e veja o que acontece!). Os argumentos das funções são definidos no momento quando a função é definida (vamos ver isso em mais detalhes em uma prática futura).

O que você faria se não soubesse o que função ~print~ faz? Digamos, por exemplo, que você viu essa função sendo usada em um código de Python mas não sabe sua funcionalidade. Como proceder? Algumas sugestões neste caso são:

1) Pesquisar na internet em busca de alguma página com explicações (Python é uma linguagem de programação muito usada, existe muito material didático disponível online);
2) Pesquisar na documentação oficial do Python disponível em português no link https://docs.python.org/pt-br/3/. Todas as funções embutidas de Python, por exemplo, estão descritas aqui: https://docs.python.org/pt-br/3/library/functions.html;
3) Usar a função ~help~ do próprio Python (tente rodar ~help(print)~ no seu caderno de notas e veja o que acontece);
4) Usar a sintaxe própria do Jupyter para buscar ajuda. Para isso basta digitar a função que quer saber mais informações junto com um sinal de interrogação. Neste caso seria ~print?~.

*[A]* Escolha uma das quatro sugestões acima para ler mais sobre a função ~print~ do Python. Observe que a função ~print~ aceita diferentes argumentos, sendo eles: ~value~, ~file~, ~flush~, ~end~, e ~sep~. Escreva como foi sua busca (incluindo fontes se for o caso) e descreva com suas palavras o que os argumentos ~end~ e ~sep~ fazem. Tente outras formas de busca caso julge necessário.

*[B]* Escolha pelo menos duas funções da lista abaixo. Para cada função escolhida, faça uma busca online (buscas 1 ou 2) e uma busca offline (buscas 3 ou 4) para entender o que estas funções fazem. Escreva como foi sua busca (incluindo fontes) e descreva com suas palavras o que estas funções fazem.

+ ~round~
+ ~pow~
+ ~oct~
+ ~abs~

* Operadores e estrutura de decisão
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_operadores
:EXPORT_OPTIONS: toc:t
:ID:       af8757f4-e890-4b3d-96ea-a9c2c73c39e5
:END:

** Operadores aritméticos

A linguagem Python contém diversos operadores aritméticos como adição (~+~), subtração (~-~), multiplicação (~*~), divisão (~/~), e exponencial (~**~). Estes operadores permitem realizar cálculos aritméticos com números inteiros, reais, e complexos. _Cuidado_: em Python, a exponenciação é representada por dois asteriscos; não confundir com o acento circunflexo (~^~) que é o operador de exponenciação usado no Excel!

*[A]* Reescreva o código abaixo em uma célula do Jupyter e veja o que acontece. Comente porque o resultado da terceira linha foi ~100.25~ e não ~5.25~.

#+begin_src python
  print(1 + 1)
  print(1 - 1 + 1 - 1)
  print(-10 + 10.5 * 10.5)
  print(10 / 2 * 5)
  print(10 ** 10)
  print(2 ** 1 / 2)
  print(2 ** (1 / 2))
  print((1 + 1j) / (1 - 1j))
#+end_src

#+RESULTS:
: 2
: 0
: 100.25
: 25.0
: 10000000000
: 1.0
: 1.4142135623730951
: 1j

A ordem de precedência dos operadores aritméticos (isto é, qual é a ordem de execução dos operadores) segue a regra do PEMDAS: parênteses, exponencial, multiplicação, divisão, adição, e subtração. Assim como na notação matemática, usamos parênteses para dar preferência para certas operações.

*[B]* Utilizando os operadores aritméticos do Python, compute:
1) Quantos segundos existem em 16 horas e 42 minutos?
2) Quantos centímetros existem em 72,8 milhas?
3) Se você percorrer 72,8 milhas em 16 horas e 42 minutos, qual a sua velocidade média em centímetros por segundo?
4) Quanto tempo você demoraria para percorrer a circunferência da Terra na linha do equador se permanecer na velocidade média obtida no item acima?

*[C]* Além dos operadores discutidos acima, existem diversos outros em Python. Dois operadores bastante úteis são a divisão inteira (~//~) e o módulo (~%~, também conhecido como resto da divisão inteira). Teste estes operadores e descreva como eles funcionam (em caso de dúvida, busque ajuda assim como discutido na Seção Buscando Ajuda). Discorra brevemente sobre possíveis situações onde estes operadores podem ser úteis.

_Atenção_: operadores aritméticos usualmente funcionam com qualquer combinação de números inteiros, reais, ou complexos. No entanto, preste atenção no tipo do resultado final!

*[D]* Escreva e execute o código abaixo e comente sobre o resultado obtido. Escreva um código similar ao código abaixo, porém alterando o operador de adição pelo operador de divisão. Você obteve algum resultado inusitado? Comente.

#+begin_src python
  inteiro_mais_inteiro = 1 + 1
  print(type(inteiro_mais_inteiro))

  inteiro_mais_real = 1 + 1.5
  print(type(inteiro_mais_real))

  real_mais_real = 1.5 + 1.5
  print(type(real_mais_real))

  inteiro_mais_complexo = 10 + (1 - 2j)
  print(type(inteiro_mais_complexo))

  real_mais_complexo = 10.5 + (1 - 2j)
  print(type(real_mais_complexo))
#+end_src

#+RESULTS:
: <class 'int'>
: <class 'float'>
: <class 'float'>
: <class 'complex'>
: <class 'complex'>

*Desafio*: durante um exercício de geometria, você decidiu realizar suas contas utilizando Python. Você escreveu o código abaixo em uma célula no seu caderno de notas Jupyter e o resultado que obteve foi inusitado! Por que o resultado é inusitado? Qual era o resultado esperado? Qual é a explicação para isso? Na sua opinião, este tipo de "problema" compromete o uso de Python como uma calculadora aritmética?

#+begin_src python
  pi = 3.14
  valor = pi + 2
  print(valor)
#+end_src

#+RESULTS:
: 5.140000000000001

** Operadores lógicos

Variáveis lógicas (também conhecidas como variáveis booleanas) são objetos que podem assumir apenas dois valores diferentes: verdadeiro ou falso. Na sintaxe de Python, escrevemos verdadeiro ou falso em inglês e com a primeira letra maiúscula: ~True~ ou ~False~.

Uma expressão booleana é uma expressão que, quando resolvida, resulta em um valor verdadeiro (~True~) ou em um valor falso (~False~). Expressões booleanas podem ser escritas com os operadores lógicos E (~and~), OU (~or~), e NÃO (~not~). Os operadores ~and~ e ~or~ são chamados de operadores binários pois requerem sempre dois argumentos para serem resolvidos. A sintaxe para usar estes operadores com os argumentos ~A~ e ~B~, por exemplo, é a seguinte: ~A and B~ e ~A or B~.

*[A]* Escreva e execute o código abaixo; comente sobre qual ou quais situações o operador ~and~ retorna o valor ~True~.

#+begin_src python
  print(True and True)
  print(True and False)
  print(False and True)
  print(False and False)
#+end_src

#+RESULTS:
: True
: False
: False
: False

Se quisermos, podemos rescrever o código acima usando variáveis para facilitar a visualização:

#+begin_src python
  A = True
  B = False

  print(A and A)
  print(A and B)
  print(B and A)
  print(B and B)
#+end_src

#+RESULTS:
: True
: False
: False
: False

*[B]* Escreva e execute um código similar ao código acima, substituindo ~and~ por ~or~; comente sobre qual ou quais situações o operador ~or~ retorna o valor ~True~.

O operador ~not~ é um operador unário; ele requer apenas um argumento para ser computado. A sintaxe para usar este operador com o argumento ~A~, por exemplo, é a seguinte: ~not A~.

*[C]* Escreva e execute o código abaixo e comente sobre como o operador ~not~ funciona.

#+begin_src python
  print(not True)
  print(not False)
#+end_src

#+RESULTS:
: False
: True

Operadores lógicos podem ser combinados na mesma declaração. Sempre que for fazer uma combinação de operadores lógicos, lembre-se de usar o parênteses para garantir a ordem de execução desejada.

#+begin_src python
  A = True
  B = False
  print((A or B) and not (B and A))
#+end_src

#+RESULTS:
: True

** Operadores de comparação

Operadores de comparação (também conhecidos como operadores relacionais) fazem exatamente o que o nome sugere: comparam dois objetos. O resultado dessa comparação é uma variável booleana (~True~ ou ~False~).

Existem 6 operadores de comparação em Python:
+ igualdade (~==~)
+ diferença (~!=~)
+ maior que (~>~)
+ menor que (~<~)
+ maior ou igual que (~>=~)
+ menor ou igual que (~<=~)

*[A]* Suponha que ~A = 1~, ~B = 2~, ~C = 4~, ~D = 8~, e ~E = 16~. Atribua o valor verdadeiro ou falso para cada uma das expressões abaixo. Escreva um código em Python para checar se você acertou. Comente sobre como funcionam as expressões com mais de um operador de comparação.

#+begin_src python
  A == B
  A < B
  B > C
  D <= E
  A != E
  E >= D >= C
  A < C == D
  A + A != B
  A + A < B < C - B
  A + A <= B <= C - B
  A != B < C == E - D - C
#+end_src

_Cuidado_: é muito comum confundir o operador de atribuição (~=~) com o operador de comparação de igualdade (~==~). O operador de atribuição é usado para atribuir um valor a uma variável, por exemplo: ~A = 10~ atribui o valor 10 para a variável ~A~. Já o operador de comparação de igualdade responde a pergunta se os objetos sendo comparados são iguais. Neste caso, a expressão ~A == 10~ responde a pergunta se o valor armazenado em ~A~ é igual a 10, resposta esta que pode ser verdadeiro ou falso.

** Estrutura de decisão e operador condicional

Em diversos momentos da vida nos adaptamos mediante às condições do ambiente. Por exemplo, ao sair de casa, /se/ estiver chovendo /então/ pegamos o guarda-chuva, /se não/ nós saímos de casa sem o guarda-chuva. Esta estrutura condicional também existe nas linguagens de programação. Em certos momentos, queremos que a execução de um ou mais comandos só ocorra caso uma ou mais condições sejam atendidas.

*[A]* Em que outros momentos da sua vida você faz escolhas segundo uma estrutura condicional contendo /se/, /então/, e /se não/? Escreva sobre três destes momentos dizendo como você se comporta (tome como base o exemplo do guarda-chuva).

O exemplo do guarda-chuva pode ser escrito em Python. Vamos supor que a variável booleana ~esta_chovendo~ armazena o valor ~True~ caso esteja chovendo ou o valor ~False~ caso não esteja chovendo. Queremos armazenar na variável booleana ~pegar_guardachuva~ o valor de ~True~ para o caso onde vamos pegar o guarda-chuva e o valor de ~False~ para o caso onde não vamos pegar o guarda-chuva. O código abaixo ilustra uma forma possível de programar essa decisão em Python (note o uso dos dois-pontos na sintaxe abaixo!).

#+begin_src python -n
  esta_chovendo = True  # troque esse True for False para ver o que acontece

  if esta_chovendo == True:
      pegar_guardachuva = True
      print("Vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

No código acima, o comando ~if~ checa se a condição "~esta_chovendo == True~" é verdadeira. Esta condição será verdadeira se a variável ~esta_chovendo~ tiver o valor ~True~. Existem duas possibilidades:

1) Se a condição checada for /verdadeira/, o bloco do ~if~ será executado e o bloco do ~else~ será ignorado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão executadas e as linhas 7 e 8 não serão executadas);

2) Se a condição checada for /falsa/, o bloco do ~if~ será ignorado, e o bloco do ~else~ será executado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão ignoradas e as linhas 7 e 8 serão executadas).

Independentemente do resultado do teste da condição, a primeira e a última linha do código serão executadas pois elas não estão dentro da estrutura de decisão.

Observe que a sintaxe de estruturas de decisão requer que o bloco referente ao ~if~ e o bloco referente ao ~else~ estejam /indentados/. Indentação de código é quando utilizamos uma certa quantidade de espaços para agrupar visualmente linhas de código pertencentes a um mesmo bloco. Segundo o guia de estilo do Python (chamado de PEP8 caso tenha curiosidade de saber mais), é recomendado usar 4 espaços para indentar seu código.

É bom saber que se seu código não estiver indentado corretamente, ele muito provavelmente não irá realizar a tarefa que você tinha em mente. Em certos casos, uma falha e indentar corretamente seu programa irá acusar um erro. Tente rodar o código abaixo e veja o que acontece (veja que ele é o mesmo código que vimos acima, porém sem indentação).

#+begin_src python -n
  esta_chovendo = True  # troque esse True for False para ver o que acontece

  if esta_chovendo == True:
  pegar_guardachuva = True
  print("Vou pegar o guarda-chuva")
  else:
  pegar_guardachuva = False
  print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

*[B]* Escreva um código de Python para cada um dos três momentos de decisão que você descreveu na questão *A*.

É bastante comum nos depararmos com situações onde nossa decisão depende de mais de uma condição. Digamos, por exemplo, que só queremos pegar o guarda-chuva se estiver chovendo e se for um dia de semana (do contrário, decidimos que vamos ficar em casa e não precisamos do guarda-chuva). Para isso precisaremos de um ~if~ adicional; veja o exemplo abaixo e note que o contexto de cada bloco de código é ditado pela sua indentação (sempre em múltiplos de 4 espaços).

#+begin_src python
  esta_chovendo = True
  final_de_semana = False

  if esta_chovendo == True:
      if final_de_semana == False:
          pegar_guardachuva = True
          print("Vou pegar o guarda-chuva")
      else:  # este else está relacionado ao if da variavel final_de_semana
          pegar_guardachuva = False
          print("Não vou pegar o guarda-chuva")
  else:  # este else está relacionado ao if da variavel esta_chovendo
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

*[C]* Pense em uma situação onde você precisa considerar duas condições para tomar uma decisão e escreva ela em um código de Python.

A linguagem Python contém uma série de expressões que são o que chamamos de /açúcar sintático/. Um açúcar sintático é uma forma de comunicar uma informação de maneira mais fácil ou mais expressiva. O código acima pode ser reescrito da seguinte maneira:

#+begin_src python
  esta_chovendo = True
  final_de_semana = False

  if esta_chovendo:
      if not final_de_semana:
          pegar_guardachuva = True
          print("Vou pegar o guarda-chuva")
      else:
          pegar_guardachuva = False
          print("Não vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

*[E]* Teste e reporte se novo código funciona. O que mudou em comparação com o original? Explique como funciona o açúcar sintático exemplificado acima. Na sua opinião, este tipo de açúcar sintático facilitou a sua leitura do código?

*[D]* Reescreva o código acima de forma que ele se comporte da mesma maneira, porém usando apenas um ~if~ e apenas um ~else~. Dica: pense em qual operador lógico poderia te ajudar aqui!

O código abaixo checa em qual faixa está o valor de pH fornecido (https://pt.wikipedia.org/wiki/PH) e reporta para o usuário se sua solução é ácida, básica, neutra, ou se houve algum equívoco e o valor de pH é inválido. Veja que a cláusula ~else~ é opcional e não foi usada no código abaixo.

#+begin_src python -n
  # teste o código com diferentes valores para a variável ph
  ph = 7

  if (ph < 0) or (ph > 14):
      print("pH inválido")

  if 0 <= ph < 6.5:
      print("pH ácido")

  if 6.5 <= ph <= 7.5:
      print("pH neutro")

  if 7.5 < ph <= 14:
      print("pH básico")
#+end_src

#+RESULTS:
: PH neutro

Imagine que você mediu o pH de um vinagre e obteve o valor de 2,5. Ao rodar o código acima, o programa irá te dizer "pH ácido" (teste você mesma(o)!). Veja que o programa poderia ter parado de rodar depois de resolver o ~if~ da linha 7 (afinal, não faz sentido checar se o pH é neutro ou básico após identificar que se trata de um pH ácido), porém ele *irá* rodar os ~if~ das linhas 10 e 13.

*[E]* Reescreva o código acima usando cláusulas ~else~ de forma que o programa não rode nenhuma cláusula ~if~ desnecessária para entregar a resposta ao usuário (isto é: após ter encontrado a resposta, nenhum outro ~if~ deve ser executado).

Uma estrutura muito comum em programação é quando queremos dizer "se a condição testada não for verdadeira, então teste esta outra condição aqui". Para isso usamos a cláusula ~elif~ que seria um ~else~ com um ~if~ "grudados". O código abaixo é similar ao anterior, porém usando ~elif~

#+begin_src python -n
  # teste o código com diferentes valores para a variável ph
  ph = 7

  if 0 <= ph < 6.5:
      print("pH ácido")

  elif 6.5 <= ph <= 7.5:
      print("pH neutro")

  elif 7.5 < ph <= 14:
      print("pH básico")

  else:
      print("pH inválido")
#+end_src

#+RESULTS:
: pH neutro

O código acima checa se o pH é ácido. Caso seja ácido o programa exibe "pH ácido" para o usuáro e nada mais será executado. Caso não seja ácido, o programa checa então se é neutro. Caso seja neutro o programa exibe "pH neutro" para o usuário e nada mais será executado. Caso não seja neutro também, o programa faz uma última checagem para confirmar se é um pH básico. Assim sendo o usuário verá o texto "pH básico" e o programa se encerra. Se o pH não for ácido, nem neutro, nem básico, então podemos afirmar que o programa recebeu um valor inválido de pH.

*[F]* Escreva um programa similar ao programa do pH que checa alguma grandeza escalar e exibe para o usuário uma informação sobre esta grandeza. Utilize pelo menos duas cláusulas ~elif~ no seu programa.

Além da estrutura de decisão ~if~/~else~ existe o operador condicional. É importante saber que ele existe, porém na maioria dos casos é preferível que você use a estrutura de decisão mesmo por ser uma construção mais legível. O exemplo abaixo mostra uma estrutura condicional e o operador condicional, ambos realizam a mesma tarefa. Note que a cláusula ~else~ é opcional na estrutura condicional porém obrigatória no operador condicional.

#+begin_src python
  condicao = True

  # estrutura condicional
  if condicao:
      a = 100
  else:
      a = 5

  # operador condicional
  a = 100 if condicao else 5
#+end_src

* Listas, tuplas, e conjuntos
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_listas
:EXPORT_OPTIONS: toc:t
:ID:       979099a4-9da2-48d1-9d6a-308a97868f1c
:END:

** Agrupando objetos com listas
Vamos começar pensando no seguinte cenário, você está em casa e não tem nada para comer, portanto, precisa ir até o supermercado comprar ingredientes para uma receita. A primeira coisa que vem a sua cabeça é comprar um pacote de miojo, afinal, é fácil de preparar. Mas, sua fome está grande, então poderia comprar dois pacotes de miojo, mas isso não parece tão atraente. Lhe ocorre a ideia de encrementar o miojo, posso adicionar queijo ralado, talvez cozinhar um ovo junto com o miojo. Além disso, você resolve comprar uma bebida para acompanhar, um refrigerante. Então, você lembra que a pasta de dentes está acabando, então decide comprar também, para aproveitar a ida ao mercado. O número de itens a se comprar já começa a ficar grande, então é melhor organizar suas compras em uma lista. Vamos escrever tal lista então:
+ Miojo
+ Queijo Ralado
+ Ovo
+ Pasta de Dentes

Maravilha! Agora você pode ir ao mercado fazer minhas compras. Então você passa no banheiro antes de sair e nota que falta papel higiênico. Hora, então você adiciona mais este item em sua lista, agora ela passa a ser assim:
+ Miojo
+ Queijo Ralado
+ Ovo
+ Pasta de Dentes
+ Papel Higiênico

Ótimo, agora está tudo pronto e você vai ao mercado fazer suas compras!

*** Listas Simples
Este tipo de organização de itens ou objetos em listas é muito prático, podemos então aplicar o mesmo conceito a programação. Vamos criar uma lista de compras em um código Python, a sintaxe será a seguinte:
#+begin_src python
listadecompras = ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes']
print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes']

Poxa, mas esqueci de incluir o Papel Higiênico na lista! Tudo bem, podemos adicionar itens a nossa lista com o método append do Python. Façamos o seguinte:

#+begin_src python
listadecompras.append('Papel Higiênico')
print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Papel Higiênico']

Perfeito, veja que o item foi adicionado a sua lista.

*** Listas dentro de listas.

Agora voltando a sua saída ao supermercado, antes de sair você lembra que precisa comprar um caderno, papel e caneta. Mas, infelizmente o mercado que você irá não tem esses itens, você precisará ir a papelaria ao lado para comprar esses itens. Então você naturalmente faz uma nova lista de compras para a papelaria, incluindo os itens necessários.
+ Caderno
+ Papel
+ Caneta

No Python, podemos fazer listas dentro de listas, então vamos fazer uma lista de listas com os objetos do mercado e da papelaria:

#+begin_src python
listadecompras = [['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes'], ['Caderno', 'Papel', 'Caneta']]
print(listadecompras)
#+end_src

#+RESULTS:
: [['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes'], ['Caderno', 'Papel', 'Caneta']]

Agora você pode notar que temos duas listas na listadecompras, uma com os itens do mercado e uma com os itens da papelaria.
Podemos imprimir as listas individualmente, para isso façamos o seguinte:

#+begin_src python
print(listadecompras[0])
print(listadecompras[1])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes']
: ['Caderno', 'Papel', 'Caneta']

Note que primeiro é impresso a primeira lista, de índice 0 e depois a segunda lista, de índice 1. Lembrando que no Python a contagem começa sempre de zero.
Perfeito, mas agora deu vontade de comer uma sobremesa após o seu miojo incrementado, então você quer adicionar este item a lista do supermercado. Além disso, você achou que convém comprar um pacote de post-it, para colocar na geladeira, para não esquecer tanto dos itens que você tem que comprar. Portanto, é necessário adicionarmos estes itens nas listas. Podemos fazer isso com a seguinte sintaxe no Python:

#+begin_src python
listadecompras[0].append('Chocolate')
listadecompras[1].append('Post-it')
print(listadecompras[0])
print(listadecompras[1])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: ['Caderno', 'Papel', 'Caneta', 'Post-it']

Pronto, as listas estão atualizadas com os itens que você incluiu.

*** Modificando, particionando, e desempacotando listas

Já foi apresentado a vocês um dos métodos utilizados em listas, o append. Mas, existem outros métodos para listas, a seguir apresentaremos alguns deles.
Vamos volta a nossa lista de compras. Você mudou de ideia quanto a sua sobremesa, não querendo mais o chocolate, mas sim um flan pronto de pote. Então precisamos remover o chocolate e inserir o flan. Vamos então remover o chocolate e adicionar o flan.

#+begin_src python
listadecompras[0].remove('Chocolate')
listadecompras[0].append('Flan')
print(listadecompras[0])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Flan']

Agora sim, podemos ver que a alteração foi realizada como você queria.
E caso você queira saber se já existe algo na lista, seria tedioso consultar toda a lista para conferir. No entanto, existe um método de listas do Python para fazer isto, chamada count. Vamos fazer um exemplo, para conferir se o miojo está na lista:

#+begin_src python
print(listadecompras[0].count('Miojo'))
#+end_src

#+RESULTS:
: 1

Note que o programa retorna "1", ou seja, ele está lhe dizendo que há o Miojo na lista uma vez. Agora teste escrever a palavra miojo somente em letras minúsculas, o que acontece?
Além disso, o programa retornou um número, ou seja, você poderia ter mais que uma ocorrência para o item consultado. Isso signica que podem existir itens duplicados na lista, caso você tivesse adicionado miojo suas vezes, o count retornaria 2.

Existem vários métodos de listas no Python, que serão muito úteis na sua vida de programação. Abaixo seguem alguns e suas explicações:
+ insert: Adiciona um elemento na posição especificada.\\
	Exemplo: listadecompras[0].insert(0,'Banana'), adiciona Banana na primeira posição da lista.\\
	Pergunta: O que acontece com os outros elementos?
+ extend: Adicionar vários elementos no final da sua lista.\\
	Exemplo: listadecompras[0].extend(['Pão', 'Queijo', 'Presunto'])
	Pergunta: Os elementos foram adicionados corretamente? Note que ao invés de adicionar os itens na sintaxe anterior, você poderia adicionar outra lista, definida anteriormente.
+ index: Retorna o índice do primeiro elemento com o valor requisitado.\\
	Exemplo: listadecompras[0].index('Ovo')\\
	Pergunta: O índice reportado é o que você esperava?
+ pop: Remove o elemento da posição requida.\\
	Exemplo: listadecompras[0].pop(5)\\
	Pergunta: Qual item foi removido? Foi o esperado?
+ sort: Ordena sua lista de maneira crescente, tanto com números como ordem alfabética. Note que você pode ordenar a lista, mas não a lista dentro da lista.\\
	Desafio: Como você faria para ordenar suas duas listas de compras, tendo no final ainda as duas listas dentro de uma lista de listas?
#+RESULTS:
: mercado = listadecompras[0]
: mercado.sort()
: print(mercado)
: papelaria = listadecompras[1]
: papelaria.sort()
: print(papelaria)
: listadecompras = []
: listadecompras.append(mercado)
: listadecompras.append(papelaria)
+ reverse: Inverte a ordem de sua lista. Novamente tome cuidado pois este método ordena listas, não listas dentro de listas. Além disso, ele simplesmente reverte a ordem existente, ou seja, ele não coloca em ordem decrescente.\\
	Desafio: Inverta a ordem da lista ordenada alfabeticamente com a função sort.\\
	Pergunta: Existe uma maneira mais direta de se ordenar de maneira decrescente (ou alfabética ao contrário)?
#+RESULTS:
: mercado = listadecompras[0]
: mercado.reverse()
: print(mercado)
: papelaria = listadecompras[1]
: papelaria.reverse()
: print(papelaria)
: listadecompras = []
: listadecompras.append(mercado)
: listadecompras.append(papelaria)
: print(listadecompras)

*** Particionamento de listas.
Já foi apresentado como acessar um item específico da lista anteriormente, com o argumento entre colchetes (listadecompras[0]). Porém, podemos particinar as listas, pegando vários elementos de interesse. Novamente utilizaremos índices entre colchetes, com a seguinte sintaxe: lista[Inicial:Final:Passo]. O 'Inicial' é o primeiro elemento da lista que desejamos, 'Final' é o elemento final desejado. Já 'Passo' é o de quantos em quantos elementos queremos, por exemplo, se o passo for 1, todos elementos na faixa específicada são impressos, se o passo for 2, só serão fornecidos elementos a cada dois. Vamos exemplificar para facilitar:

#+begin_src python
print(listadecompras[0][0:6:2])
#+end_src

Porque temos dois colchetes? Porque estamo particionando a primeira lista de nossa lista de listas. No primeiro colchetes [0], estamos específicando a primeira de nossas duas listas. No segundo colchetes estamos particionando a lista começando do elemento zero até o elemento 6, pulando de dois em dois.
A saída do código anterior é ['Queijo Ralado', 'Pão', 'Ovo'], sendo que nossa lista completa é ['Queijo Ralado', 'Queijo', 'Pão', 'Pasta de Dentes', 'Ovo', 'Miojo', 'Flan', 'Banana']. Logo foram impressos os elementros 0, 2 e 4. Mas o elemento 6 também não deveria ser impresso? Parece lógico, mas, como o Python começa sua contagem de zero, ao invés de um, sempre que especificamos faixas de valores o elemento final do intervalo não é considerado. Portanto, caso queira o último elemento incluso sempre considere n+1. Façamos isso então:

#+begin_src python
print(listadecompras[0][0:7:2])
#+end_src

Com este comando o código imprimiu ['Queijo Ralado', 'Pão', 'Ovo', 'Flan'], incluindo o sexto elemento da lista. Então, tenha isso sempre em mente com o Python, a contagem começa em zero e o último elemento das faixas de valores não é incluído. Também podemos utilizar índices negativos no particionamento de listas, mas como assim? O que acontece quando usamos índices negativos? Basicamente a contagem é de traz para frente. Então, se pedirmos a seguinte faixa [-4,-1] para nossa lista de compras do supermercado, o código imprimirá ['Ovo', 'Miojo', 'Flan'], sendo esses os elementos -4, -3 e -2, já que o último elemento não vai ser incluído por ser o final do intervalo. Se quisermos também o último elemento e colocarmos o intervalo como [-4:0] teremos um erro de sintaxe, então, para obter os quatro últimos elementos a sintaxe correta será [-4:], que irá imprimir do elemento -4 até o último.

** "Tuplas"
Existe outro tipo de dados no Python que são chamadas tuplas. As tuplas são basicamente listas imutáveis. Como assim imutáveis? Isso significa que uma vez que ela foi definida, não podemos mais adicionar ou remover elementos, bem como não é possível modificar sua ordem. Então, voltando ao nosso exemplo do supermercado, se você quiser estabelecer alguns itens que serão comprados recorrentemente, podemos colocá-los em uma tupla. Vamos a um exemplo:

#+begin_src python
itensrecorrentes = ("Miojo", "Ovo", "Queijo Ralado")
print(itensrecorrentes)
#+end_src

Então, agora esta tupla será composta sempre por estes itens, não podendo modificá-los ou alterar sua ordem. Por conta disso as tuplas só tem dois métodos possíveis, o count e o index, que tem a mesma função que nas listas, que é contar quantos itens existem na tupla e qual o índice do objeto requisitado.
O interessante é que podemos utilizar o método extend das listas incluindo a tupla. Vamos criar uma nova lista então:

#+begin_src python
listadecompras = []
listadecompras.extend(itensrecorrentes)
print(listadecompras)
#+end_src

Na primeira linha inicializamos uma lista vazia, apenas para criá-la, para poder utilizar o método extend nela na segunda linha. Podemos ver que agora temos uma lista criada a partir da tupla, então podemos voltar a adicionar os itens de interesse.

** "Cópia rasa e cópia profunda"

Agora vamos tratar de cópias no Python. Para listas o Python tem uma maneira bastante peculiar para cópias, onde são criados links entre as listas e não simplesmente copiados os objetos. Vamos a um exemplo para deixar mais claro:

#+begin_src python
lista1 = ("Miojo", "Ovo", "Queijo Ralado") #Defição da lista1 com seus objetos
lista2 = lista1                            #Criamos uma lista2 igual a lista1
print("Lista 1 Original")                  #
print(lista1)                              #Imprime a lista1
print("Lista 2 Original")                  #
print(lista2)                              #Imprime a lista2
lista2[2] = "Orégano"                      #Altera o elemento 2 da lista2 para Orégano
print("Lista 2 Alterada")                  #
print(lista2)                              #Imprime a lista2 alterada
print("Lista 1 depois de alterar lista 2") #
print(lista1)                              #Imprime a lista1 após a alteração da lista2
#+end_src

Bom, nesse código definimos uma lista1, criamos uma lista2 igualando a lista1, por fim alteramos a lista2. Como a cópia é criada com links, ou vínculos, a lista1 e a lista2 dependem uma da outra. Então, quando a lista2 foi alterada, a lista1 também foi, como vocês podem notar na saída do código. Isso pode ser interessante para alguns casos, porém, na maioria das vezes o desejável é ter dados independentes uns dos outros. Para isso, precisamos utilizar o método deepcopy do Python, que é uma cópia profunda, sem vínculos com o objeto anterior. Para isso precisamos importar a função copy e utilizar o método deepcopy, como segue:

#+begin_src python
import copy
lista1 = ("Miojo", "Ovo", "Queijo Ralado") #Defição da lista1 com seus objetos
lista2 = copy.deepcopy(lista1)             #Criamos uma lista2 igual a lista1
print("Lista 1 Original")                  #
print(lista1)                              #Imprime a lista1
print("Lista 2 Original")                  #
print(lista2)                              #Imprime a lista2
lista2[2] = "Orégano"                      #Altera o elemento 2 da lista2 para Orégano
print("Lista 2 Alterada")                  #
print(lista2)                              #Imprime a lista2 alterada
print("Lista 1 depois de alterar lista 2") #
print(lista1)                              #Imprime a lista1 após a alteração da lista2
#+end_src

** "Desempacotamento e Operador Asterisco"
No Python podemos utilizar uma notação específica para definir várias variáveis ao mesmo tempo, como segue:

#+begin_src python
item0, item1, item2 = "Miojo", "Ovo", "Queijo"
print(item0)
print(item1)
print(item2)
#+end_src

Notem que item0="Miojo", item1="Ovo" e item2="Queijo". Podemos utilizar isso para desempacotar uma lista, por exemplo:
#+begin_src python
lista = ["Miojo", "Ovo", "Queijo"]
item0, item1, item2 = lista
print(item0)
print(item1)
print(item2)
#+end_src

Os elementos a, b e c estão definidos de acordo com os elementos da lista. Porém, caso a lista não tenha a mesma dimensão do número de variáveis que estamos definindo, o que acontece? Para averiguar, utilize o código a seguir:

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]
item0, item1, item2 = lista
#+end_src

Note que o código retornou com o erro "ValueError: too many values to unpack (expected 3)". Ou seja, ele esperava três valores mas recebeu mais que isso. Para lidar com este tipo de situação podemos utilizar o operador asterisco, que pegará os elementos restantes e atribuirá a variável indicada, por exemplo:

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]
item0, item1, *resto = lista
print(item0)
print(item1)
print(resto)
#+end_src

Agora nosso comando funciona! Tivemos então o item0="Miojo", item1="Ovo" e resto=['Queijo', 'Pão', 'Orégano']. A posição do operador asterisco não precisa ser necessáriamente na última variável, ela pode ficar na primeira, ou na do meio, por exemplo:

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]
item0, *item1, item2 = lista
print(item0)
print(item1)
print(item2)
*item0, item1, item2 = lista
print(item0)
print(item1)
print(item2)
#+end_src

Como se comportou o código de acordo com onde ficou o asterisco?

** "Conjuntos são listas sem elementos repetidos"
Ainda nos tipos de objetos do Python, ainda temos os conjuntos, que são basicamente listas sem elementos repetidos. Os conjuntos possuem seus métodos específicos também, que englobam métodos equivalentes aos das listas, como: remove(), pop(). Mas especificamente para conjuntos, temos operações matemáticas já conhecidas, como união e intersecção. Vamos definir dois conjuntos e operá-los, com nossa analogia de listas de compras, vamos pensar que você fez anotações para compras em dois lugares diferentes e agora você quer juntá-las.

#+begin_src python
conjunto1 = {"Miojo", "Ovo", "Queijo"}
conjunto2 = {"Miojo", "Pão", "Queijo", "Orégano", "Pão"}
print(conjunto1)
print(conjunto2)
#+end_src

Note que para a definição de conjuntos colocamos os elementos entre chaves {}, diferente das listas que colocamos entre colchetes [] e das tuplas que colocamos entre parênteses (). Além disso, no conjunto2 o elemento pão foi adicionado duas vezes, o que aconteceu quando você imprimiu o conjunto2 em relação ao pão?
Agora vamos realizar algumas operações com os conjuntos:

#+begin_src python
intersection = conjunto1.intersection(conjunto2)
print(intersection)
union = conjunto1.union(conjunto2)
print(union)
#+end_src

Os resultados estão de acordo com o que você esperava?
Além desses métodos temos outros exclusivos de conjuntos, como segue:
+ add: Adiciona um elemento ao conjunto. Sintaxe: conjunto.add("Presunto")
+ difference: Faz a subtração de dois conjuntos. Sintaxe: difference = conjunto1.difference(conjunto2)
+ discard: Remove o elemento especificado do conjunto. Parece igual ao remove, mas, neste caso você não terá uma mensagem de erro caso o elemento não exista no conjunto. Sintaxe: conjunto.discard("Banana")
+ update: Com este método você pode incluir um iterável no conjunto, que pode ser outro conjunto, lista, tupla, ...

#+BEGIN_COMMENT
Podemos pedir para os alunos pesquisarem os outros métodos, tem alguns conceitualmente complicados. Mas precisa ver se a aula já não está muito densa.
#+END_COMMENT

* Laço de repetição
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_laco
:EXPORT_OPTIONS: toc:t
:ID:       25e5272b-ad01-463a-815a-7b4345a4b35a
:END:

Laços de repetição, ou seu termo mais comum em inglês o loop, serve para iterar elementos de listas, tuplas, conjuntos ou mesmo números em uma faixa definida. Existem diferentes maneiras de implementar loops, sendo as principais do Python o =while= e o =for=, que mostraremos pra vocês a seguir.

** Laço de repetição usando =while=
Vamos iniciar com um =while loop=, ou laço de repetição com =while=. A tradução da palavra =while= do inglês é =enquanto=, então a ideia deste loop é fazer algo enquanto uma condição não for verdadeira. Vamos começar com um exemplo simples, onde o loop será executado enquanto a variável =i= for menor que 10, e vamos somando 1 a mesma variável a cada iteração. Para isso usamos um operador que não foi apresentado ainda, o =+==, que basicamente soma o valor ou variável indicado após ele, por exemplo, i += 1 é o mesmo que i = i + 1.

#+begin_src python
i = 0
while i < 10:
	print(i)
	i += 1
#+end_src

Fique atento a identação! Assim como no caso dos condicionais (=if=) você precisa colocar a parte da execução identada, pois esta é a maneira do Python interpretar o loop. Note que estamos utilizando os operadores lógicos, que vocês já foram apresentados em uma aula anterior. Eles são fundamenteis para a implementação de loops while, pois quando a condição retornar =False=, o loop irá parar. Na execução do código vocês podem notar que os números de 0 à 9 foram impressos, quando =i= ficou igual a 10 o loop parou, pois a sentença =i < 10= passou a ser =False=. Você pode confirmar isso alterando seu código para o seguinte:

#+begin_src python
i = 0
while i < 10:
      print(i, i < 10)
      i += 1
print(i, i < 10)
#+end_src

Com isso, estamos imprimindo a variável =i= e o valor booleano da operação =i < 10=. Ao final do loop há mais uma operação de print, para mostrar que quando =i = 10= a operação =i < 10= retorna =False=.
*IMPORTANTE*
O uso de loops pode facilmente levar o seu código a loops infinitos! Sempre avalie com cuidado a condição a ser adotada em seu loop, vamos a um exemplo de loop infinito:

#+begin_src python
i = 0
while i < 10:
      print(i, i < 10)
#+end_src

Neste caso, foi esquecido o incrementador de =i= (+=), logo o valor de =i= nunca será alterado! Isso levará o código a rodar indefinidamente, sem nunca parar, teste para você conferir. Esse é um dos erros mais catastróficos em códigos, pois o programa simplesmente executa operações sem parar, muitas vezes utilizando todos os recursos computacionais disponíveis e inutilizando a máquina. Neste caso a única alternativa é terminar o programa forçosamente, ou em alguns casos só reiniciando o computador.

Também temos outra maneira de sair ou continuar em loops, usando o comando =break= e =continue=. Basicamente ao se dar o comando =break=, o loop é interrompido, e se o comando =continue= for utilizado o loop continua sua execução. Isso pode ser útil para se utilizar em conjunto com operadores condicionais, como no exemplo abaixo, onde o código cálcula o máximo divisor de um número fornecido:

#+begin_src python
a = 8733				#Número que desejamos saber o divisor
i = a-1					#Definimos i como a-1, pois se começarmos a testar o divisor como o próprio a, teríamos uma solução trivial
while i > 0:                            #Vamos iterar de a-1 até 1
    print(i)                            #
    b = a/i				#
    if (b - int(b)) == 0:		#Aqui checamos se o resultado da divisão tem componente decimal
        print(a, 'é divisível por', i)  #Caso a parte decimal seja zero, isso significa que a é divisível por i
        break				#Com este break o programa sai do loop
    else:				#Caso a divisão não tenha a parte decimal igual a zero, seguimos por aqui
        i -= 1				#Diminuímos 1 do i
        continue			#Voltamos ao início do loop
#+end_src

O código apresentado está comentado, lembrem-se sempre de comentar seus códigos, pois caso você não comente, niguém além de você o entenderá e depois de algum tempo, nem você mesmo entenderá. Basicamente o código encontra o maior divisor para um número fornecido, testando todos os números menores que ele mesmo até que alguma das divisões tenha componente decimal zero.

*Tarefa*
Modifique o código acima para avisar quando números primos são encontrados.

#+RESULTS:
: a = 17
: i = a-1
: while i > 1:
:     print(i)
:     b = a/i
:     print(b,b - int(b))
:     if (b - int(b)) == 0:
:         print(a, 'é divisível por', i)
:         break
:     else:
:         i -= 1
:         continue
: if (i == 1):
:     print(a,'é primo!')


*Desafio*
Como você faria um código para achar o máximo divisor comum?

#+RESULTS:
: a = 30
: b = 20
:
: if a > b:
:     i = b - 1
: else:
:     i = a - 1
: while a > 1:
:     print(i)
:     div1 = a/i
:     div2 = b/i
:     if ((div1 - int(div1)) == 0) and ((div2 - int(div2)) == 0):
:         print('O MDC entre', a, 'e', b, 'é', i)
:         break
:     else:
:         i -= 1
:         continue

** Laço de repetição usando =for=
A outra maneira de implementarmos loops no Python é utilizando o =for=. Mas antes de entrarmos em seus detalhes, é importante mostrar outra ferramenta do Python, o operador =in=. Com ele podemos checar se um elemento está em uma lista, ou qualquer outro objeto iterável. No exemplo abaixo mostramos sua sintaxe:

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo"]
print("Ovo" in lista)
print("Pão" in lista)
#+end_src

Veja que para o objeto ovo o código retornou =True=, já para pão, o código retornou =False=. Ou seja, ele confirmou que há ovo na lista e que não há pão. Para implementarmos um loop com for, iremos utilizar a seguinte sintaxe: =for item in lista=, desta maneira a variável item assumirá os o valor dos objetos presentes na lista, um a um. Confira o exemplo abaixo:

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
for item in lista:
	print(item)
#+end_src

Note que a cada iteração o código imprime a variável item, que assume os valores da lista do primeiro ao último. Podemos então usar condicionais ou manipular de várias maneiras os dados. Por exemplo, você quer que quando houver pão na sua lista de compras, seja automáticamente incluídos queijo, presunto e manteiga. Para isso vamos criar um operador condicional, que confere se um dos itens é pão, caso seja então adicionamos os itens desejados.

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
for item in lista:
        print(item)
        if item == "Pão":
                lista.append["Queijo", "Presunto", "Manteiga"]
print(lista)
#+end_src

Pronto, agora se você adicionar pão a lista serão adicionados os itens queijo, presundo e manteiga, assim você pode fazer seu misto quente! Agora, note que já havia queijo na lista e ele foi adicionado novamente. Como você faria um código que não adicionasse o queijo duplicadamente?

#+RESULTS:
: set1 = {"Miojo", "Ovo", "Queijo", "Orégano", "Pão"}
: set2 = copy.deepcopy(set1)
: for item in set1:
:         print(item)
:         if item == "Pão":
:                 set2.update({"Queijo", "Presunto", "Manteiga"})
: print(set2)
:
: lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
: for item in lista:
:         print(item)
:         if item == "Pão":
:             if lista.count("Queijo") == 0:
:                 lista.append("Queijo")
:             if lista.count("Presunto") == 0:
:                 lista.append("Presunto")
:             if lista.count("Manteiga") == 0:
:                 lista.append("Manteiga")
: print(lista)

Além de iterar em listas, o =for loop= pode ser utilizado em faixas de números, para isso devemos utilizar o operador =range=. Por exemplo, se quisermos iterar os números de 0 à 10, podemos fazer o seguinte:

#+begin_src python
for number in range(0,11):
        print(number)
#+end_src

A saída do código lhe dará os números de 0 à 10, um em cada linha. Mas note que a faixa que colocamos é de 0 à 11! Novamente o fato do Python começar a contar do zero leva ao intervalo aberto no final da faixa, como discutido anteriormente. Então, tenha sempre em mente isso para não perder o último número da sua faixa.

Também podemos definir o passo a ser utilizado, o padrão é iterar de um em um, mas podemos mudar isso, veja o exemplo abaixo:

#+begin_src python
for number in range(0,11,2):
	print(number)
#+end_src

O código imprime os números 0, 2, 4, 6, 8 e 10. Ou seja, o passo mudou para 2. Também podemos utilizar um passo negativo, colocando a faixa como (0,11,-1) será impressa a ordem decrescente. Isso é bastante útil em um caso bem simples, o cálculo de fatoriais. Vamos calcular o fatorial de 10 para exemplificar:

#+begin_src python
fatorial = 1			#Definimos um valor inicial para o fatorial
for number in range(4,1,-1):	#Iteramos de 4 à 2, com passo de -1
    print(number)		#Imprime o número da iteração
    fatorial = fatorial*number  #Multiplicamos a variável fatorial pelo número sendo iterado
print(fatorial)			#Imprime o resultado do fatorial
#+end_src

O código é simples mas tem alguns conceitos novos nele. Já na primeira linha definimos a variável =fatorial = 1=, porque isso, já que a utilizaremos no loop? Comente a primeira linha e confira o que acontece. Outro ponto é que iteramos de 4 a 2 e não de 4 a 1, o fatorial é definido por =4! = 4*3*2*1=, porém, qualquer número multiplicado por 1 é ele mesmo, logo não faz diferença multiplicarmos por 1, já que o resultado não é alterado. Assim, evitando uma multiplicação economizamos tempo computacional, pode parecer pouca coisa, mas, várias dessas otimizações em um código grande podem levar a ganhos significativos de performance.

*Tarefa:* Refaça o código para encontrar números primos agora utilizando o =for loop=. /Dica: Utilize o operador =%=/.

#+RESULTS:
: a = 17
: for i in range(a-1,0,-1):
:     c = a % i
:     if c == 0 and i != 1:
:         print(a, 'é divisível por', i)
:         break
:     elif i == 1:
:         print(a, 'é primo')
:     else:
:         print(a, 'não é divisível por', i)

** Laços Aninhados
Além de utilizarmos laços (loops) aliados a condicionais, também podemos ter loops dentro de loops. Vamos voltar a nossas listas de compras, agora precisamos checar o que temos na lista da padaria e do supermercado, para ver se não temos nada repetido, vamos ao exemplo:

#+begin_src python
listadecompras = [['Miojo', 'Queijo', 'Ovo', 'Pasta de Dentes', 'Chocolate'], ['Pão', 'Queijo', 'Presunto', 'Sonho']]   #Definindo uma lista de listas com itens de mercado e da padaria
print('Lista do supermercado antes da conferência:', listadecompras[0])							#Imprime lista do supermercado
print('Lista da padaria antes da conferência:', listadecompras[1])							#Imprime lista da padaria

for item1 in listadecompras[0]:												#Loop nos itens do supermercado
        for item2 in listadecompras[1]:											#Loop nos itens da padaria
                if item1 == item2:											#Checa se os itens são iguais
                        listadecompras[0].remove(item1)									#Se forem iguais, são removidos da lista do supermercado
print('Lista do supermercado após a conferência:', listadecompras[0])							#Imprime a lista do supermercado
print('Lista da padaria após a conferência:', listadecompras[1])							#Imprime a lista da padaria
#+end_src

Note que o =Queijo= foi removido da lista da padaria, que era o único item repetido neste caso.

*Tarefa:* Escreva um código para encontrar todos números primos de uma faixa de números.
#+RESULTS:
: start = 1
: end = 1000
:
: listadeprimos = set()
: listadenaoprimos = set()
: for i in range(start,end+1):
:         notprime = 0
:         for j in range(start+1,int(end/2)):
:                 if i % j == 0 and i != j:
:                         notprime = 1
:                         listadenaoprimos.add(i)
:                         print(i, 'é divisível por', j)
:                         break
:         if notprime == 0:
:                 listadeprimos.add(i)
:                 print(i, 'é primo')
:
: print(sorted(listadenaoprimos), 'não são primos')
: print(sorted(listadeprimos), 'são primos')


** Compreensão de listas
Esta ferramenta serve para criarmos novas listas a partir de uma lista existente. Isso pode ser feito com loops por exemplo, mas existe uma forma mais compacta. Vamos primeiro fazer da forma que vocês já foram apresentados então:

#+begin_src python
listadecompras = ["Miojo", "Ovo", "Queijo", "Presunto", "Pão", "Orégano", "Papel Higiênico"]
listadapadaria = []
for item in listadecompras:
	if item == "Pão" or item == "Queijo" or item == "Presunto":
		listadapadaria.append(item)
print(listadapadaria)
#+end_src

No código acima definimos a =listadecompras=, mas separamos alguns itens em uma =listadapadaria=, com os itens do misto quente. Foi feito um loop nos itens =listadecompras= e um condicional para os itens do misto quente. Notem que é possível utilizar vários condicionais juntos, o que é bastante útil. No final a =listadapadaria= acaba está com os itens desejados. Outra maneira que pode reduzir o código significativamente é o uso da compreenção de listas. Veja o exemplo no código abaixo:

#+begin_src python
listadecompras = ["Miojo", "Ovo", "Queijo", "Presunto", "Pão", "Orégano", "Papel Higiênico"]
listadapadaria = [item for item in listadecompras if "Pão" in item or "Queijo" in item or "Presunto" in item]
print(listadapadaria)
#+end_src

Temos o mesmo resultado do loop for, com um código de três linhas, frente ao de seis linhas com o loop. A economia de linhas vem aliada a uma sintaxe um pouco complicada, que merece bastante atenção. Basicamente ela consiste no seguinte: novalista = [espressão =for= item =in= iterável =if= condição verdadeira], a =expressão= para ser qualquer coisa, no exemplo anterior utilizamos o próprio =item= na expressão, sem nenhum operador, mas entraremos em mais detalhes em breve. O =item= é o que será analizada a =condição= e aplicada a =expressão=, já o =iterável= pode ser uma lista, tupla, conjunto, entre outros. Vamos a um exemplo onde aplicamos uma expressão:

#+begin_src python
quadradosimpares = [numero**2 for numero in range(10) if numero % 2 != 0]
print(quadradosimpares)
#+end_src

No exemplo acima a =expressão= é =numero**2=, ou seja tiramos o quadrado do =item= da compreensão. O iterável é a faixa de números de 0 a 9. Já a condição é que o resto da divisão entre o =item= (numero) e 2 seja diferente de zero, que será verdade para os números ímpares. Então a lista =quadradosimpares= terá o quadrado de todos os números ímpares na faixa escolhida. Agora faça o seguinte, delete a condição (if numero % 2 != 0) e execute o código, o que acontece?

Mas porque utilizar esta sintaxe de compreenssão de listas e não continuar utilizando loops? Os programadores são tão preguiçosos que querem fazer tudo em uma linha? Na verdade a maior vantagem da compreensão de listas é a performance. Vamos fazer uma rápida comparação para dar uma ideia, com o código abaixo, que calcula quais são os divisores de um número arbitrário.

#+begin_src python
import time								#Importando a biblioteca que irá cronometrar nosso código.
start = time.time()							#Setando o tempo inicial
a = 1000001								#Definimos um número qualquer
divisor = [i for i in range(1,a) if a % i == 0]				#Método de compreenssão de listas para calcular os divisores
print(divisor)								#Imprime os divisores
print("--- Comprehenssion %s seconds ---" % (time.time() - start))	#Imprime o tempo que o código levou para executar

start = time.time()							#Setando novamente o tempo inicial
divisor = []								#Inicializando a lista dos divisores
for i in range(1,a):							#Início do loop
    if a % i == 0:							#Testa o resto da divisão
        divisor.append(i)						#Acrescenta como divisor se o resto é zero
print(divisor)								#Imprime os divisores
print("--- Loop %s seconds ---" % (time.time() - start))		#Imprime o tempo de execução
#+end_src

No código apresentado calculamos todos divisores do número =a=, execute este código, você verá que os tempos de execução são mais rápidos para o método de compreenssão de listas. Mas poxa, um executou em 0.04 segundos e o outro em 0.05 segundos, não é muita diferença. Pois bem, aumente três zeros no =a= e compare novamente, agora temos a compreenssão de listas executando em 45 segundos e o loop em 60 segundos. Quanto maior o seu número, mais importante será essa diferença. Isso pode ser crucial em muitos casos, pois imagine que você queira fazer uma previsão do tempo para amanhã, mas seu código demora 48 horas para rodar e sua previsão fica pronta depois do dia ter passado? Esse e muitos outros casos tem a performance como algo crítico, tornando a aplicação útil ou não.

Maravilha, conseguimos ganhar um pouco de performance, mas, o código apresentado está fazendo várias operações inúteis. Como assim? Bom, vamos pensar nos divisores de um número, eles certamente não serão maiores que a metade do mesmo, mas estamos tentando dividir por esses números maiores que a metade. Ajuste seu código para dividir só até a metade de =a= e veja a diferença na performance. A diferença é grande não? Se compararmos o loop dividindo por todos os números com a compreenssão de listas dividindo até a metade de =a=, o código leva quase um terço do tempo para executar. Se fosse uma previsão do tempo que levava 48 horas, agora ela levaria pouco mais de 16 horas, ficando pronta antes do próximo dia começar, se tornando útil. Logo parar para pensar na matemática ou lógica do problema ajuda muito na otimização, ainda mais aliado as técnicas computacionais adequadas. Existe alguma outra otimização que lhe vem em mente?

** Compreensão de listas aninhadas

Assim como laços, também podemos aninhar compreensão de listas. Neste caso a sintaxe pode ficar bastante complicada, então é interessante ilustrarmos

[[./img/nested-list-comprehension.png]]

#+ açúcar sintático >> Ver com Daniel

* DANIEL Funções
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_funcoes
:EXPORT_OPTIONS: toc:t
:ID:       b20f8635-108a-49d4-9903-6a397dc4fed2
:END:

** O que é uma função?

Durante o exercício "Olá, Mundo!" nós utilizamos a função ~print~. Naquele momento, definimos funções como sendo "apelidos" para executar códigos que já foram escritos. De fato, esta é uma das grandes vantagens de funções: você escreve o código apenas uma vez e reaproveita ele quantas vezes forem necessárias! Além de economizar tempo, o uso apropriado de funções deixa o propósido do código mais fácil de ser entendido.

De maneira geral, uma função tem quatro partes:

1) um /nome/,
2) zero ou mais objetos chamados de /argumento/,
3) um bloco de código chamado de /corpo da função/,
4) zero ou mais objetos chamados de /retorno/.

Basicamente, ao executar uma função ela recebe zero ou mais objetos (argumento), executa seu bloco de código (usando ou não os argumentos recebidos) e retorna zero ou mais objetos (retorno). Veja que o conceito de função em programação não é o mesmo que o conceito de função em matemática. Certas funções em programação podem ser chamadas de funções matemáticas, porém não todas!

** Funções embutidas

Existem diversas funções embutidas em Python. Estas funções podem ser usadas _a qualquer momento_, sem a necessidade de executar nenhum comando prévio. Além das funções embutidas que já vimos (~print~ e ~help~, por exemplo) existem diversas outras! A lista completa pode ser checada aqui https://docs.python.org/pt-br/3/library/functions.html

*[A]* Existem diversas funções embutidas em Python. Para cada uma das funções abaixo, escreva em uma célula de texto o nome da função, descreva seus argumentos, explique em suas palavras o que a função faz e descreva seus valores de retorno. Na célula seguinte, escreva um código que use esta função.

+ ~any~
+ ~all~
+ ~len~
+ ~abs~

** Definindo novas funções

Podemos definir nossas próprias funções utilizando a instrução ~def~. O código abaixo mostra diversos exemplos de definições de funções. Observe que todas as definições começam com ~def~, seguido do nome da função, seguido de parêntesis e por fim dois-pontos. É considerado bom estilo pular duas linhas antes e depois da definição de funções e nomear funções com a primeira letra minúscula. Ao fim do código as funções definidas são executadas. Para executar funções basta escrever o nome delas seguido de parênteses.

#+begin_src python -n
  def funcao_1():
      print("Esta é a função 1")


  def funcao_2(argumento1):
      print("Esta é a função 2")
      print(argumento1)


  def funcao_3(argumento1, argumento2):
      print("Esta é a função 3")
      print(argumento1)
      print(argumento2)


  def funcao_4(argumento1, argumento2):
      print("Esta é a função 4")
      soma = argumento1 + argumento2
      return soma


  def funcao_5(argumento1, argumento2):
      print("Esta é a função 5")
      return 10


  def funcao_6(argumento1, argumento2, argumento3):
      print("Esta é a função 6")
      return argumento3, argumento2, argumento1


  print('Testando a funcao_1')
  retorno = funcao_1()
  print(retorno)
  print()

  print('Testando a funcao_2')
  retorno = funcao_2("Olá")
  print(retorno)
  print()

  print('Testando a funcao_3')
  retorno = funcao_3("Olá", "mundo")
  print(retorno)
  print()

  print('Testando a funcao_4')
  retorno = funcao_4(1, 2)
  print(retorno)
  print()

  print('Testando a funcao_5')
  retorno = funcao_5(1, 2)
  print(retorno)
  print()

  print('Testando a funcao_6')
  retorno = funcao_6("a", "b", "c")
  print(retorno)
  print()

  print('Testando a funcao_6 novamente')
  retorno1, retorno2, retorno3 = funcao_6("a", "b", "c")
  print(retorno1, retorno2, retorno3)
  print()
#+end_src

#+RESULTS:
#+begin_example
Testando a funcao_1
Esta é a função 1
None

Testando a funcao_2
Esta é a função 2
Olá
None

Testando a funcao_3
Esta é a função 3
Olá
mundo
None

Testando a funcao_4
Esta é a função 4
3

Testando a funcao_5
Esta é a função 5
10

Testando a funcao_6
Esta é a função 6
('c', 'b', 'a')

Testando a funcao_6 novamente
Esta é a função 6
c b a

#+end_example

A ~funcao_1~ não recebe nenhum argumento. Sabemos que este é o caso pois não existe nenhuma informação dentro dos parênteses logo após o ~def funcao_1~. Quando executada, esta função exibe a mensagem "Esta é a função 1". Não existem valores de retorno pois em nenhum local do corpo da função existe a instrução ~return~. Funções que não possuem valor de retorno explícito sempre retornam ~None~ quando encerram sua execução.

A ~funcao_2~ recebe um argumento chamado ~argumento1~. Todos os argumentos recebidos pelas funções podem ser utilizados no corpo da função. No caso desta função, o valor do ~argumento1~ é exibido ao usuário através da função ~print~. Novamente, não existem valores de retorno.

A ~funcao_3~ recebe dois argumentos, ~argumento1~ e ~argumento2~. Note que os nomes dos argumentos são separados por vírgula. Funções podem ter quantos argumentos forem necessários, desde que todos eles sejam declarados no local apropriado (isto é, dentro dos parênteses). Novamente, não existem valores de retorno.

A ~funcao_4~ recebe dois argumentos, calcula a soma deles e retorna este valor. O retorno do valor é feito pela instrução ~return~ no corpo do da função. Observe na linha 48 como podemos armazenar o valor retornado pela função em uma variável.

A ~funcao_5~ recebe dois argumentos e retorna o valor 10. Observe que não é necessário utilizar os argumentos da função no corpo da mesma. No entanto, não é uma boa prática definir argumentos que não serão utilizados no corpo da função.

Finalmente, a ~funcao_6~ recebe três argumentos e retorna os mesmos argumentos em ordem inversa. Observe que a instrução ~return~ permite retornar mais que um valor. Se retornar mais que um valor, estes devem estar separados por vírgulas. Na linha 58 temos uma situação inusitada: a ~funcao_6~ retorna três valores, mas estamos atribuindo o retorno desta função a apenas uma variável chamada ~retorno~. Se você rodar este código perceberá que não ocorrem erros. Neste caso, os três valores de retorno são agrupados em uma tupla e armazenados na variável ~retorno~. Observe a sintaxe da linha 63 para ver como separar os valores de retorno em variáveis independentes.

*[B]* Crie e execute funções para realizar as tarefas abaixo:

+ Uma função que recebe um valor numérico e retorna o cubo deste valor.
+ Uma função que recebe cinco valores e retorna o valor médio e o desvio padrão destes valores.
+ Uma função que recebe uma lista contendo números e retorna uma lista com os números ordenados de forma crescente.

*[C]* Crie uma função que recebe um argumento e tente executar ela sem fornecer nenhum argumento. Após este teste, tente executar ela fornecendo dois argumentos. Observe e relate o que aconteceu.

*[D]* Execute o código abaixo e comente o que ocorre quando executamos a linha 5. Nesta linha a função ~ola~ foi executada sem os parênteses. Seu código rodou com erro ou se erro? De qualquer forma elabore o que aconteceu.

#+begin_src python -n
  def ola():
      return "Olá!"

  print(ola())
  print(ola)
#+end_src

** Argumentos posicionais, argumentos nomeados e argumentos com valor padrão

A ordem dos argumentos é muito importante durante a execução de funções com dois ou mais argumentos. O exemplo abaixo ilustra isso: a inversão da ordem dos argumentos altera o resultado do retorno da função. Cada argumento de uma função tem a sua _posição_, então é necessário se atentar a ordem dos argumentos para evitar erros.

#+begin_src python
  def exponenciacao(base, expoente):
      return base ** expoente


  print(exponenciacao(10, 2))  # resulta em 100
  print(exponenciacao(2, 10))  # resulta em 1024
#+end_src

#+RESULTS:
: 100
: 1024

Todo argumento tem um _nome_. Na função ~exponenciacao~ acima temos dois argumentos, um chamado de ~base~ e outro de ~expoente~. Podemos executar essa função chamando os argumentos pelo nome! Veja no exemplo abaixo.

#+begin_src python -n
  def exponenciacao(base, expoente):
      return base ** expoente


  print(exponenciacao(base=10, expoente=2))  # resulta em 100
  print(exponenciacao(expoente=2, base=10))  # resulta em 100
  print(exponenciacao(10, expoente=2))       # resulta em 100
  print(exponenciacao(expoente=2, 10))       # ERRO!
  print(exponenciacao(expoente=2))           # ERRO!
  print(exponenciacao(base=10))              # ERRO!
#+end_src

#+RESULTS:
: 100
: 100
: 100

Na linha 5 acima, a função ~exponenciacao~ é executada com seus argumentos chamados pelo nome.

Na linha 6 vemos que não é necessário seguir a mesma ordem dos argumentos da função, desde que todos os argumentos necessários sejam nomeados.

Na linha 7 vemos que é possível misturar argumentos nomeados com argumentos posicionais. Neste caso, o valor "10" está na posição zero, logo ele será atribuído à variável ~base~ da função ~exponenciacao~. O valor do argumento ~expoente~ foi nomeado durante a execução e atribuído o valor de "2".

A linha 8 parece similar a linha 7, porém ela não executa! O programa da erro! Isso porque não é permitido argumentos posicionais _após_ argumetos nomeados. Se você for utilizar uma mistura de argumentos posicionais com nomeados, certifique-se que os argumentos nomeados estão todos após os argumentos posicionais.

As linhas 9 e 10 mostram que precisamos garantir que todos os argumentos tenham valores, do contrário a função não executa.

Argumentos nomeados ajudam na leitura do código, principalmente quando as funções e argumentos receberam bons nomes. As linhas 5 e 6 do código acima deixam bem clara a intenção do código.

Por fim, além de uma posição e um nome, argumentos opcionalmente podem ter um _valor padrão_. O valor padrão é atribuido com o operador de atribuição ~=~ logo após o nome do argumento. Veja o exemplo abaixo.

#+begin_src python -n
  def exponenciacao(base, expoente=5):
      return base ** expoente


  print(exponenciacao(base=10, expoente=2))  # resulta em 100
  print(exponenciacao(base=10))              # resulta em 100000
  print(exponenciacao(10))                   # resulta em 100000
  print(exponenciacao(expoente=2))           # ERRO! Falta o valor da base
#+end_src

#+RESULTS:
: 100
: 100000
: 100000

A nova função ~exponenciacao~ tem um valor padrão para o argumento expoente (no caso, é o valor 5). Ela continua funcionando da mesma maneira que a função anterior. Execute a linha 5 e verá que isso é verdade. Com o valor padrão do argumento ~expoente~, podemos executar as linhas 6 e 7 sem problema. Em ambos os casos nós informamos apenas o valor do argumento ~base~ quando executamos a função. Ao fazer isso, informamos a função que ela deve usar o valor padrão para o argumento ~expoente~. Finalmente, a linha 8 resulta em um erro pois o valor para o argumento ~base~ não foi informado para a execução da função ~exponenciacao~.

Observe que não é permitido declarar argumentos sem valor padrão após argumentos com valor padrão. Por conta disso o código abaixo resulta em erro ao ser executado.

#+begin_src python
  def exponenciacao(base=10, expoente):
      return base ** expoente
#+end_src

** Variáveis globais e variáveis locais

Variáveis criadas dentro de funções são locais e só existem dentro do escopo da função. Teste se isso é verdade executando o código abaixo. O que aconteceu?

#+begin_src python -n
  def refeicao():
      opcao_1 = "SPAM"
      opcao_2 = "SPAM"
      opcao_3 = "ovos"
      opcao_4 = "bacon"
      return [opcao_1, opcao_2, opcao_3, opcao_4]

  lanche_da_tarde = refeicao()
  print(opcao_1)
#+end_src

#+RESULTS:

No código acima a função ~refeicao~ declara internamente 4 variáveis, sendo elas ~opcao_1~, ~opcao_2~, ~opcao_3~ e ~opcao_4~. Executamos essa função na linha 8 e na linha 9 tentamos exibir o valor da variável ~opcao_1~. Entretanto, o compilador acusa um erro nos dizendo que a variável ~opcao_1~ não existe! Isso ocorre pois a variável ~opcao_1~ foi declarada dentro do escopo da função ~refeicao~ e ela só faz sentido dentro do escopo onde foi declarada. Além disso, após o término da execução da função todas as suas variáveis locais são destruídas para liberar memória.

** Documentando suas funções com docstring
+ comentar sobre =pep8=

** Funções lambda
+ falar de função recebendo função

* DANIEL Depuração de programas
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_debug
:EXPORT_OPTIONS: toc:t
:ID:       a822fa0b-e43c-4dc6-99f4-0f4f8a2e97fc
:END:

** Meu programa não roda pois dá um erro, e agora?
+ tipos de erros

** Meu programa não faz o que eu queria que ele fizesse, e agora?
+ técnicas de debug
+ pythontutor https://pythontutor.com/visualize.html#mode=edit
+ módulo =pdb=
+ recordar o tópico "buscando ajuda"

** Tratamento de exceções
+ bloco =try= / =except= / =finally=

* Dicionários
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_dicionarios
:EXPORT_OPTIONS: toc:t
:ID:       982992c4-400b-4d79-a738-e86116b14ebc
:END:

** Associando objetos com dicionários
Dicionários são mais uma maneira de guardarmos informações, que pode ser bastante interessante para organização. Vamos dar um exemplo que já foi tratado nesse curso, as listas de compras. Lembram do nosso miojo incrementado, os itens para comprar na papelaria e os da padaria para fazer o misto quente? Estavamos os guardando em listas de listas, mas, podemos os guardar em dicionários também e com uma melhor organização. Vamos para um exemplo onde mostramos a sintaxe e a estrutura dos dicionários:

#+begin_src python
dicionariodecompras = {						#Iniciamos a definição do dicionário
  "mercado": ["Miojo", "Ovo", "Orégano", "Papel Higiênico"],	#Definimos a primeira chave do dicionário, com seu valro associado, que no caso é uma lista
  "padaria": ["Pão", "Queijo", "Presunto"],			#Definimos a segunda chave e seu valor
  "papelaria": ["Caderno", "Caneta", "Lápis"]			#Terceira chave e valor definidos
}								#Término do dicionário
print(dicionariodecompras)					#Imprimimos o dicionário todo
print(dicionariodecompras['mercado'])				#Imprimimos apenas a chave mercado do dicionário
print(dicionariodecompras['padaria'])                           #Imprimimos a chave padaria
print(dicionariodecompras['papelaria'])                         #Por fim, a chava papelaria é impressa
#+end_src

Notem a sintaxe, os dicionários ficam entre chaves ={ }=, assim como os conjuntos, então cuidado, pois isso pode trazer ambiguidades no código, por exemplo para inicializar um conjunto vazio. Na definição interna do dicionário temos a seguinte sintaxe: ="chave": valor=, onde as chaves vão funcionar como se fossem índices do dicionário, e os valores são os itens associados a chave. No exemplo acima definimos cada chave como uma lista, convenientemente organizadas, sendo uma chave para cada lista de compras. Os valores dos dicionários não precisam ser listas, podem ser números, strings e misturadas. Vamos a mais um exemplo para ilustrar isto:

#+begin_src python
print(aluno)
print(aluno["Nome"])
print(aluno["Nota 1"])
print(aluno["Nome"], 'teve as seguintes notas:', aluno["Nota 1"], aluno["Nota 2"], aluno["Nota 3"], 'com média final', ((aluno["Nota 1"]+aluno["Nota 2"]+aluno["Nota 3"])/3))
#+end_src

** Métodos de dicionários
Assim como listas e conjuntos, os dicionários também possuem métodos associados. Como sempre os métodos facilitam a vida na programação, por fazer diretamente uma função que poderia ser extensa de implementar. Abaixo os principais métodos de dicionários são apresentados:

+ keys: Retorna uma lista contendo todas as chaves do dicionário. Sintaxe: dicionario.keys()
+ get: Retorna o valor da chave especificada. Sintaxe: dicionario.get("chave")
+ items: Retorna uma lista contendo uma tupla para cada par chave-valor. Sintaxe: dicionario.items()
+ values: Retorna uma lista com todos os valores no dicionário. Sintaxe: dicionario.values()
+ update: Insere um par chave-valor no dicionário. Sintaxe: dicionario.update({"chave": "valor"})
+ pop: Assim como já visto em listas e conjuntos,


** Modificando e desempacotando dicionários


+ método =pop=
+ adicionando nova chave
+ deletando uma chave

** Iterando sobre dicionários
+ métodos =items=, =get=, =keys=, =values=

** Funções com argumentos estrela \ast{}args e \ast\ast{}kwargs

* TODO Strings e processamento de texto
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_strings
:EXPORT_OPTIONS: toc:t
:ID:       6feb275c-31de-49dd-87a1-d3576f4dbfc2
:END:

** Agrupando caracteres com strings
+ strings são imutáveis
+ convertendo objetos para strings com =str=
+ convertendo strings para inteiros e reais com =int= e =float=
+ iterando em strings com =for=
+ checando prefixos e sufixos com =startswith= e =endswith=
+ checando caracteres com =isnumeric=, =isupper=, =islower=

** Recebendo informações do usuário com o comando =input=

** Tipos de strings
+ utf-8
  - caracteres especiais tipo \n e \t
+ raw
+ fstring

** Processamento de texto
+ =split= e =join=
+ =translate= e =maketrans=
+ =capitalize=, =title=, =lower=, =upper=, =swapcase=
+ =replace=

** Expressões regulares
* JAMES Scripts de python, bash e HPC
* TODO Programação orientada a objetos
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_classes
:EXPORT_OPTIONS: toc:t
:ID:       59343370-093c-4c7c-b549-9e102aed7b5b
:END:

** Agrupando objetos com classes
+ classes como um único objeto para tratar de dados e funções
+ sintaxe
+ instância
+ parâmetros
+ =self=

** Classes e seus métodos
** Métodos mágicos
+ dunders
+ __init__
+ __str__
+ __repr__

** Herança de classes

* TODO Biblioteca padrão
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_bibpadrao
:EXPORT_OPTIONS: toc:t
:ID:       a5a1dec7-4ac1-4c97-a064-75b93b837a5c
:END:

** O que são e como importar módulos de Python
+ sintaxe para importar um módulo (com ou sem apelido)
+ sintaxe para importar objetos de um módulo
+ conceito de namespace ("espaço de nome")
+ reforçar que cada módulo tem sua documentação (ou deveria ter...)
+ Módulos para usar como exemplo: =math= e =random=

** Módulos embutidos
+ os que eu acho mais interessantes são:
  + os
  + sys
  + functools
  + itertools
  + math
  + pathlib
  + pdb
  + pprint
  + random
  + re
  + statistics
  + pickle
  + abc?
  + collections
  + datetime

* TODO Leitura e manipulação de dados com o módulo =pandas=
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_pandas
:EXPORT_OPTIONS: toc:t
:ID:       94937cb1-718d-4eee-a3be-611c4badeb4b
:END:

** Criando e manipulando DataFrames a partir de arquivos
** Análise dos dados
+ Estatística descritiva
** Criando e exportando um DataFrame a partir de listas
+ Criando um dataframe usando listas de python
+ Exportar para csv
+ Exportar para xlsx

* TODO Graficando dados
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_graficos
:EXPORT_OPTIONS: toc:t
:ID:       5c9942b1-d397-4d59-9891-6f6bfee01809
:END:

** Graficando dados de um DataFrame
** Graficando dados usando =matplotlib=

* TODO Controle de versão usando =git=
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_git
:EXPORT_OPTIONS: toc:t
:ID:       7ec34a02-1c92-4a3f-940a-955daab7050f
:END:

* TODO Computação científica com =numpy= e =scipy=
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_numpy
:EXPORT_OPTIONS: toc:t
:ID:       fc29118f-e0b5-4816-9034-4a83e7b520b4
:END:
* TODO Algebra simbólica com =sympy=
* TODO Propagação de erros com =uncertainties=
* TODO Exercícios :noexport:

+ Computar numericamente a soma de uma PA ou PG
+ Função que checa se um número é palímdromo (sem usar string!)
+ Checar os números divisíveis por 5 em uma lista
+ Contar quais são as palavras mais comuns em um texto
+ Dadas duas listas, montar uma terceira com os maiores números de cada (element-wise)
+ mostrar a sequencia de fibonacci até o número n
+ checar se um número é primo
+ função que soma todos os números do 1 até o n
+ programa que conta quantos digitos existem em um numero inteiro
+ inverter a ordem de uma lista
+ programa que calcula o fatorial de um inteiro positivo
+ programa que cria uma lista apenas com os itens nas posições impares de uma lista original
+ encontre o segundo maior número em uma lista
+ função que conta quantas letras, dígitos e caracteres especiais tem em uma string
+ histograma de contagem de caracteres em uma string
+ encontrar números em uma string e armazena-los em uma lista
+ histograma de valores em uma lista
+ criar uma lista sem itens repetidos
+ identificar os elementos em comum entre duas listas
+ separar valores e chaves de dicionários em duas listas
+ concatenar duas listas de string element-wise
+ Create a program that asks the user to enter their name and their age. Print out a message addressed to them that tells them the year that they will turn 100 years old.
+ Ask the user for a number. Depending on whether the number is even or odd, print out an appropriate message to the user.
+ use compreensão de lista para identificar números impares em uma lista
+ criar um jogo de jokenpo a ser jogado por duas pessoas
+ exercicio onde o computador escolhe um numero aleatorio e o usuario deve adivinhar com dicas de maior ou menor


intermediário:
+ reverter cada palavra de uma lista
  - 'My Name is Jessa'
  - yM emaN si asseJ
+ inverter chave e valores de um dicionário
+ mostrar todos os itens duplicados em uma lista
* TODO Ideias de tópicos :noexport:

+ criando módulos de python
+ geradores
+ decoradores
