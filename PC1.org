#+TITLE: Práticas em Ciência de Dados
#+AUTHOR: Daniel R. Cassar & James M. de Almeida
:config:
#+EXPORT_FILE_NAME: PC1/PC1
#+STARTUP: overview
#+PROPERTY: header-args:python :results output
#+OPTIONS: TeX:t LaTeX:t toc:t html-style:t e:t
#+LATEX_HEADER: \usepackage[brazilian]{babel}
#+LATEX_HEADER: \addto\captionsenglish{\renewcommand\contentsname{Conteúdo}}
#+todo: TODO(t) DANIEL(d) JAMES(j) | DONE(x)
:END:
:style:
#+BEGIN_EXPORT html
<style>
  .linenr {
    color: #669999;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  <!-- blockquote { -->
  <!--   margin-bottom: 10px; -->
  <!--   padding: 10px; -->
  <!--   background-color: #FFF8DC; -->
  <!--   border-left: 2px solid #ffeb8e; -->
  <!--   border-left-color: rgb(255, 228, 102); -->
  <!--   display: block; -->
  <!--   margin-block-start: 1em; -->
  <!--   margin-block-end: 1em; -->
  <!--   margin-inline-start: 40px; -->
  <!--   margin-inline-end: 40px; -->
  <!-- } -->

  <!-- .verse { -->
  <!--   margin-bottom: 10px; -->
  <!--   padding: 10px; -->
  <!--   background-color: #FFF8DC; -->
  <!--   border-left: 2px solid #ffeb8e; -->
  <!--   border-left-color: rgb(255, 228, 102); -->
  <!--   display: block; -->
  <!--   margin-block-start: 1em; -->
  <!--   margin-block-end: 1em; -->
  <!--   margin-inline-start: 40px; -->
  <!--   margin-inline-end: 40px; -->
  <!-- } -->
</style>
#+END_EXPORT
:END:

#+BEGIN_SRC elisp :session pyvenv :results none :exports none
  (venv-workon "drcpy")
#+END_SRC

#+RESULTS:

* Conteúdo da disciplina :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/toc
:EXPORT_OPTIONS: toc:nil
:END:

1. Jupyter, variáveis e como buscar ajuda
2. Operadores e estrutura de decisão
3. Funções
4. Listas, tuplas e conjuntos
5. Laço de repetição
6. Dicionários e depuração de programas
7. Strings e processamento de texto
8. Scripts de python, bash e HPC
9. Biblioteca padrão e bibliotecas externas
10. Computação científica com numpy e scipy
11. Leitura e manipulação de dados com o módulo pandas
12. Graficando dados
13. Controle de versão usando git
14. Tópicos avançados
15. Apresentação dos trabalhos de conclusão do semestre

* Introdução
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_intro
:EXPORT_OPTIONS: toc:nil
:ID:       be365bdb-8e61-4ed3-89ae-397c7855cdeb
:END:

** Olá! Que bom que você veio, aprochegue-se!

#+begin_quote
"/A mente que se abre a uma nova ideia jamais voltará ao seu tamanho original./" --- Albert Einstein
#+end_quote

Bem-vinda(o) à apostila de Práticas em Ciência de Dados. Esta apostila foi escrita[fn:: Está sendo escrita na verdade, e provavelmente continuará sendo escrita por muito tempo pois a área de computação é muito dinâmica.] tendo em mente a disciplina de /Práticas em Ciência de Dados/ do Bacharelado em Ciência, Tecnologia e Inovação da Ilum Escola de Ciência. Assim, esta apostila leva em consideração que os problemas propostos serão realizados em sala de aula em um ambiente dinâmico com interações alunos-alunos e alunos-professores. Esta é uma abordagem diferente da maioria dos livros-texto disponíveis em língua portuguesa.

A apostila está dividida em tópicos gerais e cada um deles divididos em subtópicos com diversas práticas. Todos os subtópicos contém um texto explicativo (com exemplos) e uma ou mais práticas. As práticas são marcadas com uma letra em negrito e entre chaves.

*[A]* Aqui, por exemplo, seria o enunciado da prática *1.1.A* (prática A da Seção 1.1).

Realize as práticas seguindo as instruções discutidas em sala de aula. Lembre-se que a capacidade de ler, entender, escrever e depurar seu próprio código é /fundamental/ para realizar as diversas disciplinas da Ilum (incluindo, obviamente, todas as disciplinas de computação). Por este motivo, se atente às dicas abaixo:

+ As práticas são individuais. Tente resolver as questões no seu computador antes de discutir em grupo. Depois de tentar resolver, você é incentivada(o) a discutir em grupo e observar outras formas de resolver o mesmo problema (aprendemos muito vendo outras soluções!);

+ Algumas práticas te convidam a executar algum código pronto para ver o que acontece. Mesmo sendo possível copiar e colar o código, é fortemente recomendado /escrever/ o código pois aprendemos mais quando escrevemos (ação ativa) do que quando copiamos e colamos (ação passiva);

+ Praticamente todos os problemas computacionais que serão explorados nesta disciplina já foram resolvidos por alguém e a solução pode ser encontrada em livros ou na internet. Isso é inevitável para problemas /simples/. Mais adiante no curso (ou na vida) iremos nos deparar com problemas mais /difíceis/ e mais específicos, que não têm soluções prontas. Para resolver problemas difíceis precisamos ter uma base sólida que só adquirimos resolvendo problemas mais simples. Aproveite esse momento de aprendizado e evite buscar respostas prontas /antes/ de tentar resolver o problema! Depois que você tentou resolver, fique à vontade para procurar e estudar outras soluções. Aprendemos muito quando estudamos diferentes soluções para o mesmo problema.

** Python e o caderno de notas Jupyter

#+begin_quote
"/Além do saneamento, da medicina, da educação, do vinho, da ordem pública, da irrigação, das estradas, do sistema de água doce, da saúde pública... o que os romanos já fizeram por nós?/" --- Monty Python, A vida de Brian
#+end_quote

Esta apostila toda foi escrita considerando a linguagem de programação _Python_. Python é uma linguagem de programação criada por Guido van Rossun com grande ênfase em produzir códigos expressivos que sejam mais fáceis de serem lidos[fn:: O fato de que Python foi criado intencionalmente com a ideia de ser mais legível sugere que existem linguagens de programação que foram criadas sem essa preocupação. Existem ainda linguagens de programação chamadas de exotéricas que são deliberadamente criadas para serem o mais ilegível possível (muitas vezes para fins humorísticos). Provavelmente a mais conhecida é a Brainfuck https://esolangs.org/wiki/Brainfuck.]. Por este e outros motivos, Python chamou a atenção da comunidade científica e hoje é uma das linguagens de programação mais utilizada nesta área. Existem diversas bibliotecas científicas livres e de código aberto disponíveis para Python, muitas delas são o estado da arte em suas respectivas áreas.

Uma ferramenta para execução de códigos em Python muito utilizada no meio científico são os cadernos de nota Jupyter (/Jupyter Notebooks/, em inglês). Jupyter é um programa que permite a execução interativa de códigos em Python separados em blocos de códigos chamados de células. A possibilidade de incluir células de texto, imagens e gráficos interativos são muito bem-vindas no contexto de análises científicas. Além disso, os cadernos de nota Jupyter armazenam os resultados obtidos e, se bem utilizados, nos ajudam com a reprodutibilidade do nosso trabalho. Reprodutibilidade significa que seu trabalho pode ser reproduzido por um par com conhecimento técnico suficiente, e isso é essencial para avançar o nosso conhecimento científico coletivo.

Apesar de não ser estritamente necessário utilizar os cadernos de notas Jupyter para realizar as práticas desta apostila, o texto irá assumir que as práticas serão realizadas no ambiente Jupyter.

** Links interessantes

#+begin_quote
"/É perigoso seguir sozinho, pegue isso!/" --- Ancião, The Legend of Zelda
#+end_quote

Existem alguns links que são sempre bons de ter em mãos. Um dos mais importantes é o link para a documentação oficial do Python, disponível em https://docs.python.org/3.9/ (Inglês, versão 3.9 do Python) e https://docs.python.org/pt-br/3.9/ (Português, versão 3.9 do Python). A documentação oficial é sempre uma boa escolha para investigar o funcionamento de qualquer /software/, e isso não é diferente para o Python. Leva um tempo até se acostumar com o formato da apresentação, mas vale a pena.

Python é uma linguagem de programação que constantemente recebe atualizações de funcionalidades. O processo de inclusão de novas funcionalidades envolve a escrita e o aceite das /Propostas de Melhorias do Python/ (PEP). Você pode checar todas as propostas em https://www.python.org/dev/peps/. Algumas propostas são especialmente úteis:

+ [[https://www.python.org/dev/peps/pep-0020/][PEP 20]] - O Zen do Python. Uma PEP breve contendo um poema sobre a filosofia do Python. Se for ler apenas uma PEP na sua vida, leia essa;
+ [[https://www.python.org/dev/peps/pep-0008/][PEP 8]] - Guia de estilo. Recomendações sobre o que é considerado bom estilo para a escrita de códigos em Python;
+ [[https://www.python.org/dev/peps/pep-0257/][PEP 257]] - Convenções para docstrings. Veremos docstrings no capitulo sobre funções. Lá iremos comentar sobre esta PEP. Docstrings servem para documentar seu código para torná-lo mais fácil de ser entendido por outras pessoas.

Existe uma enorme quantidade de bibliotecas de Python prontas para uso. Algumas destas bibliotecas nós veremos nesta apostila, como a ~numpy~, ~matplotlib~ e ~pandas~. Muitas outras existem! Veja neste link uma lista curada de diversas bibliotecas: https://awesome-python.com. Note que Python pode ser utilizado para diversas tarefas, não apenas para computação científica!

# *[A]* Vá até a seção de bibliotecas científicas do site awesome-python (disponível em https://awesome-python.com/#science) e escolha a biblioteca que mais te chamar a atenção. Se informe brevemente sobre o que a sua biblioteca escolhida faz e escreva o que aprendeu em uma célula de texto.

Você verá ao longo desta apostila que existem diversos detalhes para escrever código em Python (o que não é algo objetivamente bom ou ruim, apenas uma observação sobre a realidade como ela se apresenta). Com tempo e treino, muitos destes detalhes serão naturais para você. Mesmo assim, é normal esquecer certos detalhes quando ficamos um tempo sem usar. Por isso é sempre bom ter uma cola para refrescar a mente. Os links abaixo te levam para boas colas online gratuitas:

+ [[https://github.com/gto76/python-cheatsheet][Python cheatsheet no github]]
+ [[https://www.pythoncheatsheet.org/][pythoncheatsheet.org]]
+ [[https://programmingwithmosh.com/wp-content/uploads/2019/02/Python-Cheat-Sheet.pdf][Python Cheat Sheet escrito por Mosh Hamedani]]
+ [[https://github.com/ehmatthes/pcc/releases/download/v1.0.0/beginners_python_cheat_sheet_pcc_all.pdf][Python Crash Course Cheat Sheet]]

Por fim, existem diversos materiais (tanto pagos quanto gratuitos) para aprendizado de Python disponíveis online. Abaixo estão alguns links de materiais gratuitos que podem te interessar:

+ [[https://github.com/pamoroso/free-python-books][Lista de livros gratuitos de Python]] lista curada e constantemente atualizada sobre diversos livros de Python que você pode ler sem custo algum. A lista separa os livros em tópicos e também no nível de aprendizado;
+ [[https://books.goalkicker.com/PythonBook/][Notas de Python para profissionais]]: material bastante extenso cobrindo praticamente tudo sobre Python. Não é necessariamente o melhor material para aprender a linguagem, mas é um excelente material para uma consulta rápida;
+ [[https://automatetheboringstuff.com/#toc][Automatize tarefas maçantes com Python]]: livro online gratuito com uma didática muito interessante e focada em aprendizado "mão-na-massa". Sua última versão é de 2015. A recomendação é usar este livro para aprender o funcionamento básico do Python, mas não utilizá-lo para aprender as bibliotecas que ele sugere (algumas delas estão desatualizadas).
+ [[https://greenteapress.com/thinkpython2/html/index.html][Think Python 2]] [[https://penseallen.github.io/PensePython2e/][(versão em português)]]: livro online gratuito. Última versão é de 2015, então não aborda certas características mais recentes da linguagem;
** TODO Quando tudo mais falhar :noexport:
+ Técnica da NASA

* Jupyter, variáveis e como buscar ajuda
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_jupyter
:EXPORT_OPTIONS: toc:t
:ID:       60b5365d-1c0c-4944-bb64-dcbb673a2e4f
:END:

** Meu primeiro caderno de notas Jupyter

#+begin_quote
"/O segredo para chegar à frente é começar./" --- Mark Twain
#+end_quote

Usualmente, a primeira prática quando se está aprendendo uma linguagem de programação nova é a chamada "Olá, mundo!". Nesta prática, o objetivo é criar seu primeiro programa na linguagem de interesse (Python neste caso) que, quando executado, exiba a mensagem "Olá, Mundo!".

*[A]* Em um caderno de notas do Jupyter, crie uma célula de código contendo o código abaixo. Execute esta célula e observe o que acontece. Reflita e escreva brevemente sobre o que você observou em uma célula de texto.

#+begin_src python
  print("Olá, mundo!")
#+end_src

Observe que no código acima temos três elementos: o comando ~print~, parênteses e um texto delimitado por aspas duplas. O comando ~print~ é o que chamamos de _função_. Veremos funções mais adiante, mas por hora basta saber que funções são "apelidos" para executar códigos que já foram escritos. Neste caso, ~print~ é uma função embutida de Python cujo código já foi escrito pelos próprios criadores do Python, por isso você pode usar esta função sem a necessidade de defini-la. A palavra /print/ poderia ser traduzida para o português como /imprimir/, porém o termo /exibir/ se encaixa melhor no uso corriqueiro desta função.

Para executar funções precisamos chamá-las usando os parênteses. Se tiver curiosidade, tente criar e executar uma célula no Jupyter apenas com a palavra ~print~ para ver o que acontece quando escrevemos o nome de uma função sem chamá-la com o parênteses.

Por fim, dentro dos parênteses que usamos para chamar a função ~print~ nós escrevemos os /argumentos/ da função. Neste caso, temos apenas um argumento e ele é o texto "Olá, mundo!".

*[B]* Escreva o código abaixo em uma célula de código e rode ele. Descreva o que aconteceu e proponha uma solução para o problema.

#+begin_src python
  print "Olá, mundo!"
#+end_src

#+RESULTS:

*[C]* Escreva o código abaixo em uma célula de código e rode ele. Descreva o que aconteceu e proponha uma solução para o problema.

#+begin_src python
  print(Olá, mundo!)
#+end_src

#+RESULTS:

*[D]* Crie três blocos de código no seu caderno de notas do Jupyter. No primeiro bloco de código, faça com que o Python exiba seu nome completo usando a função ~print~. No segundo bloco de código, faça com que o Python exiba a data de hoje. Finalmente, no terceiro bloco de código faça com que o Python exiba uma frase que você goste muito.

Aprender qualquer linguagem, seja ela de programação ou não, requer treino. Não se preocupe se as regras de Python parecem esquisitas, com o passar do tempo você irá ler e escrever códigos em Python com mais facilidade. Afinal, você não aprendeu português de um dia para o outro, não é?

** Criando variáveis de diferentes tipos

#+begin_quote
"/Ninguém é igual a ninguém. Todo o ser humano é um estranho ímpar./" --- Carlos Drummond de Andrade
#+end_quote

É comum em programação situações onde precisamos armazenar informações em variáveis para usá-las mais tarde. Python oferece diversos tipos de variáveis como números inteiros (~int~), números reais (~float~) e variáveis que armazenam texto (~string~), por exemplo.

Para criar uma variável basta escolher um nome válido e usar o sinal de igual (~=~). O sinal de igual também é chamado de /operador de atribuição/ pois ele atribui um valor a uma variável.

*[A]* Crie uma célula de código contendo o código abaixo. Execute esta célula e observe o que acontece. Na primeira linha do código abaixo o operador de atribuição está sendo usado. Comente sobre isso e comente o que ocorreu na linha 2.

#+begin_src python -n
  frase = "Olá, mundo!"
  print(frase)
#+end_src

#+RESULTS:
: Olá, mundo!

Quando criamos uma variável nova dizemos que a variável foi /declarada/. No código acima, a variável ~frase~ foi declarada na linha 1.

Quando criamos uma variável nova, precisamos indicar de alguma forma qual o /tipo/ dessa variável. A variável ~frase~ declarada acima é um texto. Chamamos textos em programação de variáveis do tipo ~string~. Para indicar que um objeto é uma ~string~ nós usamos aspas.

*[B]* Existem quatro formas diferentes de declarar variáveis do tipo ~string~ em Python como você pode ver no código abaixo. Crie 4 variáveis diferentes (fique a vontade para nomeá-las da forma que preferir), todas elas sendo ~strings~ e cada uma delas usando uma forma diferente de declaração. Cada uma destas variáveis deve conter um frase de um cientista, artista, escritor ou pensador famoso.

#+begin_src python
  texto_com_aspas_simples = 'Olá, Mundo!'
  texto_com_aspas_duplas = "Olá, Mundo!"
  texto_com_tres_aspas_simples = '''Olá, Mundo!'''
  texto_com_tres_aspas_duplas = """Olá, Mundo!"""
#+end_src

#+RESULTS:

Além de ~strings~, variáveis podem armazenar objetos de outros tipos. Variáveis podem armazenar valores numéricos, por exemplo. Veja no código abaixo diversas formas de declarar variáveis contendo valores numéricos. Note que para o Python, o separador decimal é o _ponto_ (~.~) e não a _vírgula_ (~,~). Muita atenção com essa distinção pois a vírgula tem outro significado em Python (veremos mais adiante) e não necessariamente vai acusar um erro no seu código!!

*[C]* Execute o código abaixo. Após a execução, utilize a função ~print~ junto com a função ~type~ para identificar os tipos das variáveis declaradas (veja um exemplo na linha 16). Quantos tipos diferentes você identificou? Quais foram eles? Na sua opinião, existe uma vantagem de termos diferentes formas de declarar números inteiros, reais e complexos?

#+begin_src python -n
  numero_inteiro = 10
  numero_inteiro_positivo = +10
  numero_inteiro_negativo = -10

  numero_real = 10.0
  numero_real_sem_digitos_depois_do_ponto = 10.
  numero_real_positivo = +10.0000
  numero_real_negativo = -10.0000
  numero_real_base_dez = 1.5e7
  pi = 3.1415

  numero_complexo = 2 + 3j
  numero_complexo_apenas_parte_imaginaria = 5j
  numero_complexo_apenas_parte_real = 1 + 0j

  print(type(numero_inteiro))
#+end_src

#+RESULTS:
: <class 'int'>

*[D]* Em uma célula de texto responda as perguntas:

1) Existe diferença de se criar uma string usando aspas simples ou duplas? Existe diferença de se criar uma string usando três aspas? Reflita sobre a resposta e busque informações na internet antes de escrever. Não se esqueça de colocar as fontes na sua resposta.
2) Qual a diferença entre um número real e um número inteiro? Observando o exemplo acima, qual seria a regra para definir números inteiros e números reais?
3) Qual a regra para declarar números complexos? O que é o ~j~ na declaração dos números complexos?
4) Na sua opinião, existe diferença entre as variáveis ~numero_inteiro~ e ~numero_inteiro_positivo~? Explique brevemente seu raciocínio.
5) Na sua opinião, existe diferença entre as variáveis ~numero_real~ e ~numero_real_positivo~ e ~numero_real_sem_digitos_depois_do_ponto~? Explique brevemente seu raciocínio. De que forma você faria para confirmar a sua resposta?

*[E]* O código abaixo /supostamente/ cria novas variáveis. No entanto, algumas das declarações parecem um tanto... diferentes... quem sabe até estranhas! Seu objetivo é testar cada uma destas declarações e separar as que funcionam das que não funcionam (as que não funcionam acusam um erro quando executadas). Para as declarações que não funcionam, descreva o erro que ocorreu e proponha uma correção.

#+begin_src python
  variavel_que_o_nome_termina_com_numero_100 = 1
  100_variavel_que_o_nome_comeca_com_numero = 1
  numero_do_agente_secreto = 007

  nome_da_variável_com_acento = True
  nome da variavel com espaco = True
  booleano_sem_primeira_letra_maiuscula = true

  espaco_entre_os_numeros = 100 000
  numero_com_sublinhado = 10_000_000

  numero_com_muitos_sinais_de_menos = -----10
  numero_com_muitos_sinais_de_mais = +++++10
  numero_com_muitos_sinais_de_mais_e_menos = +--++-10

  muitos_espacos_entre_o_sinal_de_igual     =      10
  nenhum_espaco_entre_o_sinal_de_igual=10

  texto = Olá, Mundo!
  texto = "Olá, Mundo!'
#+end_src

#+RESULTS:

*[F]* Explore e comente o que acontece quando declaramos variáveis com o mesmo nome.

Existem diversos outros tipos de variáveis que veremos ao longo desta apostila. Sempre que em dúvida, cheque o tipo da variável com a função ~type~.

** Buscando ajuda

#+begin_verse
"/Socorro! Eu preciso de alguém.
Socorro! Não uma pessoa qualquer.
Socorro! Você sabe que eu preciso de alguém.
Socorro!/"
     --- Help, The Beatles
#+end_verse

Nas práticas anteriores usamos a função ~print~ para exibir informações na forma de texto no próprio caderno de notas do Jupyter. A função ~print~ é uma /função embutida/ do Python. Isto quer dizer que qualquer usuário que tenha o Python instalado (idealmente na mesma versão que a sua) terá acesso a esta função sem a necessidade de executar nenhum passo adicional.

Na prática, nós já sabemos que a função ~print~ recebe como argumento o texto ou variável que será exibido. Argumentos de funções são as informações que estão dentro dos parênteses quando executamos as funções. Por exemplo, o argumento da função ~print~ em ~print(1234)~ é o número 1234. Funções podem receber um ou mais argumentos, bem como podem receber zero argumentos (tente rodar ~print()~ e veja o que acontece! Tente também rodar ~print(1234, 4321)~). Os argumentos das funções são definidos no momento quando a função é definida (veremos isso em mais detalhes mais adiante).

O que você faria se não soubesse o que função ~print~ faz? Digamos, por exemplo, que você viu essa função sendo usada em um código de Python na internet, mas não sabe sua funcionalidade. Como proceder? Algumas sugestões neste caso são:

1) Pesquisar na internet em busca de alguma página com explicações (Python é uma linguagem de programação muito usada, existe muito material didático disponível online);
2) Pesquisar na documentação oficial do Python disponível em português no link https://docs.python.org/pt-br/3/. Todas as funções embutidas de Python, por exemplo, estão descritas aqui: https://docs.python.org/pt-br/3/library/functions.html;
3) Usar a função ~help~ do próprio Python (tente rodar ~help(print)~ no seu caderno de notas e veja o que acontece);
4) Usar a sintaxe própria do Jupyter para buscar ajuda. Para isso basta digitar a função que quer saber mais informações junto com um sinal de interrogação, assim como mostra o exemplo abaixo.

#+begin_src python
  print?
#+end_src

*[A]* Escolha uma das quatro sugestões acima para ler mais sobre a função ~print~ do Python. Observe que a função ~print~ aceita diferentes argumentos, sendo eles: ~value~, ~file~, ~flush~, ~end~ e ~sep~. Escreva como foi sua busca (incluindo fontes) e descreva com suas palavras o que os argumentos ~end~ e ~sep~ fazem. Tente outras formas de busca caso julgue necessário.

*[B]* Para cada função abaixo, faça uma busca online (buscas 1 ou 2) e uma busca offline (buscas 3 ou 4) para entender o que estas funções fazem. Escreva como foi sua busca (incluindo fontes) e descreva com suas palavras o que estas funções fazem.

+ ~round~
+ ~pow~
+ ~oct~
+ ~abs~

* Operadores e estrutura de decisão
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_operadores
:EXPORT_OPTIONS: toc:t
:ID:       af8757f4-e890-4b3d-96ea-a9c2c73c39e5
:END:

** Operadores aritméticos

#+begin_quote
"/Dizia eu que a aritmética.../" --- Professor Girafalez, Chaves
#+end_quote

A linguagem Python contém diversos operadores aritméticos como adição (~+~), subtração (~-~), multiplicação (~*~), divisão (~/~) e exponencial (~**~). Estes operadores permitem realizar cálculos aritméticos com números inteiros, reais e complexos. _Cuidado_: em Python, a exponenciação é representada por dois asteriscos (~**~); não confundir com o acento circunflexo (~^~) que é o operador de exponenciação usado no Excel!

# *[A*]* Reescreva o código abaixo em uma célula do Jupyter e veja o que acontece. Comente porque o resultado da terceira linha foi ~90~ e não ~0~.

# #+begin_src python -n
#   print(1 + 1)
#   print(1 - 1 + 1 - 1)
#   print(-10 + 10 * 10)
#   print(10 / 2 * 5)
#   print(10 ** 10)
#   print(2 ** 1 / 2)
#   print(2 ** (1 / 2))
#   print((1 + 1j) / (1 - 1j))
# #+end_src

# #+RESULTS:
# : 2
# : 0
# : 90
# : 25.0
# : 10000000000
# : 1.0
# : 1.4142135623730951
# : 1j

A ordem de precedência dos operadores aritméticos (isto é, a ordem de execução dos operadores) segue a regra do PEMDAS: parênteses, exponencial, multiplicação, divisão, adição e subtração. Assim como na notação matemática, usamos parênteses para dar preferência para certas operações.

# *[B*]* Escreva 5 formas diferentes de se obter o número 12 usando os operadores aritméticos que aprendeu (por exemplo ~print(7 + 5)~). Certifique-se que usou todos os operadores aritméticos que você conhece neste exercício.

*[A]* Utilizando o Python como calculadora, compute:
1) Quantos segundos existem em 16 horas e 42 minutos?
2) Quantos centímetros existem em 72,8 milhas?
3) Se você percorrer 72,8 milhas em 16 horas e 42 minutos, qual a sua velocidade média em centímetros por segundo?
4) Quanto tempo você demoraria para percorrer a circunferência da Terra na linha do equador se permanecer na velocidade média obtida no item acima?

*[B]* Além dos operadores discutidos acima, existem diversos outros em Python. Dois operadores bastante úteis são a divisão inteira (~//~) e o módulo (~%~, também conhecido como resto da divisão inteira). Veja abaixo um exemplo de como usá-los. Teste estes operadores e descreva como eles funcionam (em caso de dúvida, busque ajuda assim como apresentado na seção Buscando Ajuda). Discorra brevemente sobre possíveis situações onde estes operadores podem ser úteis.

#+begin_src python
  print(10 // 3)
  print(17 % 2)
#+end_src

#+RESULTS:
: 3
: 1

_Atenção_: operadores aritméticos usualmente funcionam com qualquer combinação de números inteiros, reais ou complexos. No entanto, preste atenção no tipo do resultado final! Use a função ~type~ para checar os tipos das variáveis em caso de dúvida.

*[C]* Escreva e execute o código abaixo e comente sobre o resultado obtido quando somamos variáveis de tipos iguais e tipos diferentes.

#+begin_src python
  inteiro_mais_inteiro = 1 + 1
  print(type(inteiro_mais_inteiro))

  inteiro_mais_real = 1 + 1.5
  print(type(inteiro_mais_real))

  real_mais_real = 1.5 + 1.5
  print(type(real_mais_real))

  inteiro_mais_complexo = 10 + (1 - 2j)
  print(type(inteiro_mais_complexo))

  real_mais_complexo = 10.5 + (1 - 2j)
  print(type(real_mais_complexo))
#+end_src

#+RESULTS:
: <class 'int'>
: <class 'float'>
: <class 'float'>
: <class 'complex'>
: <class 'complex'>

*[D]* Escreva um código similar ao código acima, porém alterando o operador de adição pelo operador de divisão. Você obteve algum resultado inusitado? Comente.

# #+begin_src python
#   inteiro_mais_inteiro = 1 / 1
#   print(type(inteiro_mais_inteiro))
#
#   inteiro_mais_real = 1 / 1.5
#   print(type(inteiro_mais_real))
#
#   real_mais_real = 1.5 / 1.5
#   print(type(real_mais_real))
#
#   inteiro_mais_complexo = 10 / (1 - 2j)
#   print(type(inteiro_mais_complexo))
#
#   real_mais_complexo = 10.5 / (1 - 2j)
#   print(type(real_mais_complexo))
# #+end_src

# #+RESULTS:
# : <class 'float'>
# : <class 'float'>
# : <class 'float'>
# : <class 'complex'>
# : <class 'complex'>

*[Desafio]* Crie uma a variável chamada ~numero~ que armazena um número inteiro entre 1000 e 9999. _Usando apenas operadores aritméticos_, separe todos os dígitos da variável ~numero~ em 4 outras variáveis. Seu código deve funcionar para qualquer valor da variável ~numero~ dentro do domínio definido. Exemplo: o número 1234 deve ser separado em uma variável contendo o número 1, uma contendo o número 2, outra contendo o número 3 e a última contendo o número 4.

*[Desafio 2]* Durante um exercício de geometria, você decidiu realizar suas contas utilizando Python. Você escreveu o código abaixo em uma célula no seu caderno de notas Jupyter e o resultado que obteve foi inusitado! Por que o resultado é inusitado? Qual era o resultado esperado? Qual é a explicação para isso? Na sua opinião, este tipo de "problema" compromete o uso de Python como uma calculadora aritmética? _Dica_: quantos números reais existem entre zero e um?

#+begin_src python
  pi = 3.14
  valor = pi + 2
  print(valor)
#+end_src

#+RESULTS:
: 5.140000000000001

** Operadores lógicos

#+begin_quote
"/Existem 10 tipos de pessoas no mundo: as que sabem binário e as que não sabem./" --- Autor desconhecido
#+end_quote

Variáveis lógicas (também conhecidas como variáveis booleanas) são objetos que podem assumir apenas dois valores diferentes: verdadeiro ou falso. Na sintaxe de Python, escrevemos verdadeiro ou falso em inglês e com a primeira letra maiúscula: ~True~ ou ~False~.

Uma expressão booleana é uma expressão que, quando resolvida, resulta em um valor verdadeiro (~True~) ou em um valor falso (~False~). Expressões booleanas podem ser escritas com os operadores lógicos E (~and~), OU (~or~) e NÃO (~not~). Os operadores ~and~ e ~or~ são chamados de operadores binários pois requerem sempre dois argumentos para serem resolvidos. A sintaxe para usar estes operadores com os argumentos ~A~ e ~B~, por exemplo, é a seguinte: ~A and B~ e ~A or B~.

*[A]* Execute o código abaixo; comente sobre qual ou quais situações o operador ~and~ retorna o valor ~True~.

#+begin_src python
  print(True and True)
  print(True and False)
  print(False and True)
  print(False and False)

  print(False and False and False)
  print(False and False and True)
  print(False and True and True)
  print(True and True and True)
#+end_src

#+RESULTS:
: True
: False
: False
: False
: False
: False
: False
: True

Se quisermos, podemos rescrever o código acima usando variáveis para facilitar a visualização:

#+begin_src python
  A = True
  B = False

  print(A and A)
  print(A and B)
  print(B and A)
  print(B and B)

  print(B and B and B)
  print(B and B and A)
  print(B and A and A)
  print(A and A and A)
#+end_src

#+RESULTS:
: True
: False
: False
: False
: False
: False
: False
: True

*[B]* Escreva e execute um código similar ao código acima, substituindo ~and~ por ~or~; comente sobre qual ou quais situações o operador ~or~ retorna o valor ~True~.

O operador ~not~ é um operador unário; ele requer apenas um argumento para ser computado. A sintaxe para usar este operador com o argumento ~A~, por exemplo, é a seguinte: ~not A~.

*[C]* Escreva e execute o código abaixo e comente sobre como o operador ~not~ funciona.

#+begin_src python
  print(not True)
  print(not False)
#+end_src

#+RESULTS:
: False
: True

Operadores lógicos podem ser combinados na mesma declaração. Quando for fazer uma combinação de operadores lógicos, lembre-se de usar o parênteses para garantir a ordem de execução desejada.

#+begin_src python
  A = True
  B = False
  print((A or B) and not (B and A))
#+end_src

#+RESULTS:
: True

*[D]* É possível somar variáveis booleanas? Quanto vale ~True + True~? Quanto vale ~False + False~? Quanto vale ~True + False~? Descubra a resposta para estas questões usando o Jupyter e busque online ou em livros o motivo para o resultado obtido. Escreva sobre o que encontrou. _Observação_: note que essa possibilidade de somar variáveis booleanas é apenas uma característica de como o Python armazena as variáveis booleanas. Isso não funciona dessa forma em lógica matemática.

*[Desafio]* Faça um programa que calcula a tabela verdade de uma expressão lógica. O programa deve exibir todas as variáveis e seus valores verdade, bem como o valor verdade da expressão lógica arbitrária fornecida pelo usuário. Fica a seu critério como a expressão lógica é inserida pelo usuário (pode ser no formato de string, função, lista, etc). Este é um desafio recomendado para que já souber laço de repetição.

** Operadores de comparação

#+begin_quote
"/O bolo é uma mentira./" --- frase escrita na parede, Portal
#+end_quote

Operadores de comparação (também conhecidos como operadores relacionais) fazem exatamente o que o nome sugere: comparam dois objetos. O resultado dessa comparação é uma variável booleana (ou seja, pode ter o valor ~True~ ou ~False~).

Existem 6 operadores de comparação em Python:
+ igualdade (~==~)
+ diferença (~!=~)
+ maior que (~>~)
+ menor que (~<~)
+ maior ou igual que (~>=~)
+ menor ou igual que (~<=~)

*[A]* Suponha que ~A = 1~, ~B = 2~, ~C = 4~, ~D = 8~ e ~E = 16~. Atribua o valor verdadeiro ou falso para cada uma das expressões abaixo. Escreva um código em Python para checar se você acertou. Comente sobre como funcionam as expressões com mais de um operador de comparação.

#+begin_src python
  A == B
  A < B
  B > C
  D <= E
  A != E
  E >= D >= C
  A < C == D
  A + A != B
  A + A < B < C - B
  A + A <= B <= C - B
  A != B < C == E - D - C
#+end_src

#+RESULTS:
#+begin_example
False
True
False
True
True
True
False
False
False
True
True
#+end_example

_Cuidado_: é muito comum confundir o operador de atribuição (~=~) com o operador de comparação de igualdade (~==~). O operador de atribuição é usado para atribuir um valor a uma variável, por exemplo: ~A = 10~ atribui o valor 10 para a variável ~A~. Já o operador de comparação de igualdade responde a pergunta se os objetos sendo comparados são iguais. Neste caso, a expressão ~A == 10~ responde a pergunta se o valor armazenado em ~A~ é igual a 10 (resposta esta que pode ser ~True~ ou ~False~).

** Estrutura de decisão e operador condicional

#+begin_quote
"/Se você ouvir com muita atenção, a música finalmente chegará até você./" --- Stairway to Heaven, Led Zeppelin
#+end_quote

Em diversos momentos da vida nos adaptamos mediante às condições do ambiente. Por exemplo, ao sair de casa, /se/ estiver chovendo /então/ pegamos o guarda-chuva, /se não/ nós saímos de casa sem o guarda-chuva. Esta estrutura condicional também existe nas linguagens de programação. Em diversos momentos, queremos que a execução de certos comandos só ocorram caso uma ou mais condições sejam atendidas.

O exemplo do guarda-chuva pode ser escrito em Python. Vamos supor que a variável booleana ~esta_chovendo~ armazena o valor ~True~ caso esteja chovendo ou o valor ~False~ caso não esteja chovendo. Queremos armazenar na variável booleana ~pegar_guardachuva~ o valor de ~True~ para o caso onde vamos pegar o guarda-chuva e o valor de ~False~ para o caso onde não vamos pegar o guarda-chuva. O código abaixo ilustra uma forma possível de programar essa decisão em Python. Veja que a palavra "if" em inglês traduz para "se" em português e que a palavra "else" traduz para "se não". Fique à vontade para trocar o valor da variável ~esta_chovendo~ para ~False~ para ver o que acontece.

#+begin_src python -n
  esta_chovendo = True

  if esta_chovendo == True:
      pegar_guardachuva = True
      print("Vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

No código acima, a instrução ~if~ checa se a condição "~esta_chovendo == True~" é verdadeira. Esta condição será verdadeira se a variável ~esta_chovendo~ tiver o valor ~True~. Existem duas possibilidades:

1) Se a condição checada for /verdadeira/, o bloco do ~if~ será executado e o bloco do ~else~ será ignorado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão executadas e as linhas 7 e 8 não serão executadas);

2) Se a condição checada for /falsa/, o bloco do ~if~ será ignorado, e o bloco do ~else~ será executado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão ignoradas e as linhas 7 e 8 serão executadas).

Independentemente do resultado do teste da condição, a primeira e a última linha do código serão executadas pois elas /não/ estão dentro da estrutura de decisão.

Observe que a sintaxe de estruturas de decisão requer que o bloco referente ao ~if~ e o bloco referente ao ~else~ estejam /indentados/. Indentação de código é quando utilizamos uma certa quantidade de espaços para agrupar visualmente linhas de código pertencentes a um mesmo bloco. Segundo o guia de estilo do Python (a PEP 8 que vimos lá na Introdução), é recomendado usar 4 espaços para cada indentação do seu código.

É bom saber que se seu código não estiver indentado corretamente, ele muito provavelmente não irá realizar a tarefa que você tinha em mente. Em certos casos, uma falha em indentar corretamente seu programa irá acusar um erro. Tente rodar o código abaixo e veja o que acontece (veja que ele é o mesmo código que vimos acima, porém sem indentação)[fn:: Aqui vale a pena comentar que o requisito de blocos de códigos estarem indentados é uma característica de algumas linguagens de programação, porém não todas! Códigos em ~C~, por exemplo, não têm esse requisito. Mesmo assim, é considerado bom estilo sempre indentar seu código para facilitar a leitura, independente da linguagem de programação que você está utilizando.].

#+begin_src python -n
  esta_chovendo = True

  if esta_chovendo == True:
  pegar_guardachuva = True
  print("Vou pegar o guarda-chuva")
  else:
  pegar_guardachuva = False
  print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

*[A]* Em que outros momentos da sua vida você faz escolhas seguindo uma estrutura condicional contendo /se/, /então/ e /se não/? Escreva (em português mesmo) sobre um destes momentos dizendo como você se comporta (tome como base o exemplo do guarda-chuva). Escreva um código de Python para a decisão que você descreveu.

É bastante comum nos depararmos com situações onde nossa decisão depende de mais de uma condição. Digamos, por exemplo, que só queremos pegar o guarda-chuva se estiver chovendo e se for um dia de semana (do contrário, decidimos que vamos ficar em casa e não precisamos do guarda-chuva). Uma solução para isso é adicionar um novo ~if~ ao código; veja o exemplo abaixo e note as diferentes indentações para indicar diferentes blocos de código. Note também que cada par de instruções ~if~ e ~else~ devem estar na mesma indentação. Isso significa que o ~else~ da linha 11 faz par com o ~if~ da linha 4. Da mesma forma, o ~else~ da linha 8 faz par com o ~if~ da linha 5.

#+begin_src python -n
  esta_chovendo = True
  final_de_semana = False

  if esta_chovendo == True:
      if final_de_semana == False:
          pegar_guardachuva = True
          print("Vou pegar o guarda-chuva")
      else:
          pegar_guardachuva = False
          print("Não vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

*[B]* Descreva uma situação onde você precisa considerar duas condições para tomar uma decisão e escreva ela em um código de Python.

# A linguagem Python contém uma série de expressões que são o que chamamos de /açúcar sintático/. Um açúcar sintático é uma forma de comunicar uma informação de maneira mais fácil ou mais expressiva. O código acima pode ser reescrito da seguinte maneira:

# #+begin_src python -n
#   esta_chovendo = True
#   final_de_semana = False
#
#   if esta_chovendo:
#       if not final_de_semana:
#           pegar_guardachuva = True
#           print("Vou pegar o guarda-chuva")
#       else:
#           pegar_guardachuva = False
#           print("Não vou pegar o guarda-chuva")
#   else:
#       pegar_guardachuva = False
#       print("Não vou pegar o guarda-chuva")
#
#   print("Fim do programa")
# #+end_src

# *[D]* Teste o código acima e reporte se ele funciona da forma esperada. O que mudou em comparação com o original? Explique como funciona o açúcar sintático exemplificado acima. Na sua opinião, este tipo de açúcar sintático facilitou a sua leitura do código?

*[C]* Reescreva o código acima de forma que ele se comporte da mesma maneira, porém usando apenas uma instrução ~if~ e apenas uma instrução ~else~. _Dica_: pense em qual operador lógico poderia te ajudar aqui!

O código abaixo checa em qual faixa está um certo valor de pH fornecido (relembre o que é o pH lendo o artigo da [[https://pt.wikipedia.org/wiki/PH][Wikipedia]] caso necessário) e reporta para o usuário se sua solução é ácida, básica, neutra ou se houve algum equívoco e o valor de pH é inválido. Observe que a cláusula ~else~ é _opcional_ e não foi usada no código abaixo. Fique à vontade para testar o código abaixo com diferentes valores para a variável ~ph~.

#+begin_src python -n
  ph = 7

  if (ph < 0) or (ph > 14):
      print("pH inválido")

  if 0 <= ph < 6.5:
      print("pH ácido")

  if 6.5 <= ph <= 7.5:
      print("pH neutro")

  if 7.5 < ph <= 14:
      print("pH básico")
#+end_src

#+RESULTS:
: PH neutro

Imagine que você mediu o pH de um vinagre e obteve o valor de 2,5. Ao rodar o código acima, o programa irá te dizer "pH ácido" (teste e veja!). Veja que o programa poderia ter parado de rodar depois de resolver o ~if~ da linha 6 (afinal, não faz sentido checar se o pH é neutro ou básico após identificar que se trata de um pH ácido), porém ele _irá_ rodar os ~if~ das linhas 9 e 12 pois é assim que o programa foi escrito.

*[D]* Reescreva o código acima usando cláusulas ~else~ de forma que o programa não rode nenhuma cláusula ~if~ desnecessária para entregar a resposta ao usuário (isto é: após ter encontrado a resposta, nenhum outro ~if~ deve ser executado!).

Uma estrutura muito comum em programação é quando queremos dizer "se a condição testada não for verdadeira, então teste esta outra condição aqui". Para isso usamos a cláusula ~elif~ que seria um ~else~ com um ~if~ "grudados". O código abaixo é similar ao anterior, porém usando ~elif~

#+begin_src python -n
  ph = 7

  if 0 <= ph < 6.5:
      print("pH ácido")

  elif 6.5 <= ph <= 7.5:
      print("pH neutro")

  elif 7.5 < ph <= 14:
      print("pH básico")

  else:
      print("pH inválido")
#+end_src

#+RESULTS:
: pH neutro

O código acima checa se o pH é ácido. Caso seja ácido o programa exibe "pH ácido" para o usuário e nada mais será executado. Caso não seja ácido, o programa checa então se é neutro. Caso seja neutro o programa exibe "pH neutro" para o usuário e nada mais será executado. Caso não seja neutro também, o programa faz uma última checagem para confirmar se é um pH básico. Assim sendo, o usuário verá o texto "pH básico" e o programa se encerra. Se o pH não for ácido, nem neutro, nem básico, então podemos afirmar com segurança que o programa recebeu um valor inválido de pH.

*[E]* Escreva um programa similar ao programa do pH que checa alguma grandeza escalar e exibe para o usuário uma informação sobre esta grandeza. Utilize pelo menos duas cláusulas ~elif~ no seu programa.

# Além da estrutura de decisão ~if~ / ~else~ existe o /operador condicional/. É importante saber que ele existe, porém na maioria dos casos é preferível que você use a estrutura de decisão mesmo por ser uma construção mais legível. O exemplo abaixo mostra uma estrutura condicional (linhas 3 a 6) e o operador condicional (linha 8), ambos realizam a mesma tarefa. Note que a cláusula ~else~ é opcional na estrutura condicional porém obrigatória no operador condicional.

# #+begin_src python -n
#   condicao = True
#
#   if condicao:
#       a = 100
#   else:
#       a = 5
#
#   a = 100 if condicao else 5
# #+end_src
#
# #+RESULTS:

*[F]* Escreva um código que tem uma variável inteira chamada ~numero~. Este código deve reportar ao usuário se este número é par ou ímpar.

*[G]* Escreva um programa que tem três variáveis numéricas ~a~, ~b~ e ~c~. O programa deve exibir ao usuário os valores contidos em ~a~, ~b~ e ~c~ em ordem crescente. Ele deve funcionar para qualquer valor numérico de ~a~, ~b~ e ~c~.

*[Desafio]* Escreva um programa que contém uma variável inteira positiva chamada ~ano~. O programa deve mostrar ao usuário se o ano em questão é um ano bissexto ou não. As regras para um ano ser bissexto são as seguintes:

1) Se o ano é divisível por 4, execute o passo 2. Do contrário, vá ao passo 5.
2) Se o ano é divisível por 100, execute o passo 3. Do contrário, vá ao passo 4.
3) Se o ano é divisível por 400, vá ao passo 4. Do contrário, vá ao passo 5.
4) Conclusão: o ano é bissexto!
5) Conclusão: o ano não é bissexto!

*[Desafio 2]* Escreva um programa que contém uma variável inteira chamada ~numero~. Esta variável armazena um número que deve estar entre 1000 e 9999. O programa deve checar se esse número é um número palíndromo e reportar essa informação ao usuário. Um número palíndromo é aquele que tem o mesmo valor quando a ordem dos seus dígitos é invertida, por exemplo:
1) o número 1234 não é número palíndromo pois é diferente de 4321.
2) o numero 3223 é um número palíndromo.

** Uma breve introdução sobre estilo

#+begin_verse
"/Bonito é melhor que feio.
Explícito é melhor que implícito.
Simples é melhor que complexo.
Complexo é melhor que complicado.
Linear é melhor do que aninhado.
Esparso é melhor que denso.
Legibilidade conta./"
     --- [[https://www.python.org/dev/peps/pep-0020/][O Zen do Python]]
#+end_verse

#+begin_quote
"/Devia ter complicado menos.../" --- Epitáfio, Titãs
#+end_quote

Em geral, programadores gastam muito mais tempo /lendo/ código do que /escrevendo/ código. Toda vez que recebemos um código escrito por outra pessoa, temos que ler para entender o que ele faz (exemplo: todos os códigos desta apostila). Toda vez que vamos corrigir um problema no código que nós escrevemos, devemos ler para identificar o local da correção. Toda vez que vamos adicionar uma nova funcionalidade para um código já escrito, devemos ler para entender a melhor forma de implementar essa adição.

Quando estamos lendo um código, nossa cabeça está "compilando" o que lemos internamente, isto é: estamos montando as peças do quebra-cabeça que é o que o código faz. Veja que isso não é diferente de ler algo em português! Esta frase que você está lendo agora é apenas um amontoado de letras para uma pessoa que não sabe português, mas para você ela faz sentido e comunica algo pois você sabe interpretar a linguagem.

Veja o código abaixo. Qual você acha que é o valor exibido pela função ~print~? Está bastante claro, não é? Trata-se de um código trivial para quem sabe o tanto de Python que você já sabe.

#+begin_src python
  x = 10
  y = x + x
  print(y)
#+end_src

#+RESULTS:
: 20

Agora veja o código abaixo. Novamente, qual valor você acha que é o valor exibido pela função ~print~? A verdade é que é exatamente o mesmo valor do código acima (teste no Jupyter!). No entanto, este código foi escrito de propósito para ser ilegível (nem parece que funciona, não é?). O objetivo dessa provocação é mostrar que existem diversas formas de realizar uma mesma tarefa em Python. Neste exemplo, uma delas é trivial de ler enquanto a outra demanda muito tempo para ser entendida!

#+begin_src python
  x = 2 ** \
      6 \
      / 6.4
  y = (
      [x +
       [
          x * \
           x // \
           x
      ][0]
       ][0]
  )
  print(y)
#+end_src

#+RESULTS:
: 20.0

Em geral, um código que funciona é /melhor/ que um código que não funciona. Porém, um código legível que funciona é /bem melhor/ que um código que apenas funciona. É muito tentador escrever códigos que funcionam sem se preocupar que eles sejam legíveis... cuidado para não cair no paradigma do POG ([[https://www.livropog.com.br/][Programação Orientada à Gambiarra]]).

# *[A]* Escreva um código que executa uma tarefa simples, porém escreva-o da forma mais ilegível que você conseguir. Troque o seu código com um colega e tente entender o código que recebeu antes de executá-lo no Python.

Veja que nem sempre conseguimos nos expressar em Python de forma que a leitura seja trivial. Isso acontece em qualquer linguagem! Existem certos conceitos e tarefas que simplesmente são complexos de serem representados. Isso é normal! Para facilitar nossas vidas, em programação existe o conceito de /comentários/. Comentários são linhas de texto ao longo do código que são ignoradas pelo compilador quando o código é executado. Comentários servem para ajudar quem está lendo o código a entender mais facilmente o que ele faz. É uma forma do criador do código de se comunicar com seu leitor sem que isso interfira na execução do código em si. Veja o exemplo abaixo.

#+begin_src python
  # este é um comentário. Tudo que está após o `#` será ignorado pelo Python
  x = -10

  y = abs(x)  # `y` recebe o valor absoluto de `x` (explicação na linha)

  # exibe o valor de `y` (explicação antes do que será executado)
  print(y)
#+end_src

#+RESULTS:
: 10

Para iniciantes é recomendado sempre comentar seu código. Isso não só irá te ajudar a organizar suas ideias mas também ajudar quem for ler seu código a entender o que ele faz. Em níveis intermediários, recomenda-se deixar comentários apenas em partes do código que não são triviais de se entender.

*[A]* Escreva um código que calcula as raízes de uma equação de segundo grau $f(x) = ax^2 + bx + c$ usando a fórmula de Bhaskara. Comente todas as etapas do seu código. Siga o modelo abaixo.

#+begin_src python
  # valores dos coeficientes (pode alterar se quiser)
  a = 10
  b = 3
  c = -5

  # delete este comentário e escreva seu código aqui.

  # mostra as raízes para o usuário
  print(raiz_1)
  print(raiz_2)
#+end_src

*[Desafio]* Escreva um código que resolve um problema de física, matemática, química ou biologia a sua escolha. Escreva um comentário com seu nome, a data e o que seu código faz. Escreva um comentário em cada etapa que considere não-trivial do seu código.

# *[D*]* Escreva em uma célula o código abaixo e execute. Nós ainda não vimos essa sintaxe, mas mesmo assim tente e veja o que acontece. A mensagem exibida é um poema chamado /O Zen do Python/. Veremos adiante que a sintaxe com a instrução ~import~ é usada para carregar (importar) módulos. Neste caso, o ~import this~ não faz nada mais do que exibir o poema, mas veremos adiante que a instrução ~import~ é absurdamente útil e importante!

# #+begin_src python
#   import this
# #+end_src

* Funções
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_funcoes
:EXPORT_OPTIONS: toc:t
:ID:       b20f8635-108a-49d4-9903-6a397dc4fed2
:END:

** O que é uma função?

#+begin_quote
"/É função da ciência descobrir a existência de um regime geral de ordem na natureza e encontrar as causas que governam esta ordem./" --- Dmitri Mendeleev
#+end_quote

Durante o exercício "Olá, Mundo!" nós utilizamos a função ~print~. Naquele momento, definimos funções como sendo "apelidos" para executar códigos que já foram escritos. De fato, esta é uma das grandes vantagens de funções: você escreve o código apenas uma vez e reaproveita ele quantas vezes forem necessárias! Além de economizar tempo, o uso apropriado de funções deixa o propósito do código mais fácil de ser entendido.

De maneira geral, uma função tem quatro partes:

1) um /nome/,
2) zero ou mais objetos chamados de /argumento/,
3) um bloco de código chamado de /corpo da função/,
4) zero ou mais objetos chamados de /retorno/.

Basicamente, ao executar uma função ela recebe zero ou mais objetos (argumento), executa seu bloco de código (usando ou não os argumentos recebidos) e retorna zero ou mais objetos (retorno). Veja que o conceito de função em programação não é o mesmo que o conceito de função em matemática. Certas funções em programação podem ser chamadas de funções matemáticas, porém não todas!

** Funções embutidas

#+begin_quote
"/Vou querer Spam, Spam, Spam, Spam, Spam, Spam, feijão cozido, Spam, Spam, Spam e Spam!/" --- Sr. Bun, Monty Python's Flying Circus
#+end_quote

Existem diversas funções embutidas em Python. Estas funções podem ser usadas _a qualquer momento_, sem a necessidade de executar nenhum comando prévio. Além das funções embutidas que já vimos (~print~ e ~help~, por exemplo) existem diversas outras! A lista completa pode ser conferida na [[https://docs.python.org/pt-br/3/library/functions.html][documentação oficial]].

# *[A]* Para cada uma das funções embutidas abaixo, escreva em uma célula de texto o nome da função, descreva seus argumentos, explique em suas palavras o que a função faz e descreva seus valores de retorno. Na célula seguinte, escreva um código que use esta função. Comente seu código!

# + ~any~
# + ~all~
# + ~len~
# + ~abs~

** Definindo novas funções

#+begin_quote
"/Definir é limitar./" --- Oscar Wilde, O Retrato de Dorian Gray
#+end_quote

Podemos definir nossas próprias funções utilizando a instrução ~def~. O código abaixo mostra diversos exemplos de definições de funções. Observe que todas as definições começam com ~def~, seguido do nome da função, seguido de parêntesis e por fim dois-pontos. É considerado bom estilo pular duas linhas antes e depois da definição de funções e nomear funções com a primeira letra minúscula. Ao fim do código abaixo, as funções definidas são executadas. Para executar funções basta escrever o nome delas seguido de parênteses (os argumentos vão dentro destes parênteses).

#+begin_src python -n
  def funcao_1():
      print("Esta é a função 1")


  def funcao_2(argumento1):
      print("Esta é a função 2")
      print(argumento1)


  def funcao_3(argumento1, argumento2):
      print("Esta é a função 3")
      print(argumento1)
      print(argumento2)


  def funcao_4(argumento1, argumento2):
      print("Esta é a função 4")
      soma = argumento1 + argumento2
      return soma


  def funcao_5(argumento1, argumento2):
      print("Esta é a função 5")
      return 10


  def funcao_6(argumento1, argumento2, argumento3):
      print("Esta é a função 6")
      return argumento3, argumento2, argumento1


  print('Testando a funcao_1')
  retorno = funcao_1()
  print(retorno)
  print()

  print('Testando a funcao_2')
  retorno = funcao_2("Olá")
  print(retorno)
  print()

  print('Testando a funcao_3')
  retorno = funcao_3("Olá", "mundo")
  print(retorno)
  print()

  print('Testando a funcao_4')
  retorno = funcao_4(1, 2)
  print(retorno)
  print()

  print('Testando a funcao_5')
  retorno = funcao_5(1, 2)
  print(retorno)
  print()

  print('Testando a funcao_6')
  retorno = funcao_6("a", "b", "c")
  print(retorno)
  print()

  print('Testando a funcao_6 novamente')
  retorno1, retorno2, retorno3 = funcao_6("a", "b", "c")
  print(retorno1, retorno2, retorno3)
  print()
#+end_src

#+RESULTS:
#+begin_example
Testando a funcao_1
Esta é a função 1
None

Testando a funcao_2
Esta é a função 2
Olá
None

Testando a funcao_3
Esta é a função 3
Olá
mundo
None

Testando a funcao_4
Esta é a função 4
3

Testando a funcao_5
Esta é a função 5
10

Testando a funcao_6
Esta é a função 6
('c', 'b', 'a')

Testando a funcao_6 novamente
Esta é a função 6
c b a

#+end_example

A ~funcao_1~ não recebe nenhum argumento. Sabemos que este é o caso pois não existe nenhuma informação dentro dos parênteses logo após o comando ~def funcao_1~. Quando executada, esta função exibe a mensagem "Esta é a função 1". Não existem valores de retorno pois em nenhum local do corpo da função existe a instrução ~return~. Funções que não possuem valor de retorno explícito sempre retornam ~None~ quando encerram sua execução. ~None~ é o chamado /objeto nulo/ e ele passa a mensagem que não existe valor associado ao objeto. Observe que ~None~ não significa o valor zero nem o valor ~False~.

A ~funcao_2~ recebe um argumento chamado ~argumento1~. Todos os argumentos recebidos pelas funções podem ser utilizados no corpo da função. No caso desta função, o valor do ~argumento1~ é exibido ao usuário através da função ~print~. Novamente, não existem valores de retorno.

A ~funcao_3~ recebe dois argumentos, ~argumento1~ e ~argumento2~. Note que os nomes dos argumentos são separados por vírgula. Funções podem ter quantos argumentos forem necessários, desde que todos eles sejam declarados no local apropriado (isto é, dentro dos parênteses). Novamente, não existem valores de retorno.

A ~funcao_4~ recebe dois argumentos, calcula a soma deles e retorna este valor. O retorno do valor é feito pela instrução ~return~ no corpo do da função. Observe na linha 48 como podemos armazenar o valor retornado pela função em uma variável.

A ~funcao_5~ recebe dois argumentos e retorna o valor 10. Observe que não é necessário utilizar os argumentos da função no corpo da mesma. No entanto, não é uma boa prática definir argumentos que não serão utilizados no corpo da função! Evite este tipo de comportamento.

Finalmente, a ~funcao_6~ recebe três argumentos e retorna os mesmos argumentos em ordem inversa . Observe que a instrução ~return~ permite retornar mais que um valor. Se retornar mais que um valor, estes devem estar separados por vírgulas. Na linha 58 temos uma situação inusitada: a ~funcao_6~ retorna três valores, mas estamos atribuindo o retorno desta função a apenas uma variável chamada ~retorno~. Se você rodar este código perceberá que não ocorrem erros. Neste caso, os três valores de retorno são agrupados em um objeto chamado de /tupla/ e armazenados na variável ~retorno~ (veremos tuplas mais adiante). Observe a sintaxe da linha 63 para ver como separar os valores de retorno em variáveis independentes.

*[A]* Crie e execute funções para realizar as tarefas abaixo:

+ Uma função que recebe um valor numérico e retorna o cubo deste valor.
+ Uma função que recebe cinco valores e retorna o valor médio e o desvio padrão destes valores.
+ Uma função que recebe três números e retorna os números recebidos em ordem decrescente.

*[B]* Crie uma função que recebe um argumento e tente executar ela sem fornecer nenhum argumento. Após este teste, tente executar ela fornecendo dois argumentos quaisquer. Observe e relate o que aconteceu.

*[C]* Execute o código abaixo e comente o que ocorre quando executamos a linha 6. Nesta linha a função ~ola~ foi executada sem os parênteses. Seu código rodou com erro ou se erro? De qualquer forma elabore o que aconteceu.

#+begin_src python -n
  def ola():
      return "Olá!"


  print(ola())
  print(ola)
#+end_src

#+RESULTS:
: Olá!
: <function ola at 0x7f69502dfd90>

*[Desafio]* Escreva uma função que recebe 5 argumentos numéricos e retorna o valor do segundo maior número recebido.

*[Desafio 2]* Escreva uma função que recebe 5 argumentos numéricos e exibe todos os valores únicos que recebeu (isto é, não exibe valores repetidos).

** Argumentos posicionais, argumentos nomeados e argumentos com valor padrão

#+begin_quote
"/O raciocínio é um argumento em que, estabelecidas certas coisas, outras coisas diferentes se deduzem necessariamente das primeiras./" --- Aristóteles
#+end_quote

A ordem dos argumentos é muito importante durante a execução de funções com dois ou mais argumentos. O exemplo abaixo ilustra isso: a inversão da ordem dos argumentos altera o resultado do retorno da função. Cada argumento de uma função tem a sua _posição_, então é necessário se atentar a ordem dos argumentos para evitar erros.

#+begin_src python
  def exponenciacao(base, expoente):
      return base ** expoente


  print(exponenciacao(10, 2))  # resulta em 100
  print(exponenciacao(2, 10))  # resulta em 1024
#+end_src

#+RESULTS:
: 100
: 1024

Todo argumento tem um _nome_[fn:: Na verdade, veremos adiante que existem casos onde argumentos podem não ter nome, são os chamados argumentos estrela. Não se preocupe com isso agora.]. Na função ~exponenciacao~ acima temos dois argumentos, um chamado de ~base~ e outro de ~expoente~. Podemos executar essa função chamando os argumentos pelo nome! Veja no exemplo abaixo.

#+begin_src python -n
  def exponenciacao(base, expoente):
      return base ** expoente


  print(exponenciacao(base=10, expoente=2))  # resulta em 100
  print(exponenciacao(expoente=2, base=10))  # resulta em 100
  print(exponenciacao(10, expoente=2))       # resulta em 100
  print(exponenciacao(expoente=2, 10))       # ERRO!
  print(exponenciacao(expoente=2))           # ERRO!
  print(exponenciacao(base=10))              # ERRO!
#+end_src

#+RESULTS:
: 100
: 100
: 100

Na linha 5 acima, a função ~exponenciacao~ é executada com seus argumentos chamados pelo nome.

Na linha 6 vemos que não é necessário apresentar os argumentos nomeados seguindo a mesma ordem dos argumentos assim como definida na função. Isso funciona desde que todos os argumentos tenham um valor atribuído no momento de execução da função.

Na linha 7 vemos que é possível misturar argumentos nomeados com argumentos posicionais. Neste caso, o valor "10" está na posição zero, logo ele será atribuído à variável ~base~ da função ~exponenciacao~. O valor do argumento ~expoente~ foi nomeado durante a execução e atribuído o valor de "2".

A linha 8 parece similar a linha 7, porém ela acusa um erro quando executada!! Isso porque não é permitido argumentos posicionais /após/ argumentos nomeados. Se você for utilizar uma mistura de argumentos posicionais com nomeados, certifique-se que os argumentos nomeados estão todos após os argumentos posicionais.

As linhas 9 e 10 mostram que precisamos garantir que todos os argumentos tenham valores atribuídos, do contrário a função não executa.

Argumentos nomeados ajudam na leitura do código, principalmente quando as funções e argumentos receberam bons nomes. Por exemplo: as linhas 5 e 6 do código acima deixam bem clara a intenção do código.

Por fim, além de uma posição e um nome, argumentos opcionalmente podem ter um _valor padrão_. O valor padrão é atribuído com o operador de atribuição ~=~ logo após o nome do argumento. Veja o exemplo abaixo.

#+begin_src python -n
  def exponenciacao(base, expoente=5):
      return base ** expoente


  print(exponenciacao(base=10, expoente=2))  # resulta em 100
  print(exponenciacao(base=10))              # resulta em 100000
  print(exponenciacao(10))                   # resulta em 100000
  print(exponenciacao(expoente=2))           # ERRO! Falta o valor da base
#+end_src

#+RESULTS:
: 100
: 100000
: 100000

A nova função ~exponenciacao~ tem um valor padrão para o argumento expoente (no caso, é o valor 5). Ela continua funcionando da mesma maneira que a função anterior. Execute a linha 5 e verá que isso é verdade. Com o valor padrão do argumento ~expoente~, podemos executar as linhas 6 e 7 sem problema. Em ambos os casos, nós informamos apenas o valor do argumento ~base~ quando executamos a função. Ao fazer isso, estamos dizendo à função que ela deve usar o valor padrão para o argumento ~expoente~. Finalmente, a linha 8 resulta em um erro pois o valor para o argumento ~base~ não foi informado para a execução da função ~exponenciacao~.

Observe que não é permitido declarar argumentos sem valor padrão após argumentos com valor padrão. Por conta disso o código abaixo resulta em erro ao ser executado.

#+begin_src python
  def exponenciacao(base=10, expoente):
      return base ** expoente
#+end_src

*[A]* Crie uma função que tira a n-ézima raiz de um número. Faça com que o índice da raiz tenha um valor padrão de 2.

*[B]* Crie uma função que recebe o raio de um círculo e retorna seu perímetro e sua área.

** Variáveis globais e variáveis locais

#+begin_quote
"/Pense globalmente, aja localmente./" --- Paul McCartney
#+end_quote

Variáveis criadas dentro de funções são /locais/ e só existem dentro do escopo da função.

*[A]* Teste se a afirmação acima é verdade executando o código abaixo. Relate o que aconteceu.

#+begin_src python -n
  def refeicao():
      opcao_1 = "SPAM"
      opcao_2 = "SPAM"
      opcao_3 = "ovos"
      opcao_4 = "bacon"
      return opcao_1, opcao_2, opcao_3, opcao_4

  lanche_da_tarde = refeicao()
  print(opcao_1)
#+end_src

#+RESULTS:

No código acima a função ~refeicao~ declara internamente 4 variáveis, sendo elas ~opcao_1~, ~opcao_2~, ~opcao_3~ e ~opcao_4~. Executamos essa função na linha 8 e na linha 9 tentamos exibir o valor da variável ~opcao_1~. Entretanto, o compilador acusa um erro nos dizendo que a variável ~opcao_1~ não existe! Isso ocorre pois a variável ~opcao_1~ foi declarada /dentro do escopo/ da função ~refeicao~ e ela só existe dentro do escopo onde foi declarada. Após o término da execução da função todas as suas variáveis locais são _destruídas_ para liberar memória.

Variáveis declaradas fora do escopo de funções são variáveis /globais/. Variáveis globais podem ser acessadas em _qualquer escopo_, inclusive dentro do escopo de funções!

*[B]* Tendo em mente o que foi discutido, escreva e justifique o que você acha que irá acontecer se executarmos o código abaixo. Rode o código para checar se seu palpite estava certo.

#+begin_src python
  melhor_album = "The Dark Side of the Moon"  # esta é uma variável global


  def qual_o_melhor_album():
      print("O melhor album de todos os tempos é :")
      print(melhor_album)


  qual_o_melhor_album()
#+end_src

#+RESULTS:
: O melhor album de todos os tempos é :
: The dark side of the moon

Mesmo sabendo que variáveis globais podem ser utilizadas dentro de funções, este comportamento é _desencorajado_! Isso torna a leitura do código mais difícil, o uso da função menos geral e aumenta a chance de /bugs/ no seu código! Se necessário utilizar uma variável global em uma função, opte por adicionar um argumento com a variável global como valor padrão.

*[C]* O que acontece quando um argumento de uma função tem o mesmo nome de uma variável global? Teste isso escrevendo seu próprio código e explique em suas palavras o que observou.

*[D]* O que acontece quando uma variável global é alterada dentro de uma função? Explique em suas palavras o que observou.

** Documentando suas funções com a docstring

#+begin_quote
"/Depois de tudo o que passamos. Tudo o que eu fiz. Isto não pode ser em vão./" --- Ellie, The Last of Us
#+end_quote

Funções podem ser tão simples ou tão complexas quanto quisermos. As versões mais recentes do Python permitem que as funções tenham quantos argumentos e retornos nós desejarmos. Também não há limites quanto a quantidade de linhas de código no corpo da função.

Mas como dizia o tio Ben: com grandes poderes vem grandes responsabilidades! Você pode escrever hoje a função mais complexa do mundo e resolver todos os seus problemas. Tudo certo enquanto a função está fresca na sua mente. Daqui a três meses você precisa utilizar essa função novamente e já não se recorda mais o que cada argumento controla, não entende mais o valor de retorno e não tem tempo de interpretar as doze mil linhas de código que compõe o corpo da função... e agora?

Uma solução para +evitar+ reduzir dor de cabeça no futuro é documentar sua função escrevendo a chamada /docstring/. Documentar a função nada mais é do que escrever o que ela faz, detalhando todas as partes importantes para que qualquer um que venha a usar a função entenda qual é o seu propósito e o que pode esperar quando executá-la. O guia de estilo de docstrings em Python é a PEP 257 e pode ser acessada em https://www.python.org/dev/peps/pep-0257/.

A docstring mais simples de todas é a "docstring em uma linha". Trata-se de uma descrição breve do que a função faz e, como o nome sugere, não deve ultrapassar uma linha. Veja a docstring da função ~soma_pares~ na linha 2 abaixo. Note que docstrings devem ser a primeira linha do corpo da função (logo abaixo a definição da mesma) e são strings declaradas com três aspas. Na descrição em uma linha, use verbos no imperativo! Podemos acessar a docstring de qualquer função usando o comando ~help~ (veja a linha 20) ou acessando o atributo especial ~__doc__~ (veja a linha 22).

#+begin_src python -n
  def soma_pares(numero1, numero2, numero3):
      """Recebe três números e soma apenas os pares."""
      soma = 0

      if numero1 % 2 == 0:
          soma = soma + numero1

      if numero2 % 2 == 0:
          soma = soma + numero2

      if numero3 % 2 == 0:
          soma = soma + numero3

      return soma


  print(soma_pares(10, 5, 6))

  print()
  help(soma_pares)  # mostra informações sobre a função

  print(soma_pares.__doc__)  # mostra a doscring da função
#+end_src

#+RESULTS:
: 16
:
: Help on function soma_pares in module __main__:
:
: soma_pares(numero1, numero2, numero3)
:     Recebe três números e soma apenas os pares.
:
: Recebe três números e soma apenas os pares.

*[A]* Escreva uma função que recebe três números e retorna a multiplicação de todos os números ímpares. Escreva uma docstring em uma linha para sua função.

Docstrings em uma linha são suficientes para funções mais simples com poucas linhas de código. Funções mais complexas se beneficiam de mais informações na docstring para deixar claro seu funcionamento, como por exemplo:

1) Uma descrição mais aprofundada da função;
2) Uma listagem de todos os argumentos da função, descrevendo o que eles controlam;
3) Uma listagem de todos os retornos da função, descrevendo o que eles são;
4) Uma listagem de todos os erros capturados e levantados pela função;
5) Exemplos do uso da função;
6) Notas e informações adicionais como links e referências.

Para armazenar mais informações, precisamos fazer uso das "docstrings de múltiplas linhas". A PEP 257 não define como docstrings de múltiplas linhas devem ser escritas e, por conta disso, existem diversos guias de estilos diferentes. Nenhum estilo é objetivamente melhor ou pior que o outro, no entanto é considerado bom costume escolher um estilo para cada projeto e se ater a ele (misturar diferentes estilos pode confundir quem está lendo o código!). Esta apostila segue o Guia de Estilo de Python da Google que pode ser conferido em https://google.github.io/styleguide/pyguide.html?showone=Comments#s3.8.1-comments-in-doc-strings. Veja um exemplo abaixo.

#+begin_src python -n
  def soma_pares_ou_impares(numero1, numero2, numero3, tipo="pares",
                            verbose=False):
      """Recebe três números e retorna a soma dos pares ou ímpares.

      O cálculo da soma depende do argumento `tipo`. Cuidado, se o valor do
      argumento tipo não estiver correto o programa acusa um erro!

      Args:
        numero1:
          Um número inteiro qualquer.
        numero2:
          Um número inteiro qualquer.
        numero3:
          Um número inteiro qualquer.
        tipo:
          String que pode ter o valor `pares` ou `impares`. Controla quais números
          serão considerados para a soma. Valor padrão é `pares`.
        verbose:
          Booleano que controla se o resultado final será exibido ao usuário.
          `True` exibe o resultado. Valor padrão é `False`.

      Returns:
        Soma dos números pares ou ímpares.

      Raises:
        ValueError: ocorre se a variável `tipo` recebe um valor inválido.
      """

      if tipo == "pares":
          resto_divisao_por_dois = 0
      elif tipo == "impares":
          resto_divisao_por_dois = 1
      else:
          raise ValueError("Valor incorreto da variável `tipo`.")

      soma = 0

      if numero1 % 2 == resto_divisao_por_dois:
          soma = soma + numero1

      if numero2 % 2 == resto_divisao_por_dois:
          soma = soma + numero2

      if numero3 % 2 == resto_divisao_por_dois:
          soma = soma + numero3

      if verbose:
          print(soma)

      return soma


  soma_pares = soma_pares_ou_impares(10, 5, 6, "pares", True)
  soma_impares = soma_pares_ou_impares(10, 5, 6, "impares", True)

  # da erro!
  soma_complexos = soma_pares_ou_impares(10, 5, 6, "complexos", True)
#+end_src

#+RESULTS:
: 16
: 5

Vamos analisar as diversas partes do exemplo acima:

1) A primeira linha da docstring (linha 3) ainda é a descrição da função em uma linha. Ela sempre deve estar presente.

2) Na linha 5 temos a descrição mais aprofundada da função. Use quantas linhas quiser para essa descrição. Esta descrição não é obrigatória.

3) Na linha 8 damos início a descrição dos argumento com o cabeçalho ~Args:~. O nome de cada argumento é escrito com indentação de dois espaços seguido de dois-pontos. A descrição de cada argumento é feita com indentação de quatro espaços e pode conter quantas linhas quiser. Descreva o tipo de variáveis esperadas e o que o argumento controla. Conte para o leitor os valores esperados caso existam e deixe claro qual é o valor padrão quando for o caso. Esta seção é obrigatória caso a função receba um ou mais argumentos.

4) Na linha 22 damos início a descrição dos valores de retorno com o cabeçalho ~Returns:~. Aqui nós contamos quais os valores de retorno e o tipo deles, podemos usar quantas linhas forem necessárias. Esta seção é obrigatória caso existam retornos.

5) Na linha 25 damos início a descrição dos possíveis erros levantados pelo código. Estes são erros deliberadamente programados no corpo da função. Veremos mais sobre erros na seção de depuração de programas, mas por hora é relevante saber que se a variável ~tipo~ tiver um valor fora do esperado, a própria função acusa um erro e envia uma mensagem ao usuário para que ele possa corrigir seu código. Esta seção é obrigatória caso exista gerência de erros no corpo da função (instruções ~raise~ e ~assert~).

*[B]* Crie uma função com pelo menos três argumentos e escreva uma docstring em múltiplas linhas para ela. Sua função deve executar um código que tenha relevância científica.

** Funções também são objetos!

#+begin_quote
"/As vezes não é nada fácil encontrar uma citação minimamente relacionada ao tópico em questão."/ --- Daniel Cassar
#+end_quote

Funções em Python são objetos assim como números e strings. Desta forma, podemos passar funções como argumentos de funções (linhas 16, 19, 32 e 35 do código abaixo) e podemos ter funções como valores de retorno de outras funções (veja a linha 29)! Podemos inclusive definir novas funções no corpo de funções (linha 26).

#+begin_src python -n
  def soma_dois(x):
      """Soma dois a o valor recebido."""
      return x + 2


  def multiplica_dois(x):
      """Multiplica o valor recebido por dois."""
      return x * 2


  def aplica_funcao_composta(f1, f2, x):
      """Calcula a função composta de f1 e f2."""
      return f1(f2(x))


  retorno = aplica_funcao_composta(soma_dois, multiplica_dois, 10)
  print(retorno)  # mostra o número 22

  retorno = aplica_funcao_composta(multiplica_dois, soma_dois, 10)
  print(retorno)  # mostra o número 24


  def retorna_funcao_composta(f1, f2):
      """Retorna a função composta de f1 e f2."""

      def funcao_composta(x):
          return f1(f2(x))

      return funcao_composta


  funcao_composta = retorna_funcao_composta(soma_dois, multiplica_dois)
  print(funcao_composta(10))  # retorna 22

  funcao_composta = retorna_funcao_composta(multiplica_dois, soma_dois)
  print(funcao_composta(10))  # retorna 24
#+end_src

#+RESULTS:
: 22
: 24
: 22
: 24

*[Desafio]* Escreva uma função chamada ~poli~ que recebe um argumento chamado ~x~ e mais $n$ argumentos ($n > 2$) chamados de ~c_0~, ~c_1~, ... Estes argumentos que começam com a letra ~c~ serão os coeficientes de um polinômio de grau $n$. A função ~poli~ recebe todos estes argumentos e calcula o valor do polinômio no ponto ~x~. Agora crie uma função chamada ~integral~ que recebe 3 argumentos: ~a~, ~b~ e ~fun~. A função ~integral~ deve computar numericamente a integral entre ~a~ e ~b~ da função ~fun~. Teste sua função ~integral~ usando a função ~poli~. Não se esqueça de documentar suas funções com docstrings!

* Listas, tuplas e conjuntos
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_listas
:EXPORT_OPTIONS: toc:t
:ID:       979099a4-9da2-48d1-9d6a-308a97868f1c
:END:

** Agrupando objetos com listas

#+begin_quote
"/Lists are how I parse and manage the world./" --- Adam Savage
#+end_quote

Vamos começar pensando no seguinte cenário, você está em casa e não tem nada para comer... logo, você precisa ir até o supermercado comprar ingredientes para uma receita. A primeira coisa que vem a sua cabeça é comprar um pacote de miojo pois, afinal, é fácil de preparar. Mas, sua fome está grande, então poderia comprar dois pacotes de miojo, mas isso não parece tão atraente. Lhe ocorre a ideia de incrementar o miojo. Você pode adicionar queijo ralado, talvez cozinhar um ovo junto com o miojo. Além disso, você resolve comprar uma bebida para acompanhar, um refrigerante. Então, você lembra que a pasta de dentes está acabando, então decide comprar também, para aproveitar a ida ao mercado. O número de itens a se comprar já começa a ficar grande, então é melhor organizar suas compras em uma lista.

*[A]* Escreva a /sua/ lista de compras de supermercado desta semana em uma célula de texto no jupyter.

Maravilha! Agora você pode ir ao mercado fazer minhas compras. Então você passa no banheiro antes de sair e nota que falta papel higiênico. Hora, então você adiciona mais este item em sua lista.

*[B]* Atualize sua lista com um item que você esqueceu em uma nova célula de markdown.

Ótimo, agora está tudo pronto e você vai ao mercado fazer suas compras!

Este tipo de organização de itens ou objetos em listas é muito prático, podemos então aplicar o mesmo conceito a programação. Vamos criar uma lista de compras em um código Python, a sintaxe será a seguinte:

#+begin_src python
  listadecompras = ["Miojo", "Queijo ralado", "Ovo", "Pasta de dentes"]
  print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo ralado', 'Ovo', 'Pasta de dentes']

Poxa, mas esqueci de incluir o papel higiênico na lista! Tudo bem, podemos adicionar itens a nossa lista com o método ~append~. Façamos o seguinte:

#+begin_src python
  listadecompras = ["Miojo", "Queijo ralado", "Ovo", "Pasta de dentes"]
  print(listadecompras)

  listadecompras.append("Papel higiênico")
  print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo ralado', 'Ovo', 'Pasta de dentes']
: ['Miojo', 'Queijo ralado', 'Ovo', 'Pasta de dentes', 'Papel higiênico']

Perfeito, veja que o item foi adicionado a sua lista! Mas... de onde veio esse ~append~? E por que chamamos ele de método e não de função?

A resposta da primeira pergunta está intimamente relacionada ao fato de Python ser uma linguagem de programação orientada a objetos. Tudo em Python é um objeto[fn:: OK, /praticamente/ tudo em Python é um objeto. Certas coisas como os operadores e instruções como ~if~ e ~while~ não são objetos. Tudo que você declara é um objeto!]! Um objeto em Python é simplesmente um agrupamento de informações e funções; ao criar um objeto, você automaticamente "ganha de brinde" essas informações e funções sem a necessidade de fazer nada extra. É aqui que entra o ~append~ que vimos acima. Ele é uma "função" de todo objeto do tipo lista que serve para acrescentar um novo item no final da lista. Essas "funções de objeto" são chamadas de _métodos_ para diferenciar das funções que não estão associadas a objetos em particular. Métodos se comportam de maneira similar às funções que nós já vimos: devem ser chamados com parênteses, podem ter zero ou mais argumentos e podem ter zero ou mais valores de retorno.

*[C]* Escreva a lista da prática [A] acima como uma lista de Python. Após atribuir os objetos da lista, use o ~print~ para mostrar sua lista na tela. Use o método ~append~ para inserir o item da prática [B] acima e então exiba todos os itens da lista com ~print~ novamente.

** Listas dentro de listas.

#+begin_quote
"/This category contains pages which catalog other lists./" --- Wikipedia
#+end_quote

Agora voltando a sua saída ao supermercado, antes de sair você lembra que precisa comprar um caderno, papel e caneta. Mas, infelizmente o mercado que você irá não tem esses itens, você precisará ir a papelaria ao lado para comprar esses itens. Então você naturalmente faz uma nova lista de compras para a papelaria, incluindo os itens necessários.

+ Caderno
+ Papel
+ Caneta

No Python, podemos fazer listas dentro de listas, então vamos fazer uma lista de listas com os objetos do mercado e da papelaria:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  print(listadecompras)
#+end_src

#+RESULTS:
: [['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes'], ['Caderno', 'Papel', 'Caneta']]

Agora você pode notar que temos duas listas na variável ~listadecompras~, uma com os itens do mercado e uma com os itens da papelaria. Podemos exibir as listas individualmente, para isso façamos o seguinte:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  print(listadecompras[0])
  print(listadecompras[1])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes']
: ['Caderno', 'Papel', 'Caneta']

Note que o primeiro ~print~ exibe a primeira lista, de índice 0 e o segundo ~print~ exibe a segunda lista, de índice 1. Em Python a contagem começa sempre de zero e usamos os colchetes para resgatar os itens de listas.

Perfeito, mas agora deu vontade de comer uma sobremesa após o miojo incrementado, então você quer adicionar este item a lista do supermercado. Além disso, você achou que convém comprar um pacote de post-it, para colocar na geladeira, para não esquecer tanto dos itens que você tem que comprar. Portanto, é necessário adicionarmos estes itens nas listas. Podemos fazer isso com a seguinte sintaxe no Python:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  listadecompras[0].append("Chocolate")
  listadecompras[1].append("Post-it")

  print(listadecompras[0])
  print(listadecompras[1])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: ['Caderno', 'Papel', 'Caneta', 'Post-it']

*[A]* Crie uma lista de listas. Faça isso de tal forma que todas as listas que você criou sejam diferentes, assim como no exemplo da lista do supermercado e da papelaria. Lembre-se de utilizar a sua lista, não repetir as que demos de exemplo aqui.

*[B]* Exiba cada uma das listas da prática acima separadamente com o comando ~print~.

Pronto, as listas estão atualizadas com os itens que você incluiu.

*[C]* Agora, nas listas da atividade *[B]*, use o método ~append~ para adicionar itens a cada uma das suas listas na lista de listas. Lembre-se de exibir cada uma delas com a função ~print~.

** Modificando, particionando e desempacotando listas

Já foi apresentado um dos métodos utilizados em listas, o ~append~. Mas, existem outros métodos para listas, a seguir veremos alguns deles.

Vamos voltar a nossa lista de compras. Você mudou de ideia quanto a sua sobremesa, não querendo mais o chocolate, mas sim um flan pronto de pote, sobrou VA no final do mês, então dá pra se dar esse luxo :). Então precisamos remover o chocolate e inserir o flan.

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  listadecompras[0].append("Chocolate")

  print(listadecompras[0])

  listadecompras[0].remove("Chocolate")
  listadecompras[0].append("Flan")

  print(listadecompras[0])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Flan']

Agora sim, podemos ver que a alteração foi realizada como você queria.

*[A]* Na sua lista da prática anterior, remova um item e adicione outro utilizando os métodos ~remove~ e ~append~.

E caso você queira saber se já existe algo na lista, seria tedioso consultar toda a lista para conferir. No entanto, existe um método de listas do Python para fazer isto, chamada count. Vamos fazer um exemplo, para conferir se o miojo está na lista:

#+begin_src python
  print(listadecompras[0].count("Miojo"))
#+end_src

#+RESULTS:
: 1

Note que o programa retorna "1", ou seja, ele está lhe dizendo que há o Miojo na lista uma vez. Agora teste buscar por "miojo" utilizando somente letras minúsculas, o que acontece?

Além disso, o programa retornou um número, ou seja, você poderia ter mais que uma ocorrência para o item consultado. Isso signica que podem existir itens duplicados na lista, caso você tivesse adicionado miojo suas vezes, o count retornaria 2.

*[B]* Existem vários métodos de listas no Python, que serão muito úteis na sua vida de programação. Abaixo seguem alguns e suas explicações e algumas perguntas:

+ ~insert~: Adiciona um elemento na posição especificada.\\
	Exemplo: ~listadecompras[0].insert(0, "Banana")~, adiciona Banana na posição zero da lista.\\
	*Pergunta 1:* O que acontece com os outros elementos?

+ ~extend~: Adicionar vários elementos de uma lista no final da sua lista.\\
	Exemplo: ~listadecompras[0].extend(['Pão', 'Queijo', 'Presunto'])~\\
	*Pergunta 2:* Os elementos foram adicionados corretamente? Note que ao invés de adicionar os itens na sintaxe anterior, você poderia adicionar outra lista, definida anteriormente.

+ ~index~: Retorna o índice do primeiro elemento com o valor requisitado.\\
	Exemplo: ~listadecompras[0].index('Ovo')~\\
	*Pergunta 3:* O índice reportado é o que você esperava?

+ ~pop~: Remove o elemento da posição requida.\\
	Exemplo: ~listadecompras[0].pop(5)~\\
	*Pergunta 4:* Qual item foi removido? Foi o esperado?

+ ~sort~: Ordena sua lista de maneira crescente, tanto com números como ordem alfabética. Note que você pode ordenar a lista, mas não a lista dentro da lista.\\

+ ~reverse~: Inverte a ordem de sua lista. Novamente tome cuidado pois este método ordena listas, não listas dentro de listas. Além disso, ele simplesmente reverte a ordem existente, ou seja, ele não coloca em ordem decrescente.\\

*[C]* Com a sua lista de listas, escolha 2 métodos e os aplique a sua lista (fora o ~append~ e ~remove~ que já foram utilizados). Algum método lhe pareceu particularmente útil?

*[Desafio 1]* Como você faria para ordenar alfabeticamente suas duas listas de compras, tendo no final ainda as duas listas dentro de uma lista de listas?

# #+RESULTS:
# : mercado = listadecompras[0]
# : mercado.sort()
# : print(mercado)
# : papelaria = listadecompras[1]
# : papelaria.sort()
# : print(papelaria)
# : listadecompras = []
# : listadecompras.append(mercado)
# : listadecompras.append(papelaria)

*[Desafio 2]* Coloque cada lista de sua lista de listas na ordem contrária a alfabética.

# #+RESULTS:
# : mercado = listadecompras[0]
# : mercado.reverse()
# : print(mercado)
# : papelaria = listadecompras[1]
# : papelaria.reverse()
# : print(papelaria)
# : listadecompras = []
# : listadecompras.append(mercado)
# : listadecompras.append(papelaria)
# : print(listadecompras)

** Particionamento de listas

Já foi apresentado como acessar um item específico da lista anteriormente, com o argumento entre colchetes (~listadecompras[0]~). Porém, podemos particinar as listas, pegando vários elementos de interesse. Novamente utilizaremos índices entre colchetes, com a seguinte sintaxe: lista[Inicial:Final:Passo]. O 'Inicial' é o primeiro elemento da lista que desejamos, 'Final' é o elemento final desejado. Já 'Passo' é o de quantos em quantos elementos queremos, por exemplo, se o passo for 1, todos elementos na faixa específicada são impressos, se o passo for 2, só serão fornecidos elementos a cada dois. Vamos exemplificar para facilitar:

#+begin_src python
  listadecompras = [
      [
          "Queijo Ralado",
          "Queijo",
          "Pão",
          "Pasta de Dentes",
          "Ovo",
          "Miojo",
          "Flan",
          "Banana",
      ],
      [
          "Caderno",
          "Papel",
          "Caneta",
          "Post-it",
      ],
  ]

  print(listadecompras[0][0:6:2])
#+end_src

Porque temos dois colchetes? Porque estamo particionando a primeira lista de nossa lista de listas. No primeiro colchetes ~[0]~, estamos específicando a primeira de nossas duas listas. No segundo colchetes estamos particionando a lista começando do elemento zero até o elemento 6, pulando de dois em dois.

A saída do código anterior é ~['Queijo Ralado', 'Pão', 'Ovo']~, sendo que nossa lista completa é ~['Queijo Ralado', 'Queijo', 'Pão', 'Pasta de Dentes', 'Ovo', 'Miojo', 'Flan', 'Banana']~. Logo foram impressos os elementros 0, 2 e 4. Mas o elemento 6 também não deveria ser exibido? Parece lógico, mas, como o Python começa sua contagem de zero, ao invés de um, sempre que especificamos faixas de valores o elemento final do intervalo não é considerado. Portanto, caso queira o último elemento incluso sempre considere n+1. Façamos isso então:

#+begin_src python
  print(listadecompras[0][0:7:2])
#+end_src

Com este comando o código exibiu ~['Queijo Ralado', 'Pão', 'Ovo', 'Flan']~, incluindo o sexto elemento da lista. Então, tenha isso sempre em mente com o Python, a contagem começa em zero e o último elemento das faixas de valores não é incluído.

Também podemos utilizar índices negativos no particionamento de listas, mas como assim? O que acontece quando usamos índices negativos? Basicamente a contagem é de traz para frente. Então, se pedirmos a seguinte faixa ~[-4,-1]~ para nossa lista de compras do supermercado, o código imprimirá ~['Ovo', 'Miojo', 'Flan']~, sendo esses os elementos -4, -3 e -2, já que o último elemento não vai ser incluído por ser o final do intervalo. Se quisermos também o último elemento e colocarmos o intervalo como ~[-4:0]~ teremos um erro de sintaxe, então, para obter os quatro últimos elementos a sintaxe correta será ~[-4:]~, que irá imprimir do elemento -4 até o último.

*[A]* Utilize o particionamento de lista em uma lista que você criou. Faça para dois passos e duas faixas de valores.

*[B]* Exiba os três últimos elementos de uma lista criada por você (esta deve ter pelo menos 4 elementos).

*[Desafio 1]* Crie uma lista de quatro números e some todos os números da lista, também encontre a média dos quatro números da lista.

*[Desafio 2]* Encontre os valores máximo e mínimo de uma lista de quatro números.

*[Desafio 3]* Crie uma função que recebe duas listas de mesmo tamanho (estas listas devem conter apenas valores numéricos). O programa deve retornar uma lista que é a multiplicação por elementos das listas (isto é, o elemento na posição zero da lista final é a multiplicação dos elementos da posição zero das listas de entrada; o mesmo vale para os elementos das demais posições). Sua função deve conter uma docstring e para esse desafio não é permitido usar funções importadas de outras bibliotecas.

*[Desafio 4]* Crie uma função que recebe um número posinivo $n$ e retorna uma lista com os $n$ primeiros valores da sequência de Fibonacci. Sua função deve conter uma docstring e para esse desafio não é permitido usar funções importadas de outras bibliotecas.

*[Desafio 5]* Crie uma função que recebe uma lista contendo números inteiros. Esta função retorna duas listas: a primeira lista (~lista_retorno_1~) deve conter todos os números da lista original em ordem crescente e sem repetição; a segunda lista deve conter a contagem em que cada número da ~lista_retorno_1~ aparece na lista original recebida pela função. Sua função deve conter uma docstring e para esse desafio não é permitido usar funções importadas de outras bibliotecas.

** Copiando listas

Agora vamos tratar de cópias no Python. Para listas o Python tem uma maneira bastante peculiar para cópias, onde são criados links entre as listas e não simplesmente copiados os objetos. Vamos a um exemplo para deixar mais claro:

#+begin_src python -n
  lista1 = ["Miojo", "Ovo", "Queijo Ralado"]
  lista2 = lista1  # Criamos uma lista2 igual a lista1

  print("Lista 1 Original")
  print(lista1)
  print("Lista 2 Original")
  print(lista2)

  print()

  lista2[2] = "Orégano"  # Altera o elemento 2 da lista2 para Orégano

  print("Lista 2 Alterada")
  print(lista2)  # Exibe a lista2 alterada
  print("Lista 1 depois de alterar lista 2")
  print(lista1)  # Exibe a lista1 após a alteração da lista2
#+end_src

#+RESULTS:
: Lista 1 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
: Lista 2 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
:
: Lista 2 Alterada
: ['Miojo', 'Ovo', 'Orégano']
: Lista 1 depois de alterar lista 2
: ['Miojo', 'Ovo', 'Orégano']

Bom, nesse código definimos uma ~lista1~, criamos uma ~lista2~ igualando a ~lista1~, por fim alteramos a ~lista2~. Como a cópia é criada com links, ou vínculos, a ~lista1~ e a ~lista2~ dependem uma da outra. Em outras palavras: elas estão conectadas! Então, quando a ~lista2~ foi alterada, a ~lista1~ também foi, como vocês podem notar na saída do código. Isso pode ser interessante para alguns casos, porém, na maioria das vezes o desejável é ter dados independentes uns dos outros. Para isso, precisamos utilizar o método ~copy~ de listas. Veja o exemplo abaixo.

#+begin_src python -n
  lista1 = ["Miojo", "Ovo", "Queijo Ralado"]
  lista2 = lista1.copy()  # Usando o método `copy`

  print("Lista 1 Original")
  print(lista1)
  print("Lista 2 Original")
  print(lista2)

  print()

  lista2[2] = "Orégano"  # Altera o elemento 2 da lista2 para Orégano

  print("Lista 2 Alterada")
  print(lista2)  # Exibe a lista2 alterada
  print("Lista 1 depois de alterar lista 2")
  print(lista1)  # Exibe a lista1 após a alteração da lista2
#+end_src

#+RESULTS:
: Lista 1 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
: Lista 2 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
:
: Lista 2 Alterada
: ['Miojo', 'Ovo', 'Orégano']
: Lista 1 depois de alterar lista 2
: ['Miojo', 'Ovo', 'Queijo Ralado']

*[A]* Para uma lista criada por você, mostre os dois casos de cópia, um usando o operador de atribuição (~=~) e outro usando o método ~copy~, lembre de mostrar a diferença quando alteramos uma das listas após a cópia.

** Desempacotamento e Operador Asterisco

No Python podemos utilizar uma notação específica para definir várias variáveis ao mesmo tempo, como segue:

#+begin_src python
  item0, item1, item2 = "Miojo", "Ovo", "Queijo"

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: Queijo

Notem que item0="Miojo", item1="Ovo" e item2="Queijo". Podemos utilizar isso para desempacotar uma lista, por exemplo:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo"]

  item0, item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: Queijo

*[A]* Desempacote uma lista criada por você. Lembre-se de imprimir todos os itens com a função ~print~.

Os itens0, 1 e 2 foram definidos de acordo com os elementos da lista, no código mostrado anteriormente. Caso a lista não tenha a mesma dimensão do número de variáveis que estamos definindo, o que acontece?

*[B]* Para averiguar, utilize o código a seguir, comente sobre o que aconteceu.

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]

  item0, item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:

Para lidar com este tipo de situação podemos utilizar o operador asterisco (também conhecido como operador estrela), que pegará os elementos restantes e atribuirá a variável indicada, por exemplo:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]

  item0, item1, *resto = lista

  print(item0)
  print(item1)
  print(resto)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: ['Queijo', 'Pão', 'Orégano']

Agora nosso comando funciona! Tivemos então o item0="Miojo", item1="Ovo" e resto=['Queijo', 'Pão', 'Orégano'].

A posição do operador asterisco não precisa ser necessáriamente na última variável, ela pode ficar na primeira, ou na do meio, por exemplo:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]

  item0, *item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)

  print()

  *item0, item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:
: Miojo
: ['Ovo', 'Queijo', 'Pão']
: Orégano
:
: ['Miojo', 'Ovo', 'Queijo']
: Pão
: Orégano

*[C]* Como se comportou o código acima de acordo com onde ficou o asterisco?

** Tuplas

Existe outro tipo de dados no Python que são chamadas tuplas. As tuplas são basicamente listas imutáveis. Como assim imutáveis? Isso significa que uma vez que ela foi definida, não podemos mais adicionar ou remover elementos, bem como não é possível modificar sua ordem. Então, voltando ao nosso exemplo do supermercado, se você quiser estabelecer uma lista perpétua de itens a serem comprados (que jamais serão alterados), você pode colocá-los em uma tupla. Vamos a um exemplo:

#+begin_src python
  itensrecorrentes = ("Miojo", "Ovo", "Queijo Ralado")
  print(itensrecorrentes)
#+end_src

#+RESULTS:
: ('Miojo', 'Ovo', 'Queijo Ralado')

Então, agora esta tupla será composta sempre por estes itens, não podendo modificá-los ou alterar sua ordem. Por conta disso as tuplas só tem dois métodos possíveis, o ~count~ e o ~index~, que tem a mesma função que nas listas, que é contar quantos itens existem na tupla e qual o índice do objeto requisitado.

*[A]* Qual a diferença na sintaxe para a declaração de tuplas, comparando com a de listas? Seja atento, pois pequenos detalhes fazem muita diferença do Python.

O interessante é que podemos utilizar o método ~extend~ com uma tupla como argumento. Veja que, neste caso, quem está sendo alterado é a lista, não a tupla. A tupla seria apenas a fonte de informação com a qual vamos atualizar a lista. Vamos ver um exemplo:

#+begin_src python -n
  itensrecorrentes = ("Miojo", "Ovo", "Queijo Ralado")

  listadecompras = []
  listadecompras.extend(itensrecorrentes)

  print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Ovo', 'Queijo Ralado']

Na linha 3 inicializamos uma lista vazia, apenas para criá-la, para poder utilizar o método ~extend~ nela na linha 4. Podemos ver que agora temos uma lista criada a partir da tupla, então podemos voltar a adicionar os itens de interesse.

*[B]* Crie uma tupla com itens de seu interesse. Após isso, construa uma lista a partir dessa tupla.

** Conjuntos

Outro objeto de Python são os conjuntos, que são basicamente listas sem elementos repetidos. Os conjuntos possuem seus métodos específicos também, que englobam métodos equivalentes aos das listas, como: ~remove~ e ~pop~. Mas especificamente para conjuntos, temos operações matemáticas já conhecidas, como união e intersecção. Vamos definir dois conjuntos e operá-los, com nossa analogia de listas de compras, vamos pensar que você fez anotações para compras em dois lugares diferentes e agora você quer juntá-las.

#+begin_src python
  conjunto1 = {"Miojo", "Ovo", "Queijo"}
  conjunto2 = {"Miojo", "Pão", "Queijo", "Orégano", "Pão"}

  print(conjunto1)
  print(conjunto2)
#+end_src

#+RESULTS:
: {'Ovo', 'Miojo', 'Queijo'}
: {'Miojo', 'Pão', 'Queijo', 'Orégano'}

*[A]* Qual a diferença na sintaxe para a declaração de conjuntos, tuplas e listas?

*[B]* Quando você imprimiu o ~conjunto2~, quantas vezes apareceu "Pão"? Quantas vezes ele estava na declaração? Porque desta diferença? Pode usar a internet para descobrir, mas lembre-se de citar suas fontes!

Agora vamos realizar algumas operações com os conjuntos:

#+begin_src python
  conjunto1 = {"Miojo", "Ovo", "Queijo"}
  conjunto2 = {"Miojo", "Pão", "Queijo", "Orégano", "Pão"}

  intersection = conjunto1.intersection(conjunto2)
  print(intersection)

  union = conjunto1.union(conjunto2)
  print(union)
#+end_src

#+RESULTS:
: {'Miojo', 'Queijo'}
: {'Orégano', 'Miojo', 'Ovo', 'Queijo', 'Pão'}

*[C]* Os resultados estão de acordo com o que você esperava?

Além desses métodos temos outros exclusivos de conjuntos, como segue:

+ ~add~: Adiciona um elemento ao conjunto. Sintaxe: conjunto.add("Presunto")
+ ~difference~: Faz a subtração de dois conjuntos. Sintaxe: ~difference = conjunto1.difference(conjunto2)~
+ ~discard~: Remove o elemento especificado do conjunto. Parece igual ao remove, mas, neste caso você não terá uma mensagem de erro caso o elemento não exista no conjunto. Sintaxe: ~conjunto.discard("Banana")~
+ ~update~: Com este método você pode incluir um iterável no conjunto, que pode ser outro conjunto, lista, tupla, ...

*[D]* Crie três conjuntos com itens de seu interesse. Realize operações de adição, diferença, interseção e união com eles.

* Laço de repetição
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_laco
:EXPORT_OPTIONS: toc:t
:ID:       25e5272b-ad01-463a-815a-7b4345a4b35a
:END:

#+begin_quote
"/Once you free your mind about a concept of
Harmony and of music being correct
You can do whatever you want
So nobody told me what to do
And there was no preconception of what to do/" --- Giovanni Giorgio
#+end_quote

Laços de repetição, ou seu termo mais comum em inglês o /loop/, serve para iterar elementos de listas, tuplas, conjuntos ou geradores. Existem diferentes maneiras de implementar loops, sendo as principais do Python o =while= e o =for=, que mostraremos pra vocês a seguir.

** Laço de repetição usando =while=
#+begin_quote
"/Do it while yo can/" --- Billy Preston
#+end_quote

Vamos iniciar com um =while= loop, ou laço de repetição com =while=. A tradução da palavra =while= do inglês é enquanto, então a ideia deste loop é fazer algo enquanto uma condição for verdadeira. Vamos começar com um exemplo simples, onde o loop será executado enquanto a variável =i= for menor que 10, e vamos somando 1 a mesma variável a cada iteração. Para isso usamos um operador que não foi apresentado ainda, o ~+=~, que basicamente soma o valor ou variável indicado após ele, por exemplo, i += 1 é o mesmo que i = i + 1.

*[A]* Execute o código abaixo no seu Jupyter Notebook, descreva o que ocorreu com o código.

#+begin_src python
  i = 0
  while i < 10:  # Leia como "Enquanto o valor de i for menor que 10, faça:"
      print(i)
      i += 1  # mesma coisa que escrever `i = i + 1`
#+end_src

#+RESULTS:
#+begin_example
0
1
2
3
4
5
6
7
8
9
#+end_example

Fique atento a identação! Assim como no caso dos condicionais (=if=) você precisa colocar o bloco executado pelo ~while~ em um código indentado, pois esta é a maneira do Python entender o que pertence e o que não pertence ao bloco do ~while~. Note que estamos utilizando os operadores de comparação, que vocês já foram apresentados em uma aula anterior. Eles são fundamenteis para a implementação de loops while, pois quando a condição retornar =False=, o loop irá parar. Na execução do código vocês podem notar que os números de 0 à 9 foram impressos, quando =i= ficou igual a 10 o loop parou, pois a sentença =i < 10= passou a ser =False=. Você pode confirmar isso alterando seu código para o seguinte:

*[B]* Execute o código abaixo no seu Jupyter Notebook. O que aconteceu agora? Quais são o significado dos dois print executados?

#+begin_src python
  i = 0
  while i < 10:
      print(i, i < 10)
      i += 1
  print(i, i < 10)
#+end_src

#+RESULTS:
#+begin_example
0 True
1 True
2 True
3 True
4 True
5 True
6 True
7 True
8 True
9 True
10 False
#+end_example

#+BEGIN_COMMENT
Com isso, estamos imprimindo a variável =i= e o valor booleano da operação =i < 10=. Ao final do loop há mais uma operação de print, para mostrar que quando =i = 10= a operação =i < 10= retorna =False=.
#+END_COMMENT

*IMPORTANTE*

O uso de loops pode facilmente levar o seu código a loops infinitos! Sempre avalie com cuidado a condição a ser adotada em seu loop, vamos a um exemplo de loop infinito:

#+begin_src python
  i = 0
  while i < 10:
      print(i, i < 10)
#+end_src

*Caso tenha executado, precisará desligar (shut down) seu kernel, pois o código não irá parar nunca!*

Neste caso, foi esquecido o incrementador de =i= (+=), logo o valor de =i= nunca será alterado! Isso levará o código a rodar indefinidamente, sem nunca parar, teste para você conferir. Esse é um dos erros mais catastróficos em códigos, pois o programa simplesmente executa operações sem parar, muitas vezes utilizando todos os recursos computacionais disponíveis e inutilizando a máquina. Neste caso a única alternativa é terminar o programa forçosamente, ou em alguns casos só reiniciando o computador.

Também temos outra maneira de sair ou continuar em loops, usando os comandos =break= ou =continue=. Basicamente, ao se dar o comando =break=, a execução do loop é interrompida e nós saímos do bloco de execução do loop. Use o ~break~ sempre que quiser "pular fora" do loop. O comando ~continue~ é diferente, ele interrompe a execução natural do loop e retorna para o início do loop onde a condição é checada (a linha do ~while~). Ambas estruturas de controle são bastante úteis. Veja um exemplo onde usamos ~break~ abaixo.

#+begin_src python -n
  def maximo_divisor_comum(a):
      """Calcula o máximo divisor comum e, caso exista, exibe ao usuário.

      Args:
        a:
          Número que desejamos saber o divisor.
      """

      # Definimos i como a-1, pois se começarmos a testar o divisor como o
      # próprio a, teríamos uma solução trivial
      i = a - 1

      while i > 0:  # Vamos iterar de a-1 até 1
          b = a / i

          # Caso a divisão tenha a parte decimal igual a zero
          if b - int(b) == 0:
              print(a, "é divisível por", i)
              break  # Com este break o programa sai do loop

          # Caso a divisão não tenha a parte decimal igual a zero
          else:
              i -= 1  # Diminuímos 1 do i


  maximo_divisor_comum(8733)  # teste
#+end_src

#+RESULTS:
: 8733 é divisível por 2911

*[C]* Modifique o código acima, para utilizar o operador resto ~%~, isso simplificará o código.

O código apresentado está comentado e a função tem uma docstring, lembrem-se sempre de comentar seus códigos e adicionar docstrings às suas funções! Do contrário, niguém além de você o entenderá e depois de algum tempo, nem você mesmo entenderá. Basicamente o código encontra o maior divisor para um número fornecido, testando todos os números menores que ele mesmo até que alguma das divisões tenha componente decimal zero.

*[D]* Modifique o código acima para avisar quando números primos são encontrados.

#+BEGIN_COMMENT
#+RESULTS:
#: a = 17
#: i = a-1
#: while i > 1:
#:     print(i)
#:     b = a/i
#:     print(b,b - int(b))
#:     if (b - int(b)) == 0:
#:         print(a, 'é divisível por', i)
#:         break
#:     else:
#:         i -= 1
#:         continue
#: if (i == 1):
#:     print(a,'é primo!')
#+END_COMMENT

*[Desafio]* Como você faria um código para achar o máximo divisor comum de dois números?

#+BEGIN_COMMENT
#+RESULTS:
#: a = 30
#: b = 20
#:
#: if a > b:
#:     i = b - 1
#: else:
#:     i = a - 1
#: while a > 1:
#:     print(i)
#:     div1 = a/i
#:     div2 = b/i
#:     if ((div1 - int(div1)) == 0) and ((div2 - int(div2)) == 0):
#:         print('O MDC entre', a, 'e', b, 'é', i)
#:         break
#:     else:
#:         i -= 1
#:         continue
#+END_COMMENT

** Laço de repetição usando =for=

#+begin_quote
"/Loop de loop flip flop Santa's got an airplane/" --- Santa's Got an Airplane - The Beach Boys
#+end_quote

A outra maneira de implementarmos loops no Python é utilizando o =for=. Mas antes de entrarmos em seus detalhes, é importante mostrar outra ferramenta do Python, o operador =in=. Com ele podemos checar se um elemento está em uma lista, ou qualquer outro objeto iterável. No exemplo abaixo mostramos sua sintaxe:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo"]
  print("Ovo" in lista)
  print("Pão" in lista)
#+end_src

#+RESULTS:
: True
: False

Veja que para o objeto ~"Ovo"~ o código retornou =True=, já para ~"Pão"~​, o código retornou ~False~. Ou seja, ele confirmou que há ~"Ovo"~ na lista e que não há pão.

Para implementarmos um loop com ~for~, iremos utilizar a seguinte sintaxe: =for item in lista=, desta maneira a variável item assumirá os valores dos objetos presentes na lista, um a um, em ordem.

*[A]* Execute o código abaixo e descreva o que observou.

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
  for item in lista:
      print(item)
#+end_src

#+BEGIN_COMMENT
Note que a cada iteração o código imprime a variável item, que assume os valores da lista do primeiro ao último.
#+END_COMMENT

Dentro do bloco do ~for~ podemos usar condicionais ou manipular de várias maneiras as variáveis. Por exemplo, você quer que quando houver pão na sua lista de compras, seja automáticamente incluídos queijo, presunto e manteiga.

*[B]* Crie um operador condicional no seu loop ~for~, que confere se um dos itens da lista é pão, caso seja então avise o usuário que ele deve comprar os ingredientes necessários para fazer um lanche.

#+BEGIN_COMMENT
#+begin_src python
#lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
#for item in lista:
#        print(item)
#        if item == "Pão":
#                lista.append["Queijo", "Presunto", "Manteiga"]
#print(lista)
#+end_src
#+END_COMMENT

Existe uma regra de ouro sempre que usar um loop com ~for~: *nunca altere o objeto que você está iterando*! Isto é, caso você esteja iterando no objeto ~lista~, não deve usar métodos que adicionem, removam ou ordenem os itens o objeto ~lista~ dentro do bloco do ~for~. Caso precise, crie uma lista nova ou uma cópia da lista sendo iterada para realizar suas alterações. Veja o exemplo abaixo.

#+begin_src python -n
  lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
  lista_copia = lista.copy()  # criando uma cópia de `lista`

  for item in lista:  # `lista` é o objeto sendo iterado
      print(item)
      if item == "Ovo":
          lista_copia.append("Bacon")  # alterando a `lista_copia`, não `lista`

  print(lista)
  print()
  print(lista_copia)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: Queijo
: Orégano
: Pão
: ['Miojo', 'Ovo', 'Queijo', 'Orégano', 'Pão']
:
: ['Miojo', 'Ovo', 'Queijo', 'Orégano', 'Pão', 'Bacon']

*[C]* Faça um código que adicione o queijo, presunto e manteiga à uma lista caso ela tenha pão. Certifique-se que sua lista final nunca terá itens duplicados (isto é, se já tinha queijo na lista original, então não teremos dois itens queijo na lista final).

#+BEGIN_COMMENT
#+RESULTS:
#: set1 = {"Miojo", "Ovo", "Queijo", "Orégano", "Pão"}
#: set2 = copy.deepcopy(set1)
#: for item in set1:
#:         print(item)
#:         if item == "Pão":
#:                 set2.update({"Queijo", "Presunto", "Manteiga"})
#: print(set2)
#:
#: lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
#: for item in lista:
#:         print(item)
#:         if item == "Pão":
#:             if lista.count("Queijo") == 0:
#:                 lista.append("Queijo")
#:             if lista.count("Presunto") == 0:
#:                 lista.append("Presunto")
#:             if lista.count("Manteiga") == 0:
#:                 lista.append("Manteiga")
#: print(lista)
#+END_COMMENT

Além de iterar em listas, o =for= loop pode ser utilizado em faixas de números, para isso devemos utilizar o operador =range=. Por exemplo, se quisermos iterar os números de 0 à 10, podemos fazer o seguinte:

#+begin_src python
  for number in range(0, 11):
      print(number)
#+end_src

#+RESULTS:
#+begin_example
0
1
2
3
4
5
6
7
8
9
10
#+end_example

A saída do código lhe dará os números de 0 a 10, um em cada linha. Mas note que a faixa que colocamos é de 0 a 11. Novamente o fato do Python começar a contar do zero leva ao intervalo aberto no final da faixa, como discutido anteriormente. Então, tenha sempre em mente isso para não perder o último número da sua faixa.

Também podemos definir o passo a ser utilizado, como fizemos no particionamento de listas. O padrão é iterar de um em um, mas podemos mudar isso, veja o exemplo abaixo:

#+begin_src python
  for number in range(0, 11, 2):
      print(number)
#+end_src

#+RESULTS:
: 0
: 2
: 4
: 6
: 8
: 10

O código acima exibe os números 0, 2, 4, 6, 8 e 10. Ou seja, o passo mudou para 2. Também podemos utilizar um passo negativo, colocando a faixa como (0,11,-1) será impressa a ordem decrescente. Isso é bastante útil em um caso bem simples, o cálculo de fatoriais.

*[D]* Com a dica do passo negativo, escreva um código para calcular o fatorial de um número inteiro qualquer. Dica: utilize no máximo números de dois dígitos, se não o resultado ficará monstruosamente grande!

#+BEGIN_COMMENT
#+begin_src python
#fatorial = 1			#Definimos um valor inicial para o fatorial
#for number in range(4,1,-1):	#Iteramos de 4 à 2, com passo de -1
#    print(number)		#Imprime o número da iteração
#    fatorial = fatorial*number  #Multiplicamos a variável fatorial pelo número sendo iterado
#print(fatorial)			#Imprime o resultado do fatorial
#+end_src

#O código é simples mas tem alguns conceitos novos nele. Já na primeira linha definimos a variável =fatorial = 1=, porque isso, já que a utilizaremos no loop? Comente a primeira linha e confira o que acontece. Outro ponto é que iteramos de 4 a 2 e não de 4 a 1, o fatorial é definido por =4! = 4*3*2*1=, porém, qualquer número multiplicado por 1 é ele mesmo, logo não faz diferença multiplicarmos por 1, já que o resultado não é alterado. Assim, evitando uma multiplicação economizamos tempo computacional, pode parecer pouca coisa, mas, várias dessas otimizações em um código grande podem levar a ganhos significativos de performance.
#+END_COMMENT

*[E]* Refaça o código para encontrar números primos, agora utilizando o =for= loop.

#+BEGIN_COMMENT
#+RESULTS:
#: a = 17
#: for i in range(a-1,0,-1):
#:     c = a % i
#:     if c == 0 and i != 1:
#:         print(a, 'é divisível por', i)
#:         break
#:     elif i == 1:
#:         print(a, 'é primo')
#:     else:
#:         print(a, 'não é divisível por', i)
#+END_COMMENT

** Laços Aninhados

#+begin_quote
"/That Many Dreams Within Dreams Is Too Unstable/" --- Yusuf - Inception
#+end_quote

Além de utilizarmos laços (loops) aliados a condicionais, também podemos ter loops dentro de loops. Vamos voltar a nossas listas de compras, agora precisamos checar o que temos na lista da padaria e do supermercado, para ver se não temos nada repetido, vamos ao exemplo:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo", "Ovo", "Pasta de Dentes", "Chocolate"],
      ["Pão", "Queijo", "Presunto", "Sonho"],
  ]

  print("Lista do supermercado antes da conferência:", listadecompras[0])
  print("Lista da padaria antes da conferência:", listadecompras[1])

  # cópia para não alterar o original dentro do loop (regra de ouro!)
  lista_copia = listadecompras.copy()

  for item1 in listadecompras[0]:  # Loop nos itens do supermercado
      for item2 in listadecompras[1]:  # Loop nos itens da padaria
          if item1 == item2:  # Checa se os itens são iguais

              # Se forem iguais, são removidos da lista do supermercado
              lista_copia[0].remove(item1)

  listadecompras = lista_copia  # atualizando a lista original

  print("Lista do supermercado após a conferência:", listadecompras[0])
  print("Lista da padaria após a conferência:", listadecompras[1])
#+end_src

#+RESULTS:
: Lista do supermercado antes da conferência: ['Miojo', 'Queijo', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: Lista da padaria antes da conferência: ['Pão', 'Queijo', 'Presunto', 'Sonho']
: Lista do supermercado após a conferência: ['Miojo', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: Lista da padaria após a conferência: ['Pão', 'Queijo', 'Presunto', 'Sonho']

Note que o ="Queijo"= foi removido da lista do supermercado, que era o único item repetido neste caso.

*[A]* Agora crie mais uma lista, que corresponderia a itens que você já tem no armário de casa. Escreva um código para averiguar se há itens repetidos na lista do supermercado e da padaria, como antes, mas que também confira se há itens repetidos na lista de itens do armário.

*[Desafio]* Escreva uma função para encontrar todos números primos dentro de um intervalo de números inteiros.

*BONUS* Testaremos esses códigos, o mais rápido ganhará um bonus na nota! Os códigos elegíveis são os que estiverem devidamente comentados e a função deve ter uma docstring completa em múltiplas linhas.

#+BEGIN_COMMENT
#+RESULTS:
#: start = 1
#: end = 1000
#:
#: listadeprimos = set()
#: listadenaoprimos = set()
#: for i in range(start,end+1):
#:         notprime = 0
#:         for j in range(start+1,int(end/2)):
#:                 if i % j == 0 and i != j:
#:                         notprime = 1
#:                         listadenaoprimos.add(i)
#:                         print(i, 'é divisível por', j)
#:                         break
#:         if notprime == 0:
#:                 listadeprimos.add(i)
#:                 print(i, 'é primo')
#:
#: print(sorted(listadenaoprimos), 'não são primos')
#: print(sorted(listadeprimos), 'são primos')
#+END_COMMENT

** Compreensão de listas

#+begin_quote
"/Wise it is to comprehend the whole. - Edward Young/" --- Yusuf - Inception
#+end_quote

Esta ferramenta serve para criarmos novas listas a partir de uma lista existente. Isso pode ser feito com loops por exemplo, mas existe uma forma mais compacta. Vamos primeiro fazer da forma que vocês já foram apresentados:

#+begin_src python -n
  listadecompras = [
      "Miojo",
      "Ovo",
      "Queijo",
      "Presunto",
      "Pão",
      "Orégano",
      "Papel Higiênico",
  ]

  listadapadaria = []

  for item in listadecompras:
      if item == "Pão" or item == "Queijo" or item == "Presunto":
          listadapadaria.append(item)

  print(listadapadaria)
#+end_src

#+RESULTS:
: ['Queijo', 'Presunto', 'Pão']

No código acima definimos a =listadecompras=, mas separamos alguns itens em uma =listadapadaria=, com os itens do misto quente. Foi feito um loop nos itens =listadecompras= e um condicional para os itens do misto quente. Notem que é possível utilizar vários condicionais juntos, o que é bastante útil. No final a =listadapadaria= está com os itens desejados. Outra maneira que pode reduzir o código significativamente é o uso da compreensão de listas. Veja o exemplo no código abaixo:

#+begin_src python
  listadecompras = [
      "Miojo",
      "Ovo",
      "Queijo",
      "Presunto",
      "Pão",
      "Orégano",
      "Papel Higiênico",
  ]

  listadapadaria = [
      item
      for item in listadecompras
      if "Pão" in item or "Queijo" in item or "Presunto" in item
  ]

  print(listadapadaria)
#+end_src

#+RESULTS:
: ['Queijo', 'Presunto', 'Pão']

Temos o mesmo resultado do loop ~for~, com um código de três linhas, frente ao de seis linhas com o loop. A economia de linhas vem aliada a uma sintaxe um pouco complicada, que merece bastante atenção. Basicamente ela consiste no seguinte: novalista = [espressão =for= item =in= iterável =if= condição verdadeira], a =expressão= para ser qualquer coisa, no exemplo anterior utilizamos o próprio =item= na expressão, sem nenhum operador, mas entraremos em mais detalhes em breve. O =item= é o que será analizada a =condição= e aplicada a =expressão=, já o =iterável= pode ser uma lista, tupla, conjunto, entre outros. Vamos a um exemplo onde aplicamos uma expressão:

#+begin_src python -n
  quadradosimpares = [
      numero ** 2
      for numero in range(10)
      if numero % 2 != 0
  ]

  print(quadradosimpares)
#+end_src

#+RESULTS:
: [1, 9, 25, 49, 81]

No exemplo acima a =expressão= é =numero**2=, ou seja tiramos o quadrado do =item= da compreensão. O iterável é a faixa de números de 0 a 9. Já a condição é que o resto da divisão entre o =item= (numero) e 2 seja diferente de zero, que será verdade para os números ímpares. Então a lista =quadradosimpares= terá o quadrado de todos os números ímpares na faixa escolhida.

Veja que não é necessário pular linhas dentro da sua compreensão de listas, o código abaixo funciona de forma idêntica ao anterior. Aqui nós pulamos as linhas apenas para deixar claro as diferentes partes da sintaxe.

#+begin_src python
  quadradosimpares = [numero ** 2 for numero in range(10) if numero % 2 != 0]
  print(quadradosimpares)
#+end_src

#+RESULTS:
: [1, 9, 25, 49, 81]

*[A]* Agora faça o seguinte, delete a condição (if numero % 2 != 0) e execute o código, o que acontece?

Mas porque utilizar esta sintaxe de compreensão de listas e não continuar utilizando loops? Os programadores são tão preguiçosos que querem fazer tudo em uma linha? Na verdade a maior vantagem da compreensão de listas é a performance. Vamos fazer uma rápida comparação para dar uma ideia, com o código abaixo, que calcula quais são os divisores de um número arbitrário.

# #+begin_src python -n
#   def divisores_for(numero):
#       '''Calcula os divisores de um numero usando loop for.'''
#       divisores = []
#       for i in range(1, numero):
#           if numero % i == 0:
#               divisores.append(i)
#       return divisores


#   def divisores_cl(numero):
#       '''Calcula os divisores de um numero usando compreensão de listas.'''
#       divisores = [i for i in range(1, numero) if numero % i == 0]
#       return divisores

#   numero = 1000001
#   %timeit divisores_for(numero)
#   %timeit divisores_cl(numero)
# #+end_src

#+begin_src python
  import time  # Importando a biblioteca que irá cronometrar nosso código.
  a = 1000001  # Definimos um número qualquer


  start = time.time()  # Setando o tempo inicial
  # Método de compreenssão de listas para calcular os divisores
  divisor = [i for i in range(1, a) if a % i == 0]
  print(divisor)  # Imprime os divisores
  # Imprime o tempo que o código levou para executar
  print("--- Comprehenssion %s seconds ---" % (time.time() - start))


  start = time.time()  # Setando novamente o tempo inicial
  divisor = []  # Inicializando a lista dos divisores
  for i in range(1, a):  # Início do loop
      if a % i == 0:  # Testa o resto da divisão
          divisor.append(i)  # Acrescenta como divisor se o resto é zero

  print(divisor)  # Imprime os divisores
  # Imprime o tempo de execução
  print("--- Loop %s seconds ---" % (time.time() - start))
#+end_src

#+RESULTS:
: [1, 101, 9901]
: --- Comprehenssion 0.03325843811035156 seconds ---
: [1, 101, 9901]
: --- Loop 0.042826175689697266 seconds ---

No código apresentado calculamos todos divisores do número =a=, execute este código, você verá que os tempos de execução são mais rápidos para o método de compreenssão de listas. Mas poxa, um executou em 0.04 segundos e o outro em 0.05 segundos, não é muita diferença. Pois bem, aumente três zeros no =a= e compare novamente, agora temos a compreenssão de listas executando em 45 segundos e o loop em 60 segundos. Quanto maior o seu número, mais importante será essa diferença. Isso pode ser crucial em muitos casos, pois imagine que você queira fazer uma previsão do tempo para amanhã, mas seu código demora 48 horas para rodar e sua previsão fica pronta depois do dia ter passado? Esse e muitos outros casos tem a performance como algo crítico, tornando a aplicação útil ou não.

Maravilha, conseguimos ganhar um pouco de performance, mas, o código apresentado está fazendo várias operações inúteis. Como assim? Bom, vamos pensar nos divisores de um número, eles certamente não serão maiores que a metade do mesmo, mas estamos tentando dividir por esses números maiores que a metade. Ajuste seu código para dividir só até a metade de =a= e veja a diferença na performance. A diferença é grande não? Se compararmos o loop dividindo por todos os números com a compreenssão de listas dividindo até a metade de =a=, o código leva quase um terço do tempo para executar. Se fosse uma previsão do tempo que levava 48 horas, agora ela levaria pouco mais de 16 horas, ficando pronta antes do próximo dia começar, se tornando útil. Logo parar para pensar na matemática ou lógica do problema ajuda muito na otimização, ainda mais aliado as técnicas computacionais adequadas.

*[Desafio]* Tente otimizar mais a performance do código anterior!

** Compreensão de listas aninhadas :noexport:

Assim como laços, também podemos aninhar compreensão de listas. Neste caso a sintaxe pode ficar bastante complicada, então é interessante ilustrarmos

[[./img/nested-list-comprehension.png]]
* Importando bibliotecas e lendo dados
** Bibliotecas nos ajudam a não ter que reinventar a roda

#+begin_quote
"/Se eu vi mais longe é pois estava sobre os ombros de gigantes./" --- Isaac Newton
#+end_quote

Diversas grandezas científicas variam ordens de magnitude, como por exemplo a viscosidade e a condutividade eletrônica. Uma forma de nos ajudar a tratar essas grandezas é pensar em escala logarítmica e não na escala linear.

Calcular o logaritmo de um valor é uma tarefa corriqueira no meio científico. Era de se imaginar que o Python teria uma função para computar o log de um número, não é? Dê uma olhada na [[https://docs.python.org/pt-br/3/library/functions.html][documentação oficial]] e verá que não existe nenhuma função embutida de Python que computa o log de um número...

E agora? Teremos que programar nossa própria função que calcula o log toda vez que precisarmos tirar o logaritmo de um valor? Para esse caso específico (e diversos outros), a resposta é /não/. Mesmo não sendo uma função embutida em Python, podemos obter uma função que calcula o log usando bibliotecas! Veja o exemplo abaixo.

#+begin_src python -n
  import math

  valor = 100000000000000000
  print(math.log10(valor))

  print()
  help(math.log10)
#+end_src

#+RESULTS:
: 17.0
:
: Help on built-in function log10 in module math:
:
: log10(x, /)
:     Return the base 10 logarithm of x.
:

No código acima temos a importantíssima instrução ~import~ na primeira linha. Essa instrução é usada para importar os módulos das bibliotecas que temos instaladas no nosso computador. O módulo importado foi o módulo ~math~ que, como o próprio nome sugere, contém objetos relacionados com matemática. O módulo ~math~ faz parte do que chamamos de /biblioteca padrão/ do Python, que é um conjunto de diversos módulos que já vem instalados quando se instala o Python.

Na linha 4 do código acima usamos a função ~math.log10~ para calcular o logaritmo na base 10 da variável ~valor~. Quando um módulo é importando, seus objetos podem ser acessados usando essa notação "[nome do módulo].[nome do objeto]". Imagina o tempo que você iria gastar se tivesse que escrever uma função que calcula o logaritmo de um número toda vez que precisasse... seríamos muito improdutivos se esse fosse o caso!

Finalmente, na linha 7 do código nós usamos a função ~help~ para checar como a função ~math.log10~ funciona (o que é sempre uma boa prática caso você não saiba como uma função específica funciona).

*[A]* Vamos investigar o que o módulo ~math~ tem! Rode o código abaixo e verá todos os objetos contidos no módulo ~math~ (veja que é a função ~dir~ que está listando esses objetos para nós). Leia o nome de todos os objetos e escolha 3 que achar interessante para saber mais (ignore os objetos que começam com sublinhado "_"). Antes de mais nada, identifique o tipo do objeto que escolheu com a função ~type~. Se seu objeto for uma função, rode o comando ~help~ para saber mais da função. Se seu objeto for uma variável, dê um ~print~ nela para saber seu valor. Comente brevemente sobre possíveis aplicações científicas dos objetos que escolheu.

#+begin_src python -n
  import math

  print(dir(math))
#+end_src

#+RESULTS:
: ['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc', 'ulp']

*[B]* Usando a biblioteca ~math~, faça o Python checar se $\mathrm{sen}^2(x) + \cos{}^2(x) = 1$ para 5 valores diferentes de $x$ a sua escolha. Comente caso encontre algo estranho.

# #+begin_src python
#   import math

#   for a in range(5):
#       print(math.sin(a)**2 + math.cos(a)**2)
# #+end_src

*[Desafio]* Você já se perguntou o que seria o fatorial de um número não-inteiro? Se sim, então você está se sentindo como Daniel Bernoulli se sentiu há quase 300 anos. A função Gama ($\Gamma$) é o que chamamos de extensão da função fatorial e ela funciona para números não-inteiros! Sabendo que $\Gamma(n+1) = n!$, qual seria o fatorial de $\pi$? Use o módulo ~math~ para este cálculo. _Dica_: a letra grega gama em inglês se escreve /gamma/, com dois "m".

# #+begin_src python
#   import math
#   print(math.gamma(math.pi+1))
# #+end_src

# #+RESULTS:
# : 7.188082728976031

** Espaço de nome

#+begin_quote
"/Se você esquecer completamente seu nome, você nunca encontrará seu caminho para casa./" --- Haku, A Viagem de Chihiro
#+end_quote

Quando importamos módulos nós criamos o que chamamos de ~namespace~, ou "espaço de nome" em português. Foi isso que aconteceu com o módulo ~math~: importamos ele e para usar seus objetos precisamos escrever "~math.nome_do_objeto~". Neste caso, ~math~ é o ~namespace~ que guarda todas as informações do nosso módulo.

Vamos fazer uma importação diferente agora, veja no exemplo abaixo.

#+begin_src python -n
  import random as rd

  print(dir(rd))
#+end_src

#+RESULTS:
: ['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random', 'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_ONE', '_Sequence', '_Set', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_accumulate', '_acos', '_bisect', '_ceil', '_cos', '_e', '_exp', '_floor', '_index', '_inst', '_isfinite', '_log', '_os', '_pi', '_random', '_repeat', '_sha512', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn', 'betavariate', 'choice', 'choices', 'expovariate', 'gammavariate', 'gauss', 'getrandbits', 'getstate', 'lognormvariate', 'normalvariate', 'paretovariate', 'randbytes', 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', 'uniform', 'vonmisesvariate', 'weibullvariate']

Na linha 1 temos novamente a instrução ~import~. Estamos importando o módulo ~random~ que é outro módulo da biblioteca padrão do Python e serve para gerar números aleatórios[fn:: Na verdade, são números pseudoaleatórios. Não é possível gerar números perfeitamente aleatórios utilizando apenas instruções determinísticas dos processadores atuais que temos.]. Veja que tem algo a mais nessa linha! Nós demos um apelido para o ~namespace~ do módulo ~random~. Apelidamos ele carinhosamente de ~rd~. A instrução para dar apelido para módulos é o ~as~, assim como mostra o exemplo.

*[A]* Aproveitando que comentamos sobre o módulo ~random~, importe ele dando o apelido que quiser e cheque com a função ~help~ o que as funções ~choice~ e ~randint~ fazem. Teste a função ~choice~ fornecendo uma lista com 5 itens como argumento para ver o que acontece. Teste a função ~randint~ fornecendo dois valores inteiros como argumento.

# #+begin_src python
#   import random as rd

#   print(help(rd.choice))
#   print()
#   print(help(rd.randint))

#   print(rd.choice([1,2,3,4]))
#   print(rd.randint(0,10))
# #+end_src

# #+RESULTS:
# #+begin_example
# Help on method choice in module random:

# choice(seq) method of random.Random instance
#     Choose a random element from a non-empty sequence.

# None

# Help on method randint in module random:

# randint(a, b) method of random.Random instance
#     Return random integer in range [a, b], including both end points.

# None
# 4
# 5
# #+end_example

*[Desafio]* Faça um programa que sorteia um valor aleatório entre 0 e 100. O programa pede que o usuário tente adivinhar o número (use o comando ~input~ para receber uma informação do usuário). Para cada palpite do usuário existem três possibilidades:

1) O palpite estava certo! O programa diz isso ao usuário, conta quantas tentativas ele usou e encerra sua operação.
2) O palpite é menor que o valor sorteado. O programa diz "Seu palpite é menor que o valor que eu sorteei, tente novamente!" e pede outro palpite.
3) O palpite é maior que o valor sorteado. O programa diz "Seu palpite é maior que o valor que eu sorteei, tente novamente!" e pede outro palpite.

*[Desafio matemático]* Qual estratégia você deve seguir para ganhar no jogo anterior usando a menor quantidade de palpites?

** Importando apenas o necessário

#+begin_verse
Eu uso o necessário
Somente o necessário
O extraordinário é demais
Eu digo necessário
Somente o necessário
Por isso é que essa vida eu vivo em paz
     --- Balu, Mogli - O Menino Lobo
#+end_verse

Digamos que você queira calcular o logaritmo natural de um número e não precisa usar mais nenhum outro objeto do módulo ~math~. Para fazer isso você pode usar a estrutura "~from ... import ...~" como mostra o exemplo abaixo.

#+begin_src python -n
  from math import log  # leia-se "do módulo `math`, importe o objeto `log`"

  valor = 10000
  print(log(valor))
#+end_src

#+RESULTS:
: 9.210340371976184

Perceba que ao importar a função ~log~ dessa forma, ela agora funciona sem a necessidade de invocar o ~namespace~ do módulo ~math~ na linha 4. Inclusive, neste caso se escrevermos "~math.log(valor)~" irá dar um erro pois o módulo ~math~ em si não foi importado, apenas sua função ~log~ (tente e verá)!! O que aconteceu na linha 1 foi que importamos apenas uma função específica desse módulo _e nada mais_.

*[A]* Sua tarefa é calcular o seno de um número aleatório. Para isso, importe apenas as funções necessárias dos módulos ~math~ e ~random~ usando a estrutura de importação que acabamos de ver. _Dica_: a instrução ~import~ deve ser escrita para cada biblioteca que você quer importar. Você pode ter quantas instruções ~import~ forem necessárias no seu código.

Para importar mais de um objeto de um módulo, use vírgulas. Veja no exemplo abaixo.

#+begin_src python -n
  from math import factorial, pi, e

  print(pi)
  print(e)
  print(factorial(5))
#+end_src

#+RESULTS:
: 3.141592653589793
: 2.718281828459045
: 120

Existe uma sintaxe que nos permite importar /todos/ os objetos de um módulo fora do seu ~namespace~, basta usar o asterisco como mostrado no código abaixo. Entretanto, esse tipo de estrutura *não é recomendada* e não será aceita nas respostas das práticas desta apostila. Ela está apresentada aqui apenas para fins informativos.

#+begin_src python -n
  from math import *

  # veja que as funções abaixo foram importadas e podem ser usadas sem
  # chamar o namespace `math`. Porém, com a importação com  asterísco,
  # não fica claro de onde elas vieram (imagina isso num códico com milhares
  # de linhas...)
  print(exp(10))
  print(log2(100))
  print(tan(5))
#+end_src

#+RESULTS:
: 22026.465794806718
: 6.643856189774724
: -3.380515006246586

** Documentação da biblioteca padrão

#+begin_quote
"/Quando tudo o mais falhar, leia o manual de instruções./" --- Autor desconhecido
#+end_quote

A biblioteca padrão do Python é bastante extensa. Uma forma de checar o que já existe é lendo a [[https://docs.python.org/pt-br/3.9/py-modindex.html][documentação oficial]]. Lá você vai encontrar a seção do módulo [[https://docs.python.org/pt-br/3.9/library/math.html#module-math][math]] e a seção do módulo [[https://docs.python.org/pt-br/3.9/library/random.html#module-random][random]], entre tantas outras. Fora estes dois módulos, alguns outros que valem a pena dar uma olhada são:

+ ~statistics~ - cálculos estatísticos
+ ~pprint~ - comando ~print~ que exibe certas informações de forma "mais bonita"
+ ~datetime~ - operações com datas
+ ~itertools~ - operações iterativas
+ ~functools~ - operações funcionais
+ ~pathlib~ - operações com arquivos em diferentes pastas no sistema
+ ~pickle~ - possibilita salvar variáveis de Python em arquivos
+ ~os~ - ferramentas para controlar seu sistema operacional
+ ~sys~ - acessar parâmetros do sistema
+ ~re~ - expressões regulares

*[Desafio]* Descreva o que as funções ~product~, ~permutations~ e ~combinations~ do módulo ~itertools~ fazem. Elabore possíveis usos dessa funções.

*[Desafio 2]* Escolha 3 funções do módulo ~statistics~, descreva seu uso e use em um código seu.

*[Desafio 3]* Faça o Python exibir a data de hoje usando o módulo ~datetime~.

** Lendo dados externos ao Python

#+begin_quote
"/Um leitor vive mil vidas antes de morrer. O homem que nunca lê, vive apenas uma./" --- Jojen, A Dança dos Dragões
#+end_quote

Abra um gerenciador de planilhas (Microsoft Excel, LibreOffice Calc ou similar). Crie uma tabela com três colunas, similar ao exemplo abaixo. Salve sua tabela com o nome "populacao.xlsx" _na mesma pasta onde está seu caderno de notas do Jupyter que você está usando agora_.

| País     | Continente |  População |
|----------+------------+------------|
| Brasil   | América    |  212688125 |
| Alemanha | Europa     |   83190556 |
| China    | Ásia       | 1412600000 |
| Japão    | Ásia       |  125300000 |
| México   | América    |  126014024 |
| Equador  | América    |   17715822 |

Agora rode o código abaixo (certifique-se que seu kernel do Jupyter tem a biblioteca ~pandas~ instalada[fn:: A biblioteca ~pandas~ tem esse nome pois vem de "*pan*​el *da*​ta" que é um termo comum para dados multidimensionais. Infelizmente, ela não tem nada a ver com um dos animais mais fofos que existem...]. Se estiver usando os computadores da Ilum, use o kernel ~ilumpy~).

#+begin_src python -n :session pyvenv
  import pandas as pd

  dados = pd.read_excel("populacao.xlsx")
  print(dados)
#+end_src

#+RESULTS:
:        País Continente   População
: 0    Brasil    América   212688125
: 1  Alemanha     Europa    83190556
: 2     China       Ásia  1412600000
: 3     Japão       Ásia   125300000
: 4    México    América   126014024
: 5   Equador    América    17715822

Se seu código executou sem erros, meus parabéns! Você acabou de ler dados externos ao Python e armazená-los na variável ~dados~! 🎉

Vamos ver como isso aconteceu. Primeiramente nós importamos a biblioteca ~pandas~ na linha 1; aqui nós demos o apelido carinhoso de ~pd~ para ela. Na linha 3 nós usamos a função ~read_excel~ da biblioteca ~pandas~. Esta função, como o próprio nome sugere, é capaz de ler arquivos com a extensão ~.xlsx~, que é a extensão padrão do Microsoft Excel. A função ~read_excel~ recebeu como argumento único o nome da planilha que criamos, e armazenamos o retorno dessa função na variável ~dados~. A última linha simplesmente exibiu a variável ~dados~ para nós com o comando ~print~.

_Nota_: veja que o ~pandas~ só foi capaz de encontrar o nosso arquivo "população.xlsx" pois ele estava _na mesma pasta que o caderno de notas_! Podemos ler arquivos de qualquer lugar do nosso computador, porém, para ler arquivos que não estão na mesma pasta precisamos indicar o caminho para este arquivo. Veremos isso com o tempo.

*[A]* Crie o arquivo "população.xlsx" e carregue ele no Python usando a biblioteca ~pandas~ assim como mostrado acima.

*[B]* Vamos brincar com nosso objeto ~dados~ recém criado! Execute o código abaixo e comente sobre o que cada linha fez. Dos seus testes, como você diria que é a sintaxe para acessar os valores das colunas do objeto ~dados~?

#+begin_src python -n :session pyvenv
  print(dados['País'])
  print(dados['Continente'])
  print(dados['População'])
#+end_src

#+RESULTS:
#+begin_example
5     Equador
1    Alemanha
3       Japão
4      México
0      Brasil
2       China
Name: País, dtype: object
5    América
1     Europa
3       Ásia
4    América
0    América
2       Ásia
Name: Continente, dtype: object
5      17715822
1      83190556
3     125300000
4     126014024
0     212688125
2    1412600000
Name: População, dtype: int64
#+end_example

Antes de seguir em frente, vamos ver uma nomenclatura. O objeto ~dados~ que criamos usando a função ~read_excel~ do ~pandas~ é chamado de ~DataFrame~, que em português seria literalmente traduzido como um "quadro de dados", mas podemos chamar simplesmente de "tabela". Cheque se isso é verdade rodando o código abaixo.

#+begin_src python :session pyvenv
  print(type(dados))
#+end_src

#+RESULTS:
: <class 'pandas.core.frame.DataFrame'>

** Manipulando dados armazenados em ~DataFrames~

#+begin_quote
"/Você poderia fazer isso, por gentileza?/" --- Andrew Ryan, Bioshock
#+end_quote

Os objetos do tipo ~DataFrame~ são absurdamente poderosos! Eles nos permitem tratar dados de diversas maneiras. Veremos algumas a seguir. Como sempre, vale lembrar que nada melhor que a [[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html][documentação oficial]] para checar tudo que os ~DataFrames~​ são capazes de fazer.

*[A]* Execute o código abaixo e descreva o que aconteceu.

#+begin_src python -n :session pyvenv
  print(dados.sort_values("População"))
  print()
  print(dados.sort_values("População", ascending=False))
#+end_src

#+RESULTS:
#+begin_example
       País Continente   População
5   Equador    América    17715822
1  Alemanha     Europa    83190556
3     Japão       Ásia   125300000
4    México    América   126014024
0    Brasil    América   212688125
2     China       Ásia  1412600000

       País Continente   População
2     China       Ásia  1412600000
0    Brasil    América   212688125
4    México    América   126014024
3     Japão       Ásia   125300000
1  Alemanha     Europa    83190556
5   Equador    América    17715822
#+end_example

*[B]* Após executar o código acima, o que você acha que aconteceu com a sua variável ~dados~? Você acha que ela permanece inalterada ou que o método ~sort_values~ alterou ela? Teste sua hipótese com o comando ~print~. Comente o que observou.

Os dois exercícios anteriores são apenas exemplos para mostrar que _nem sempre_ os métodos de ~DataFrames~ alteram a sua variável original. No exemplo que vimos, o método ~sort_values~ apenas fez sua ação de ordenar as colunas e você exibiu o resultado com o comando ~print~, mas não efetivamente alterou o objeto ~dados~ em si! Dizemos que o método ~sort_values~ retornou uma "visão" do seu objeto ~dados~. Podemos guardar essa "visão" usando o operador de atribuição! Veja no exemplo abaixo:

#+begin_src python -n :session pyvenv
  dados_modificados = dados.sort_values("População")

  print(dados_modificados)
  print()
  print(dados)  # esse é o original!
#+end_src

#+RESULTS:
#+begin_example
       País Continente   População
5   Equador    América    17715822
1  Alemanha     Europa    83190556
3     Japão       Ásia   125300000
4    México    América   126014024
0    Brasil    América   212688125
2     China       Ásia  1412600000

       País Continente   População
0    Brasil    América   212688125
1  Alemanha     Europa    83190556
2     China       Ásia  1412600000
3     Japão       Ásia   125300000
4    México    América   126014024
5   Equador    América    17715822
#+end_example

Nada nos impede de guardar essa "visão" na própria variável original também, se assim desejarmos:

#+begin_src python -n :session pyvenv
  dados = dados.sort_values("População")

  print(dados)  # agora a variável orinal foi subsitituida
#+end_src

#+RESULTS:
:        País Continente   População
: 5   Equador    América    17715822
: 1  Alemanha     Europa    83190556
: 3     Japão       Ásia   125300000
: 4    México    América   126014024
: 0    Brasil    América   212688125
: 2     China       Ásia  1412600000

Digamos que você queira saber quantos Equadores "cabem" em cada um dos países da nossa tabela. Para isso vamos dividir a coluna ~População~ pela população do Equador (que é de 17.715.822 habitantes). Veja o código abaixo.

#+begin_src python -n :session pyvenv
  dados_modificados = dados.copy()
  dados_modificados['População'] = dados_modificados['População'] / 17715822
  print(dados_modificados)
  print()
  print(dados)
#+end_src

#+RESULTS:
#+begin_example
       País Continente  População
5   Equador    América   1.000000
1  Alemanha     Europa   4.695834
3     Japão       Ásia   7.072774
4    México    América   7.113078
0    Brasil    América  12.005547
2     China       Ásia  79.736633

       País Continente   População
5   Equador    América    17715822
1  Alemanha     Europa    83190556
3     Japão       Ásia   125300000
4    México    América   126014024
0    Brasil    América   212688125
2     China       Ásia  1412600000
#+end_example

Primeiramente, na linha 1, nós criamos uma cópia dos nossos dados para não alterar o original (usamos o método ~copy~, similar ao que fizemos com listas). Na linha 2 alteramos o valor da coluna ~População~ usando a sintaxe do ~pandas~. Observe que precisamos usar o operador de atribuição aqui! Por fim, na linha 3 demos um ~print~ nos dados modificados (que respondeu nossa pergunta original) e na linha 5 nós vemos que nossa variável original ~dados~ permanece inalterada pois trabalhamos em uma cópia dela.

*[C]* Usando a sintaxe que acabamos de ver, crie uma cópia da variável ~dados~ e nesta cópia faça com que a coluna ~População~ armezene a população em unidade de milhão de pessoas. Exiba seus cálculos com o comando ~print~.

** Plotando gráficos com ~pandas~

#+begin_quote
"/De todas as nossas invenções para a comunicação de massa, as imagens ainda falam a língua mais compreendida universalmente./" --- Walt Disney
#+end_quote

No jargão científico, quando nós produzimos um gráfico é comum dizer que "plotamos um gráfico". "Plotar" vem do verbo /plot/ do inglês.

Existem diversas ferramentas para plotar gráficos em Python. O ~pandas~ não é uma biblioteca especializada em gráficos, porém ele nos fornece uma interface muito amigável para uma biblioteca chamada ~matplotib~ que é muito poderosa para gerar gráficos.

*[A]* Rode o código abaixo e escreva brevemente sobre o que você entendeu da sintaxe para criar um plot usando um ~DataFrame~.

#+begin_src python -n :session pyvenv
  import pandas as pd

  dados = pd.read_excel("populacao.xlsx")
  ax = dados.plot("País", "População")
#+end_src

#+RESULTS:
: <class 'matplotlib.axes._subplots.AxesSubplot'>

O código acima é bastante intuitivo: nós rodamos o método ~plot~ da nossa variável ~dados~ e fornecemos para ele o que deve ser plotado no eixo $x$ (foi a coluna "País") e o que deve ser plotado no eixo $y$ (foi a coluna "População"). O retorno do método ~plot~ é um objeto do tipo ~AxesSubplot~ que nós armazenamos na variável ~ax~. Este objeto é um objeto da biblioteca ~matplotlib~ que armazena as informações dos eixos do seu plot. Veremos mais detalhes sobre isso adiante, não se preocupe com isso neste momento.

*[B]* Vamos fazer um plot de barras! Rode o código abaixo e compare com o anterior.

#+begin_src python :session pyvenv
  ax = dados.plot.bar("País", "População")
#+end_src

*[C]* Faça um plot de barras assim como no exercício anterior, porém faça com que barras fiquem em ordem decrescente de tamanho. _Dica_: para isso você precisa ordenar seu ~DataFrame~ antes! Lembre-se do método ~sort_values~ que já vimos anteriormente.

# #+begin_src python -n :session pyvenv
#   dados_sort = dados.sort_values("População", ascending=False)
#   ax = dados_sort.plot.bar("País", "População")
# #+end_src

Para encerrar esta parte, vamos ver como salvar nosso gráfico:

#+begin_src python -n :session pyvenv
  ax = dados.plot.bar("País", "População")

  # precisamos obter o objeto `fig` antes de salvar
  fig = ax.get_figure()

  # sugestão: sempre use o argumento `bbox_inches="tight"` quando for salvar
  fig.savefig("grafico.png", bbox_inches="tight")
#+end_src

#+RESULTS:

Veja que para salvar o gráfico primeiro precisamos obter o objeto ~fig~ a partir do nosso objeto ~ax~. Isso é feito pelo método ~get_figure~ mostrado na linha 4. Este tipo de separação em um objeto de figura (~fig~) e um objeto de eixo (~ax~) é uma peculiaridade do ~matplotlib~. Não temos muito o que fazer a respeito, apenas aceitar a realidade como ela se apresenta. É na linha 7 que efetivamente salvamos a imagem com o método ~savefig~. O primeiro argumento deve ser o nome do seu gráfico com a extensão que você quer (pode ser ".png", ".jpg", ".pdf" entre outras). O argumento ~bbox_inches~ controla qual parte do gráfico você quer salvar. _Dica_: sempre use ~bbox_inches="tight"~ e não terá problemas.

*[D]* Teste seus conhecimentos novos! Crie uma nova planilha de dados com os dados que você quiser (pode buscar uma tabela pronta ou inventar a sua). Use o ~pandas~ para criar um objeto do tipo ~DataFrame~ com essa tabela. De um ~print~ na sua tabela e faça dois plots diferentes com ela. Salve seus plots em dois arquivos diferentes.
* Vetores e matrizes
** Listas não foram feitas para cálculos de álgebra linear

#+begin_quote
"/Todo mundo é um gênio. Mas se você julgar um peixe por sua capacidade de subir em uma árvore, ele vai gastar toda a vida acreditando que é estúpido./" --- Autor desconhecido
#+end_quote

Listas de Python são objetos muito úteis para diversas tarefas, porém não para cálculos de álgebra linear. Isto pois listas não são vetores e listas não são matrizes; listas são apenas um conjunto de objetos agrupados em uma certa ordem, nada mais nada menos.

Para cálculos de álgebra linear nós temos a disposição a excelente biblioteca ~numpy~. O objeto principal que esta biblioteca nos fornece é o ~ndarray~ (array de $n$ dimensões) que costuma ser carinhosamente chamado apenas de ~array~ ou ~numpy array~. Vamos ver um exemplo de como criamos esses arrays.

#+begin_src python -n :session pyvenv
  import numpy as np


  array_1d = np.array([1, 2, 3])  # array de 1 dimensão

  print(array_1d)
  print(type(array_1d))

  lista_de_listas = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9],
  ]

  array_2d = np.array(lista_de_listas)  # array de 2 dimensões

  print(array_2d)
  print(type(array_2d))
#+end_src

#+RESULTS:
: [1 2 3]
: <class 'numpy.ndarray'>
: [[1 2 3]
:  [4 5 6]
:  [7 8 9]]
: <class 'numpy.ndarray'>

Simples, não? Basta fornecer uma lista para a função ~np.array~ e pronto, criamos um array de ~numpy~. _Nota_: a biblioteca ~numpy~ é muito usada. Como convenção, nós sempre importamos ela com o apelido de ~np~. Vamos seguir essa convenção!

*[A]* Crie uma lista contendo 6 elementos que devem ser os dígitos do seu RM. Após isso, multiplique essa lista por um inteiro maior que 2, multiplique essa lista por ela mesma, some 10 a essa lista e some essa lista com ela mesma. Reporte o que aconteceu em cada um dos passos. Agora crie um array usando sua lista e repita todas as etapas. Reporte o que aconteceu em cada um dos passos e compare as diferenças entre arrays e listas.

# #+begin_src python -n :session pyvenv
#   lista = [1,2,3,4,5,6]

#   print(lista * 3)
#   # print(lista * lista)
#   print(lista + lista)

#   array = np.array(lista)

#   print(array * 3)
#   print(array * array)
#   print(array + array)
# #+end_src

# #+RESULTS:
# : [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
# : [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
# : [ 3  6  9 12 15 18]
# : [ 1  4  9 16 25 36]
# : [ 2  4  6  8 10 12]

Como você deve ter percebido na prática, arrays não se comportam como listas e listas não se comportam como arrays. Os dois objetos são úteis, mas geralmente arrays facilitam muito nossos cálculos científicos e por conta disso costumam ser mais usados.

*[B]* Crie uma função que recebe um array numérico de 1 dimensão de tamanho arbitrário. Considere que todos os números deste array são medidas de temperatura em Celsius. Retorne para o usuário um array de mesmo tamanho com as temperaturas convertidas para [[https://pt.wikipedia.org/wiki/Rankine][Rankine]]. Não use laço de repetição aqui, se aproveite das propriedades dos arrays!!

** Criando arrays sem usar listas

#+begin_quote
"/Não podemos resolver nossos problemas com o mesmo nível de pensamento que usamos para criá-los./" --- Albert Einstein
#+end_quote

Podemos criar arrays sem a necessidade de fornecer uma lista como dado de entrada, o que costuma ser muito útil!

*[A]* As funções ~zeros~ e ~ones~ criam arrays de qualquer tamanho contendo apenas zeros e uns, respectivamente. Veja o exemplo abaixo e escreva brevemente  sobre o que você entendeu dessas funções. Usando a função ~ones~ e a propriedade multiplicativa de arrays que vimos na seção anterior, crie uma matriz 3 por 5 onde todos os elementos são o número 42.

#+begin_src python -n :session pyvenv
  array1 = np.zeros(10)
  array2 = np.zeros((3, 4))

  array3 = np.ones(5)
  array4 = np.ones((2, 3))
#+end_src

#+RESULTS:
: [[1. 1. 1.]
:  [1. 1. 1.]]

O ~numpy~ tem também a função ~arange~ que funciona de forma similar ao ~range~ que já conhecemos. Diferentemente da ~range~, a função ~arange~ cria um array! Outra diferença é que a função ~arange~ permite criar sequências com intervalos não-inteiros. Veja o exemplo abaixo.

#+begin_src python -n :session pyvenv
  array1 = np.arange(10)
  array2 = np.arange(10, 20)
  array3 = np.arange(0, 110, 10)
  array4 = np.arange(0, 1, 0.1)  # o intervalo não precisa ser inteiro!

  for array in [array1, array2, array3, array4]:
      print(array)
#+end_src

#+RESULTS:
: [0 1 2 3 4 5 6 7 8 9]
: [10 11 12 13 14 15 16 17 18 19]
: [  0  10  20  30  40  50  60  70  80  90 100]
: [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]

Existe também a função ~linspace~ que serve para criar um array com $n$ valores _igualmente espaçados_ dentro de um certo intervalo numérico. Vamos ver alguns exemplos.

#+begin_src python -n :session pyvenv
  array1 = np.linspace(0, 1, 101)  # array com 101 valores entre 0 e 1
  array2 = np.linspace(0, 10, 5)  # array com 5 valores entre 0 e 10
  array3 = np.linspace(0, 10)  # sem o último argumento ele gera 50 números

  for array in [array1, array2, array3]:
      print(array)
#+end_src

#+RESULTS:
#+begin_example
[0.   0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1  0.11 0.12 0.13
 0.14 0.15 0.16 0.17 0.18 0.19 0.2  0.21 0.22 0.23 0.24 0.25 0.26 0.27
 0.28 0.29 0.3  0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.4  0.41
 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.5  0.51 0.52 0.53 0.54 0.55
 0.56 0.57 0.58 0.59 0.6  0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69
 0.7  0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.8  0.81 0.82 0.83
 0.84 0.85 0.86 0.87 0.88 0.89 0.9  0.91 0.92 0.93 0.94 0.95 0.96 0.97
 0.98 0.99 1.  ]
[ 0.   2.5  5.   7.5 10. ]
[ 0.          0.20408163  0.40816327  0.6122449   0.81632653  1.02040816
  1.2244898   1.42857143  1.63265306  1.83673469  2.04081633  2.24489796
  2.44897959  2.65306122  2.85714286  3.06122449  3.26530612  3.46938776
  3.67346939  3.87755102  4.08163265  4.28571429  4.48979592  4.69387755
  4.89795918  5.10204082  5.30612245  5.51020408  5.71428571  5.91836735
  6.12244898  6.32653061  6.53061224  6.73469388  6.93877551  7.14285714
  7.34693878  7.55102041  7.75510204  7.95918367  8.16326531  8.36734694
  8.57142857  8.7755102   8.97959184  9.18367347  9.3877551   9.59183673
  9.79591837 10.        ]
#+end_example

Por fim, podemos gerar um array aleatório com o comando ~random~ do ~numpy~. Ele gera arrays contendo valores aleatórios entre 0 e 1.

#+begin_src python -n :session pyvenv
  array_1d = np.random.random(10)

  array_2d_3x3 = np.random.random((3, 3))
  array_2d_5x4 = np.random.random((5, 4))

  print(array_1d)
  print(array_2d_3x3)
  print(array_2d_5x4)
#+end_src

#+RESULTS:
#+begin_example
[0.78459876 0.70643543 0.03379155 0.03525707 0.98959662 0.43755816
 0.27687816 0.85687271 0.0231125  0.32996954]
[[0.88358629 0.86299388 0.42355928]
 [0.49502425 0.88376125 0.09668543]
 [0.60909926 0.92862117 0.72223277]]
[[0.60027341 0.86250924 0.74419914 0.54000965]
 [0.39380561 0.11596089 0.97158986 0.54952193]
 [0.98834545 0.71971824 0.33617425 0.14113405]
 [0.53876703 0.44077033 0.02973686 0.17224248]
 [0.44180125 0.95462162 0.1489127  0.42849787]]
#+end_example

*[B]* Crie um array utilizando o ~linspace~ e outro array utilizando o ~random~. Após criá-los, multiplique os dois arrays e exiba o resultado.

** Funções universais

#+begin_quote
"/A matemática expressa valores que refletem o cosmos, incluindo ordem, equilíbrio, harmonia, lógica e beleza abstrata./" --- Deepak Chopa
#+end_quote

Quando trabalhamos com dados é bastante comum situações onde temos que aplicar uma função matemática em um certo conjunto de dados. Por exemplo: calcular o logaritmo dos valores em uma coluna de uma tabela. O código abaixo mostra que isso não é possível com a função ~log~ do módulo ~math~... essa função funciona apenas em variáveis numéricas... e agora?

#+begin_src python -n :session pyvenv
  from math import log


  lista = [1, 2, 3]
  print(log(lista))
#+end_src

#+RESULTS:

Precisamos de funções que "entendem" como operar nos elementos de uma lista ou array. Essas são as chamadas funções universais do ~numpy~ (chamadas de ~ufunc~ na documentação). Veja o exemplo abaixo:

#+begin_src python -n :session pyvenv
  lista = [1, 2, 3]
  print(np.log(lista))  # estamos usando o `log` do numpy aqui
#+end_src

#+RESULTS:
: [0.         0.69314718 1.09861229]

O ~numpy~ tem diversas funções universais como ~log~, ~log10~, ~sqrt~, ~sin~, ~cos~, ~tan~, ~exp~, ~absolute~ e outras. Como sempre, a [[https://numpy.org/doc/stable/reference/ufuncs.html][documentação oficial]] é uma excelente fonte de informação.

*[A]* Use o ~numpy~ e o ~pandas~ para gerar um gráfico de uma função matemática. Os valores do eixo $x$ devem ser gerados pelo ~numpy~ usando ~arange~ ou ~linspace~ (escolha o que julgar mais apropriado). Os valores do eixo $y$ devem ser calculados usando funções universais se necessário. O tipo de função a ser plotada depende do último digito do seu RM:

0) [@0] polinomial de grau 2 em $x$
1) exponencial de $x$
2) logaritmo base 10 de $x$
3) raiz quadrada de $x$
4) seno de $x$
5) cosseno de $x$
6) arco tangente de $x$
7) dez elevado a $x$
8) absoluto de $x$
9) cosseno hiperbólico de $x$

# Para resolver a prática anterior, veja as seguintes dicas.

# Para criar um ~DataFrame~ de ~pandas~ a partir de um array use a seguinte sintaxe:

# #+begin_src python -n :session pyvenv
#   import pandas as pd
#   import numpy as np


#   array = np.linspace(0,1)
#   data = pd.DataFrame(array)
#   print(data)
# #+end_src

# Para concatenar arrays verticalmente use o ~vstack~. Para concatenar arrays horizontalmente use o ~hstack~. Veja o exemplo abaixo.

# #+begin_src python -n :session pyvenv
#   array_1 = np.array([1, 2, 3])
#   array_2 = np.array([4, 5, 6])

#   array_concatenado_verticalmente = np.vstack([array_1, array_2])
#   array_concatenado_horizontalmente = np.hstack([array_1, array_2])

#   print(array_concatenado_verticalmente)
#   print(array_concatenado_horizontalmente)
# #+end_src

# #+RESULTS:
# : [[1 2 3]
# :  [4 5 6]]
# : [1 2 3 4 5 6]

# Para obter a transposta de um array, use o atributo ~T~.

# #+begin_src python -n :session pyvenv
#   array_transposto = array_concatenado_verticalmente.T
#   print(array_transposto)
# #+end_src

# #+RESULTS:
# : [[1 4]
# :  [2 5]
# :  [3 6]]

** Funções agregadoras

#+begin_quote
"/Se nós dois estamos com fome e eu como um frango inteiro, na média estamos nós dois saciados./" --- Autor desconhecido
#+end_quote

Soma dos elementos, mínimo, máximo, média e desvio padrão são operações chamadas agregadoras que são muito utilizadas. Arrays de ~numpy~ nos permitem computar esses valores de maneira muito fácil! Veja o exemplo abaixo.

#+begin_src python -n :session pyvenv
  array1 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])

  soma = array1.sum()
  minimo = array1.min()
  maximo = array1.max()
  media = array1.mean()
  desvio_padrao = array1.std()

  for valor in [soma, minimo, maximo, media, desvio_padrao]:
      print(valor)
#+end_src

#+RESULTS:
: 45
: 1
: 9
: 5.0
: 2.581988897471611

O que acontece quando usamos essas funções em arrays com mais de uma dimensão? Absolutamente a mesma coisa! Veja que o ~numpy~ completamente ignorou o que é linha e o que é coluna do seu array de entrada e computou um valor considerando todos os números do seu array.

#+begin_src python -n :session pyvenv
  array2 = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  soma = array2.sum()
  minimo = array2.min()
  maximo = array2.max()
  media = array2.mean()
  desvio_padrao = array2.std()

  for valor in [soma, minimo, maximo, media, desvio_padrao]:
      print(valor)
#+end_src

#+RESULTS:
: 45
: 1
: 9
: 5.0
: 2.581988897471611

Mas nem sempre é isso que queremos! As vezes queremos o valor médio de cada coluna da nossa tabela. As vezes queremos a soma dos valores de cada linha. Enfim, a vida científica nos dá tarefas e precisamos que o ~numpy~ resolva elas. Para resolver isso temos que usar o argumento ~axis~ que define o eixo onde a conta será realizada. Quando usamos ~axis=0~ nós estamos pedindo para o ~numpy~ realizar sua tarefa na direção das _linhas_ do nosso array. Diferentemente, quando usamos ~axis=1~ nós queremos que ele realize a sua tarefa na direção das _colunas_ do nosso array.

Para ser absurdamente sincero, leva um tempo até se acostumar com essa notação do argumento ~axis~. Veja se com o exemplo abaixo fica mais fácil de entender. Preste atenção principalmente nos valores mínimos e máximos que são os mais diretos de acompanhar o que acontece.

#+begin_src python -n :session pyvenv
  array2 = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  print("Calculos realizados na direção das linhas da matriz")
  soma = array2.sum(axis=0)
  minimo = array2.min(axis=0)
  maximo = array2.max(axis=0)
  media = array2.mean(axis=0)
  desvio_padrao = array2.std(axis=0)

  for valor in [soma, minimo, maximo, media, desvio_padrao]:
      print(valor)


  print()
  print("Calculos realizados na direção das colunas da matriz")
  soma = array2.sum(axis=1)
  minimo = array2.min(axis=1)
  maximo = array2.max(axis=1)
  media = array2.mean(axis=1)
  desvio_padrao = array2.std(axis=1)

  for valor in [soma, minimo, maximo, media, desvio_padrao]:
      print(valor)
#+end_src

#+RESULTS:
#+begin_example
Calculos considerando as linhas da matriz
[12 15 18]
[1 2 3]
[7 8 9]
[4. 5. 6.]
[2.44948974 2.44948974 2.44948974]

Calculos considerando as colunas da matriz
[ 6 15 24]
[1 4 7]
[3 6 9]
[2. 5. 8.]
[0.81649658 0.81649658 0.81649658]
#+end_example

** Indexando arrays

#+begin_quote
"/Eu poderia ser vendado e jogado no oceano mais profundo e saberia onde encontrá-lo. Eu poderia ser enterrado a cem milhas de profundidade e saberia onde você está./" --- Neil Gaiman, Deuses Americanos
#+end_quote

Existem diversas formas de indexar arrays. Veremos as mais simples por enquanto. A sintaxe que aprendemos com listas funciona aqui:

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  linha_0 = array[0]
  linha_1 = array[1]
  linha_2 = array[2]

  linhas_0_e_1 = array[:2]
  linhas_1_e_2 = array[1:]

  linha_0_coluna_0 = array[0][0]
  linha_1_coluna_2 = array[1][2]
#+end_src

#+RESULTS:

Também podemos usar a sintaxe própria do ~numpy~ (que não funciona para listas!):

#+begin_src python -n :session pyvenv
  linha_0_coluna_0 = array[0, 0]
  linha_1_coluna_2 = array[1, 2]

  # O `:` indica `todos os elementos desta posição`
  coluna_0 = array[:, 0]
  coluna_1 = array[:, 1]
  coluna_2 = array[:, 2]
#+end_src

Pela natureza iterativa dos arrays, podemos usar eles em laços de repetição ~for~ de maneira similar ao que fazíamos com listas. Veja um exemplo:

#+begin_src python -n :session pyvenv
  array_1d = np.array([1, 2, 3, 4])

  for valor in array_1d:
      print(valor)


  array_2d = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  for linha in array_2d:
      print(linha)
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: [1 2 3]
: [4 5 6]
: [7 8 9]

*[A]* Crie um array 4 $\times$ 4. Compute a multiplicação da primeira linha do array pela terceira. Após isso, subtraia do resultado a segunda linha e exiba para o usuário.

*[B]* A tabela abaixo, armazenada na variável ~dados~, tem 3 colunas: ano, quantidade de pessoas que comeram sorvete de pistache (por mil habitantes) e o logaritmo na base 10 de unidades individuais de pipoca consumidas (por mil habitantes). Usando indexação de arrays e funções agregadoras, encontre os seguintes valores:

1) Consumo médio de sorvete de pistache entre 2010 e 2021.
2) Consumo médio de unidades de pipoca entre 2010 e 2021 (dica: não é em log que a pergunta pede!).
3) Desvio padrão do número de unidades individuais de pipoca consumidas entre os anos de 2015 e 2019.
4) A diferença entre o valor máximo e o valor mínimo de pessoas que consumiram sorvete de pistache entre 2011 e 2018.
5) A soma de todas a unidades individuais de pipoca consumidas de 2011 até 2021.

#+begin_src python
  dados = [
      [2010, 20, 8],
      [2011, 22, 9],
      [2012, 27, 8],
      [2013, 27, 6],
      [2014, 25, 5],
      [2015, 21, 7],
      [2016, 18, 9],
      [2017, 16, 12],
      [2018, 17, 11],
      [2019, 21, 10],
      [2020, 28, 9],
      [2021, 30, 8],
  ]
#+end_src

** Atributos e peculiaridades de arrays

#+begin_quote
"/Mas minha rosa, sozinha, é mais importante do que todos vocês juntos, já que ela é a que eu reguei./" --- Antoine de Saint-Exupéry, O Pequeno Príncipe
#+end_quote

Arrays têm alguns atributos que ajudam muito nossa vida:

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  print(array.shape)  # formato do array
  print(array.ndim)   # número de dimensões
  print(array.size)   # quantidade de valores que tem no array
  print(array.dtype)  # tipo dos dados armazenados no array
#+end_src

#+RESULTS:
: (3, 3)
: 2
: 9
: int64

*[A]* Escreva uma função que recebe um array e checa se ele é uma matriz quadrada. Se for, retorne a soma da diagonal principal. Se não for uma matriz quadrada, retorne ~False~.

Diferentemente de listas, arrays não têm os métodos ~append~, ~remove~, ~pop~ e ~extend~. Uma vez que o array foi criado, seu tamanho não pode ser alterado. Mas podemos alterar seu formato! Para isso usamos o método ~reshape~.

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  array_2 = array.reshape((1, 9))  # 1 linha e 9 colunas
  array_3 = array.reshape((9, 1))  # 9 linhas e 1 coluna

  print(array)
  print(array_2)
  print(array_3)
#+end_src

#+RESULTS:
#+begin_example
[[1 2 3]
 [4 5 6]
 [7 8 9]]
[[1 2 3 4 5 6 7 8 9]]
[[1]
 [2]
 [3]
 [4]
 [5]
 [6]
 [7]
 [8]
 [9]]
#+end_example

Veja que as operações do ~numpy~ nunca geram uma /cópia/ do seu array, apenas uma /visão/ dele. Sabemos que visões de objetos podem nos levar a erros quando alteramos os valores do objeto! Vamos ver um exemplo:

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  array_2 = array.reshape((1, 9))  # 1 linha e 9 colunas
  array_3 = array.reshape((9, 1))  # 9 linhas e 1 coluna

  array_2[0, 0] = 10  # alteramos o valor da linha 0 e da coluna 0 apenas do array_2

  # veja que todos os arrays foram alterados!!!
  print(array)
  print(array_2)
  print(array_3)
#+end_src

#+RESULTS:
#+begin_example
[[10  2  3]
 [ 4  5  6]
 [ 7  8  9]]
[[10  2  3  4  5  6  7  8  9]]
[[10]
 [ 2]
 [ 3]
 [ 4]
 [ 5]
 [ 6]
 [ 7]
 [ 8]
 [ 9]]
#+end_example

Então sempre que precisar, crie uma cópia do seu array com o método ~copy~.

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  array_2 = array.reshape((1, 9)).copy()  # cópia!!
  array_3 = array.reshape((9, 1))

  array_2[0, 0] = 10  # alteramos o valor da linha 0 e da coluna 0 apenas do array_2

  print(array)
  print(array_2) # apenas esse foi modificado pois ele é uma cópia!
  print(array_3)
#+end_src

#+RESULTS:
#+begin_example
[[1 2 3]
 [4 5 6]
 [7 8 9]]
[[10  2  3  4  5  6  7  8  9]]
[[1]
 [2]
 [3]
 [4]
 [5]
 [6]
 [7]
 [8]
 [9]]
#+end_example

** Algumas operações de álgebra linear

#+begin_quote
"/Se álgebra linear já não é lá muito fácil, imagina a não-linear.../" --- D. R. Cassar
#+end_quote

Multiplicação matricial entre dois arrays pode ser feita com o operador ~@~ (também conhecido com operador de multiplicação matricial).

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  multiplicacao = array @ array

  print(multiplicacao)
#+end_src

#+RESULTS:
: [[ 30  36  42]
:  [ 66  81  96]
:  [102 126 150]]

A matriz transposta de um array pode ser obtida com o atributo ~T~.

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
      ]
  )

  transposta = array.T

  print(array)
  print()
  print(transposta)
#+end_src

#+RESULTS:
: [[1 2 3]
:  [4 5 6]
:  [7 8 9]]
:
: [[1 4 7]
:  [2 5 8]
:  [3 6 9]]

O determinante de uma matriz pode ser calculado com a função ~linalg.det~ e a inversa de uma matriz pode ser calculada com a função ~linalg.inv~.

#+begin_src python -n :session pyvenv
  array = np.array(
      [
          [5, 2, 3],
          [4, 5, 6],
          [7, 8, 5],
      ]
  )

  determinante = np.linalg.det(array)
  inversa = np.linalg.inv(array)

  print(determinante)
  print()
  print(inversa)
#+end_src

#+RESULTS:
: -79.99999999999997
:
: [[ 0.2875 -0.175   0.0375]
:  [-0.275  -0.05    0.225 ]
:  [ 0.0375  0.325  -0.2125]]

Outras operações de álgebra linear podem ser checadas na [[https://numpy.org/doc/stable/reference/routines.linalg.html][documentação oficial]], como sempre.

* Bash e computação de alta performance
** Breve introdução a computação de alta performance

A computação de alta performance (HPC do termo em inglês /High Performance Computing/) já tiveram muitas tecnologias e formas, desde sistemas mecânicos de engrenagens, válvulas e atualmente circuitos integrados de silício. A arquitetura dos computadores de chips integrados também já mudou bastante ao longo do tempo, mas agora a grande maioria dos sistemas de HPC são /clusters/, que são basicamente vários computadores interligados por redes de alta banda e baixa latência, sendo a mais adotada a rede /infiniband/ (atualmente com banda de 200 gbit/s e 130 nanosegundos de latencia). Quanto aos sistemas operacionais, muitos já foram utilizados também, porém, uma consulta no TOP500 (www.top500.org) mostra que todos os 500 computadores mais rápidos do mundo usam alguma forma de Linux. No sistema de HPC da Ilum a escolha não é diferente, utilizamos Linux também, com suas ferramentas de acesso e gerenciamento.

Como os sistemas de HPC são acessados remotamente, devido ao ambiente não muito agradável de /datacenters/, basicamente só realizamos operações via terminal (a tela preta só com caracteres). No linux, o tipo de interpretador de comandos no terminal mais usado atualmente é o bash, que é basicamente a linguagem de programação do terminal. Agora que vocês já sabem o básico de python, torna-se mais simples o processo de aprender outras linguagens. Então, ao longo do curso ensinaremos a vocês um básico de bash, para executar comandos básicos e manipular arquivos, assim como escrever alguns scripts utilizando bash e programas como grep, awk, entre outros.

** Acessando uma máquina remotamente

Para acessarmos uma máquina remotamente vamos utilizar o PowerShell do windows e então o protocolo SSH (Secure Shell). Como na imagem abaixo, aperte o menu iniciar da sua máquina e digite powershell, abra então o windows powershell.
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/powershell.png]]

O Windows Powershell deve ter aberto uma janela como a mostrada na figura abaixo:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/winpower.png]]

Vamos agora acessar o HPC da Ilum, carinhosamente nomeado como Heisenberg. Execute o comando abaixo substituindo o nome.ultimo_nome com seu primeiro nome e último nome, por exemplo, James Moraes de Almeida fica ~ssh james.almeida@172.20.10.15~. Sua senha temporária é senhateste logo que vocês logarem será pedido para alterar a senha, por favor, usem uma senha forte!
#+BEGIN_SRC bash
  ssh nome.ultimo_nome@172.20.10.15
#+END_SRC

Pronto, agora você está no HPC da Ilum! Mas vamos com calma, usem com parcimônia, apenas para usos estritamente acadêmicos. Como é uma máquina adquirida com recursos públicos, temos regras de uso. Nada que envolva ganhos pessoais pode ser efetuado nesta máquina, devido a legislação vigente.

Vamos então aos comandos básicos:
+ ls : lista os arquivos do diretório. Por hora vocês não possuem nada no seu diretório, então nada aparecerá.
+ mkdir nome-do-diretorio : cria um diretório.
+ cd nome-do-diretorio : entra no diretório.
+ cd .. : volta ao diretório um nível acima.

Vamos realizar então a primeira atividade, crie um diretório chamado work e entre nesse diretório, liste os arquivos do diretório (estará vazio), após isso volte ao diretório anterior.
#+BEGIN_SRC bash
  mkdir work
  cd work
  ls
  cd ..
#+END_SRC

Pronto, agora você criou um diretório entrou nele e voltou ao seu ~home~. Mas ~home~ professor, o que é isso? É basicamente o local onde ficam todos os seus arquivos, cada usuário da máquina possui um diretório na partição ~home~ do linux.

Ótimo! Mas agora precisamos executar nossos códigos de Python na máquina, para isso, vamos instalar o gerenciador de pacotes Anaconda. Execute os seguintes passos mostrados abaixo:
#+BEGIN_SRC bash
  cd #Esse comando lhe leva ao seu home
  mkdir Packages #Crie um diretório para guardar seus programas
  cd Packages #Entre no diretório de pacotes
  wget https://repo.anaconda.com/archive/Anaconda3-2021.11-Linux-x86_64.sh #Este comando faz o download do instalador da versão mais atual no dia 05/05/2022
  bash Anaconda3-2021.11-Linux-x86_64.sh #Inicia a instalação do Anaconda
#+END_SRC

A instalação do Anaconda pedirá algumas confirmações e a aceitação da licensa. Como nosso uso é acadêmico, podemos utilizá-lo sem custos. Podem utilizar o diretório padrão para a instalação. Ao final, digitem ~yes~ para a inicialização do Anaconda3, como mostrado abaixo:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/conda1.png]]

Para inicializar o conda (apelido do Anaconda), precisamos reler o script de inicialização do seu usuário, para isso, digite o seguinte comando:
#+BEGIN_SRC bash
  source ~/.bashrc
#+END_SRC

Algo como o mostrado na imagem abaixo deve aparecer:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/bashrc.PNG]]

Agora o ambiente base do seu conda está ativado. Não é recomendável modificar este ambiente base, devemos criar um ambiente separado para instalarmos nossos pacotes, evitando /quebrar/ nosso ambiente principal. Vamos criar um ambiente chamado ilumpy:

#+BEGIN_SRC bash
  conda create --name ilumpy
#+END_SRC

Aceite a instalação no local indicado com /y/. Agora o ambiente ilumpy está criado, o próximo passo é ativá-lo!

#+BEGIN_SRC bash
  conda activate ilumpy
#+END_SRC

Agora seu terminal deve estar indicando o ambiente conda logo antes do seu nome de usuário, como mostrado na figura abaixo:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/ilumpy.PNG]]

Note que o ambiente mudou de (base) para (ilumpy). Agora vamos instalar o Python e o Jupyter neste ambiente, para isso digite os comandos abaixo:

#+BEGIN_SRC bash
  conda install python
  conda install jupyter
#+END_SRC

Quando for perguntado ~Proceed ([y]/n)?~ Digite ~y~ e de enter. Com isso o Python estará instalado em seu ambiente e podemos começar a programar no Jupyter. Existem maneiras de programar diretamente no HPC, com algum editor de texto para terminal, como vi ou o nano, porém, aprender a utilizar esses editores é uma tarefa um tanto árdua, e sua interface é um tanto precária. Então, vamos continuar utilizando o Jupyter, que vocês já estão acostumados. Porém, a maneira de utilizá-lo é diferente, pois rodaremos os códigos a partir da Heisenberg, e não nos seus computadores. Para isso, precisamos também utilizar o gerenciador de processos da máquina, pois como a máquina é compartilhada, precisamos gerenciar os recursos utilizados, alocando o que há disponível para cada processo e deixando na fila de espera o que não tem recursos disponíveis para rodar. Quem gerencia esses recursos na Heisenberg é o programa ~slurm~, que é um dos mais utilizados no mundo de HPC. Para ele alocar um processo, ou como comumente chamado /job/, precisamos de um script com as instruções necessárias, tal script interpretará a linguagem bash em nosso caso.

Faça o download do arquivo =job.sh= da atividade do capítulo 9 do Moodle para seu computador, agora precisamos transferir este arquivo para a Heisenberg, mas como? Vamos utilizar um programa chamado WinSCP, que possui uma interface gráfica amigável para essas operações. O WinSCP usa o protocolo de tranferência de arquivos SCP, o mesmo do Secure Shell, porém para tranferências. Vá para o endereço https://winscp.net/eng/download.php e faça o download do WinSCP. Ao iniciar o instalador, selecione a opção, ~Instalar só para mim~, instale com todas opções padrão e execute o WinSCP no final. Com o programa aberto digite os dados de acesso como mostrado abaixo:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/winscp1.PNG]]

Clique em Salvar e dê o nome de Heisenberg para a máquina, assim você não precisa digitar os dados de acesso toda a vez que for acessar a máquina. Clique então em login, agora você estará na Heisenberg, podendo transferir arquivos do seu computador para ela e vice-versa. Note que, a janela da esquerda é a janela com os arquivos do seu computador, a janela da direita é a janela com os arquivos da sua área na Heisenberg. Para transferir os arquivos basta arrastar de uma máquina para outra, simples assim. Faça isso para o arquivo job.sh que você acabou de fazer download, envie ele para a sua pasta work na Heisenberg. Pronto! Agora podemos submeter o /job/!

Antes de submetermos o /job/, vamos entender a sintaxe básica do slurm. Primeiro digite ~squeue~, esse comando lhe mostrará os /jobs/ em execução, caso você queira averiguar apenas os jobs que você está rodando, digite ~squeue -u seu.usuário~. Para cancelar um /job/ que está rodando, digite, ~scancel número.do.job~, esse número do /job/ você obtem com o comando ~squeue -u seu.usuário~, onde a primeira coluna é o número do /job/. Ótimo, vamos então a submissão do /job/ para podermos começar a utilizar o Jupyter, vá até a sua pasta work, onde o job.sh deve estar salvo após a transferência com o WinSCP, e digite ~sbatch job.sh~. Com isso seu /job/ deve iniciar a rodar e o servidor Jupyter. Porém, não abriu a janela do Jupyter como normalmente abre em seus computadores, isso acontece porque o servidor foi iniciado na Heisenberg, então precisamos abrir no navegador o servidor com o ip da Heisenberg. Dê um ~ls~ nos arquivos da sua pasta work, note que um arquivo ~slurm-número.do.job.out~ foi gerado, nele são gravadas as saídas do que está sendo rodado. Digite ~cat slurm-número.do.job.out~, obviamente substituindo o ~número.do.job~ pelo número que aparece em seu ~ls~. Esse comando cat joga para a tela o conteúdo do arquivo, você deve visualizar algo semelhante ao mostrado na tela abaixo:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/job-jupyter.PNG]]

Abram no seu navegador o link apresentado, no caso da imagem é o http://172.20.10.15:8888/?token=eb81db62cffaa91eba1b2f6ec37bd51dcf789cc3d7cca3da, no caso de vocês o token será diferente, pois ele é único para cada sessão. Vocês devem visualizar algo semelhante a imagem abaixo:
#+ATTR_ORG: :width 300
#+ATTR_HTML: width="300px"
[[file:img/jupyter-browser.png]]

Este é o Jupyter puro, não o Jupyter-Lab que vocês costumam utilizar em aula, mas a parte que executará o Notebook é igual a que vocês utilizam no Jupyter-Lab. Perfeito, agora podemos fazer upload do Jupyter Notebook do capítulo 9 para a Heisenberg, utilizando o próprio Jupyter. Bom, primeiro faça o download do Jupyter Notebook da atividade do Capítulo 9 para seu computador, depois na sua janela do browser do Jupyter clique no botão ~Upload~ (fica na parte direita superior, não no topo mas um pouco abaixo dos botões ~Quit~ e ~Logout~). Após fazer o upload, basta abrir o Notebook e vamos começar a fazer os cálculos :)

* Dicionários
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_dicionarios
:EXPORT_OPTIONS: toc:t
:ID:       982992c4-400b-4d79-a738-e86116b14ebc
:END:

** Associando objetos com dicionários

Dicionários são mais uma maneira de guardarmos informações, que pode ser bastante interessante para organização. Vamos dar um exemplo que já foi tratado nesse curso, as listas de compras. Lembram do nosso miojo incrementado, os itens para comprar na papelaria e os da padaria para fazer o misto quente? Estavamos os guardando em listas de listas, mas, podemos os guardar em dicionários também e com uma melhor organização. Vamos para um exemplo onde mostramos a sintaxe e a estrutura dos dicionários:

#+begin_src python
  #Iniciamos a definição do dicionário
  dicionariodecompras = {
    "mercado": ["Miojo", "Ovo", "Orégano", "Papel Higiênico"],	#Definimos a primeira chave do dicionário, com seu valor associado, que no caso é uma lista
    "padaria": ["Pão", "Queijo", "Presunto"],			#Definimos a segunda chave e seu valor
    "papelaria": ["Caderno", "Caneta", "Lápis"],			#Terceira chave e valor definidos
  }	# Término do dicionário

  #Imprimimos o dicionário todo
  print(dicionariodecompras)

  #Imprimimos apenas uma chave do dicionário
  print(dicionariodecompras['mercado'])
  print(dicionariodecompras['padaria'])
  print(dicionariodecompras['papelaria'])
#+end_src

#+RESULTS:
: {'mercado': ['Miojo', 'Ovo', 'Orégano', 'Papel Higiênico'], 'padaria': ['Pão', 'Queijo', 'Presunto'], 'papelaria': ['Caderno', 'Caneta', 'Lápis']}
: ['Miojo', 'Ovo', 'Orégano', 'Papel Higiênico']
: ['Pão', 'Queijo', 'Presunto']
: ['Caderno', 'Caneta', 'Lápis']

Notem a sintaxe, os dicionários ficam entre chaves ={ }=, assim como os conjuntos, então cuidado, pois isso pode trazer ambiguidades no código, por exemplo para inicializar um conjunto vazio. Na definição interna do dicionário temos a seguinte sintaxe: ="chave": valor=, onde as chaves vão funcionar como se fossem índices do dicionário, e os valores são os itens associados a chave. No exemplo acima definimos cada chave como uma string e cada valor como uma lista, convenientemente organizadas. Os valores dos dicionários não precisam ser listas, podem ser números ou strings, e podemos misturar diferentes tipos de chaves (umas sendo strings e outras sendo números, por exemplo). Vamos a mais um exemplo para ilustrar isto:

#+begin_src python
  print(aluno)
  print(
      aluno["Nome"], "teve as seguintes notas:",
      aluno["Nota 1"], aluno["Nota 2"], aluno["Nota 3"],
      "com média final",
      (aluno["Nota 1"] + aluno["Nota 2"] + aluno["Nota 3"]) / 3,
  )
#+end_src

#+RESULTS:

*[A]* Note que o código acima não irá funcionar, pois o dicionário aluno e suas notas não foram definidas. Portanto, defina o dicionário aluno com as chaves "Nota 1", "Nota 2" e "Nota 3", então use o código acima para exibir o dicionário as notas e a média.

*[B]* Faça um novo dicionário que não possua as notas uma a uma, mas apenas em uma chave "Notas", com uma lista que agrupe todas as notas. Adapte o código para exibir as notas e média, sendo feito a partir da lista da chave "Notas".

** Métodos de dicionários

Assim como listas e conjuntos, os dicionários também possuem métodos associados. Como sempre os métodos facilitam a vida na programação, por fazer diretamente uma função que poderia ser extensa de implementar. Abaixo os principais métodos de dicionários são apresentados:

+ keys: Retorna um iterável (similar a uma lista) contendo todas as chaves do dicionário. Sintaxe: dicionario.keys()
+ get: Retorna o valor da chave especificada. Sintaxe: dicionario.get("chave"). É similar a fazer ~dicionario["chave"]~
+ items: Retorna um iterável (similar a uma lista) contendo uma tupla para cada par chave-valor. Sintaxe: dicionario.items()
+ values: Retorna um iterável (similar a uma lista) com todos os valores no dicionário. Sintaxe: dicionario.values()
+ update: Insere um par chave-valor no dicionário. Sintaxe: dicionario.update({"chave": "valor"}). É similar a fazer ~dicionario["chave"] = "valor"~
+ pop: Assim como já visto em listas e conjuntos,

*[A]* Defina um dicionário com pelo menos três chaves, pelo menos uma das chaves deve conter uma lista com pelo menos três elementos. A partir do dicionário definido, itere em um loop ~for~, em todos os elementos da chave que possui uma lista, exibindo cada elemento.

*[C]* Assim como feito em [B], itere em um loop ~for~ para todos elementos da chave com lista, desta vez crie um condicional que faça um teste, que caso seja verdadeiro um novo par chave-valor será inserido no dicionário.

** Dicionários aninhados

Podemos criar dicionários aninhados, ou seja, dicionários dentro de dicionários. Vamos utilizar o exemplo dos alunos para criar uma lista de alunos com diferentes atributos:

#+begin_src python
  alunos = {
      1: {
          "Nome": "João da Silva Sauro",
          "Notas": [8.0, 8.5, 10.0],
          "Faltas": 2,
          "Participação": 8.0,
          "Trabalho Final": 7.0,
      },
      2: {
          "Nome": "Maria das Graças",
          "Notas": [9.0, 9.5, 10.0],
          "Faltas": 0,
          "Participação": 9.0,
          "Trabalho Final": 7.5,
      },
      3: {
          "Nome": "Cabra da Peste",
          "Notas": [9.5, 8.5, 9.0],
          "Faltas": 4,
          "Participação": 0.0,
          "Trabalho Final": 8.0,
      },
  }
#+end_src

#+RESULTS:

*[A]* Com esse dicionário, escreva um código que itere entre cada aluno e cada chave do aluno. Por exemplo, para o terceiro aluno seu código deverá exibir algo semelhante a isto:

#+begin_example
Número do aluno: 3
Nome: Cabra da Peste
Notas: [9.5, 8.5, 9.0]
Faltas: 4
Participação: 0.0
Trabalho Final: 8.0
#+end_example

*[B]* Escreva um código que calcule a média final de cada aluno, sendo composta de:

NF=( (<Notas> + Trabalho Final)/2 ) + 0.15*Participação

Note que ~<Notas>~ é a média da chave ~Notas~.
Além de exibir as médias finais, o código deve exibir se cada aluno está aprovado ou reprovado.

* Strings e processamento de texto
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_strings
:EXPORT_OPTIONS: toc:t
:ID:       6feb275c-31de-49dd-87a1-d3576f4dbfc2
:END:

** Agrupando caracteres com strings

Já vimos que strings são objetos que armazenam texto e que para declarar strings usamos aspas simples ou aspas duplas. Texto nada mais é do que uma lista de zero ou mais caracteres. Assim como listas, podemos segmentar strings usando a notação dos índices dentro de colchetes. Veja no exemplo abaixo.

#+begin_src python -n
  string_com_zero_letras = ""
  string_com_uma_letra = "a"
  string_com_varias_letras = "abcdefghijklmnopqrstuvwxyz"

  print(string_com_varias_letras[0])
  print(string_com_varias_letras[1])
  print(string_com_varias_letras[2])

  print(string_com_varias_letras[3:8])
  print(string_com_varias_letras[8:])

  print(string_com_varias_letras[::2])
#+end_src

#+RESULTS:
: a
: b
: c
: defgh
: ijklmnopqrstuvwxyz
: acegikmoqsuwy

Como strings são listas de letras, também podemos usar o ~for~ da mesma maneira que usamos em listas! Veja no exemplo abaixo.

#+begin_src python -n
  texto = "Bravo, Vince!"

  for letra in texto:
      print(letra)
#+end_src

#+RESULTS:
#+begin_example
B
r
a
v
o
,

V
i
n
c
e
!
#+end_example

É possível converter objetos que não são texto para texto usando a função ~str~.

#+begin_src python -n
  numero = 1234
  texto_a_partir_do_numero = str(1234)

  print(numero)
  print(texto_a_partir_do_numero)

  # agora que temos um texto, é fácil separar os digitos do número
  print(texto_a_partir_do_numero[0])  # este é o digito 1 do número 1234

  # note que essa sintaxe não funciona para variáveis numéricas (dá erro!)
  print(numero[0])
#+end_src

#+RESULTS:
: 1234
: 1234
: 1
: Variáveis numéricas não permitem usar a notação de índices com chaves
: 1234
: 1234

Também podemos converter texto contendo dígitos em variáveis numéricas usando as funções ~int~ e ~float~. Veja o exemplo abaixo:

#+begin_src python -n
  texto = "1234"
  numero_a_partir_do_texto = int(texto)

  print(texto)
  print(numero_a_partir_do_texto)

  # agora que temos um número, podemos fazer contas
  print(numero_a_partir_do_texto + 4321)

  # note que não podemos fazer contas com variáveis que são texto (dá erro!)
  print(texto + 4321)

#+end_src

#+RESULTS:
: 1234
: 1234
: 5555

Podemos multiplicar strings por um número natural e podemos somar strings com strings!

#+begin_src python -n
  nome = "Penny! "
  chamando_penny = nome * 3
  print(chamando_penny)

  metade1 = "comp"
  metade2 = "leto"
  palavra = metade1 + metade2
  print(palavra)
#+end_src

#+RESULTS:
: Penny! Penny! Penny!
: completo

Uma diferença muito importante entre strings e listas é que strings são variáveis imutáveis (assim como tuplas) e listas são variáveis mutáveis. Isso significa que após uma string ser criada não é possível alterá-la!

*[A]* Faça uma função que recebe uma string qualquer e retorna um dicionário. As chaves do dicionário de retorno são caracteres e os valores são a quantidade de vezes que estes caracteres aparecem na string de entrada.

** Métodos condicionais de strings

Existem diversos métodos de strings. Você pode checar todos eles [[https://docs.python.org/3/library/stdtypes.html?highlight=startswith#text-sequence-type-str][na documentação oficial]]. Existem dois métodos para checar strings que são particularmente muito utilizados: o ~startswith~ e o ~endswith~. Como o próprio nome sugere, o ~startswith~ checa se sua string começa com uma certa sequência de caracteres e o ~endswith~ checa se sua string termina com uma certa sequência de caracteres. São, portanto, métodos excelentes para checar prexifos e sufixos de palavras!

#+begin_src python -n
  palavras = [
      "pato",
      "cachorro",
      "feldspato",
      "caolinita",
      "sapato",
      "tênis",
      "carrapato",
      "caranguejo",
      "empato",
      "capoto",
  ]

  palavras_que_terminam_em_pato = []
  for palavra in palavras:
      if palavra.endswith("pato"):
          palavras_que_terminam_em_pato.append(palavra)
  print(palavras_que_terminam_em_pato)

  palavras_que_comecam_em_ca = []
  for palavra in palavras:
      if palavra.startswith("ca"):
          palavras_que_comecam_em_ca.append(palavra)
  print(palavras_que_comecam_em_ca)
#+end_src

#+RESULTS:
: ['pato', 'feldspato', 'sapato', 'carrapato', 'empato']
: ['cachorro', 'caolinita', 'carrapato', 'caranguejo', 'capoto']

Outros métodos de strings bastante úteis são:

+ ~isnumeric~: retorna ~True~ se sua string é um valor numérico e ~False~ do contrário. Este método não recebe nenhum argumento.
+ ~isupper~: retorna ~True~ se sua string está escrita em caixa alta e ~False~ do contrário. Este método não recebe nenhum argumento.
+ ~islower~: retorna ~True~ se sua string está escrita em caixa baixa e ~False~ do contrário. Este método não recebe nenhum argumento.

#+begin_src python
  numero = "1234"
  caixa_alta = "AAAAHHHHH"
  caixa_baixa = "sussurrando..."

  print("Testando o método isnumeric")
  print(numero.isnumeric())
  print(caixa_alta.isnumeric())
  print(caixa_baixa.isnumeric())
  print()

  print("Testando o método isupper")
  print(numero.isupper())
  print(caixa_alta.isupper())
  print(caixa_baixa.isupper())
  print()

  print("Testando o método islower")
  print(numero.islower())
  print(caixa_alta.islower())
  print(caixa_baixa.islower())
  print()
#+end_src

#+RESULTS:
#+begin_example
Testando o método isnumeric
True
False
False

Testando o método isupper
False
True
False

Testando o método islower
False
False
True

#+end_example

** Recebendo informações do usuário com a função ~input~

Se em algum momento você precisar receber informações do usuário, basta usar a função ~input~. Vamos ver um exemplo:

#+begin_src python -n
  nome = input("Qual é o seu nome?")
  missao = input("Qual é a sua missão?")
  velocidade = input("Qual é a velocidade de vôo de uma andorinha livre de carga?")

  print(nome)
  print(missao)
  print(velocidade)
#+end_src

Preste atenção que a informação recebida pelo comando ~input~ será sempre _convertida para uma string_. Então veja que caso o usuário digite um número, este será convertido para uma string! Tenha isso em mente caso venha a usar essa função.

** Alguns caracteres especiais

Existem duas formas de fazer uma string em múltiplas linhas. Uma delas é usando aspas triplas como nós já vimos:

#+begin_src python -n :session pyvenv
  string_com_multiplas_linhas = """Olá!
  Eu sou uma string com múltiplas linhas.
  Prazer!"""

  print(string_com_multiplas_linhas)
#+end_src

#+RESULTS:
: Olá!
: Eu sou uma string com múltiplas linhas.
: Prazer!

Outra forma é escrevendo ~\n~ para simbolizar uma quebra de linha:

#+begin_src python -n :session pyvenv
  string_com_multiplas_linhas_2 = "Olá!\nEu sou uma string com múltiplas linhas.\nPrazer!"

  print(string_com_multiplas_linhas_2)
#+end_src

#+RESULTS:
: Olá!
: Eu sou uma string com múltiplas linhas.
: Prazer!

Qual destas duas estratégias é a melhor? Tanto faz, use a que julgar mais interessante. As duas retornam exatamente a mesma string como pode ser checado com o operador de comparação abaixo.

#+begin_src python :session pyvenv
  print(string_com_multiplas_linhas == string_com_multiplas_linhas_2)
#+end_src

#+RESULTS:
: True

Outro caractere especial que vale a pena mencionar é o ~\t~ que serve para incluir uma tabulação horizontal (costumeiramente chamado de "tab").

#+begin_src python -n
  tabulacao = """Ano\tConsumo de pipoca
  2017\t9
  2018\t6
  2019\t7
  2020\t13
  2021\t12
  2022\t11"""

  print(tabulacao)
#+end_src

#+RESULTS:
: Ano	Consumo de pipoca
: 2017	9
: 2018	6
: 2019	7
: 2020	13
: 2021	12
: 2022	11

Mas... e se eu quero escrever uma barra invertida (~\~) no meu texto? Daí fica difícil com esses caracteres especiais atrapalhando! Neste caso, você tem duas opções. A primeira é escrever ~\\~. A segunda é usar uma /string bruta/ (/raw/, em inglês), para isso basta acrescenta um ~r~ no início da string, antes das aspas e sem espaço. Vamos ver um exemplo.

#+begin_src python
  barra_invertida_tecnica_1 = "C:\\trabalhos\\nova pasta\\praticas_cap_10.ipynb"
  barra_invertida_string_bruta = r"C:\trabalhos\nova pasta\praticas_cap_10.ipynb"

  print(barra_invertida_tecnica_1)
  print(barra_invertida_string_bruta)

  print()

  # exemplo de uso errado
  barra_invertida_deu_ruim = "C:\trabalhos\nova pasta\praticas_cap_10.ipynb"
  print(barra_invertida_deu_ruim)
#+end_src

#+RESULTS:
: C:\trabalhos\nova pasta\praticas_cap_10.ipynb
: C:\trabalhos\nova pasta\praticas_cap_10.ipynb
:
: C:	rabalhos
: ova pasta\praticas_cap_10.ipynb

Para mais informações sobre carateres especiais consulte a [[https://docs.python.org/pt-br/3.9/reference/lexical_analysis.html#string-and-bytes-literals][documentação oficial]].

** Formatação de texto

Muitas vezes queremos exibir para o usuário uma informação contida em uma variável junto com um texto. Por exemplo:

#+begin_src python
  seu_nome = "Feiticeira Escarlate"
  meu_nome = "Visão"

  print("Olá,", seu_nome, ". Eu me chamo", meu_nome, ". Prazer!")
#+end_src

#+RESULTS:
: Olá, Feiticeira Escarlate . Eu me chamo Visão . Prazer!

As f-strings nos ajudam justamente nisso! Vamos ver o exemplo anterior usando f-strings.

#+begin_src python
  seu_nome = "Feiticeira Escarlate"
  meu_nome = "Visão"

  print(f"Olá, {seu_nome}. Eu me chamo {meu_nome}. Prazer!")
#+end_src

#+RESULTS:
: Olá, Feiticeira Escarlate. Eu me chamo Visão. Prazer!

Para usar uma f-string, basta colocar a letra ~f~ na frente das aspas da sua string (sem dar espaço!). Em uma f-string, você pode referenciar uma variável dentro de colchetes e ela será incorporada na sua string. Simples assim.

F-strings são bastante poderosas. Existem diversos "truques" que podemos fazer com elas! Como sempre, a [[https://docs.python.org/pt-br/3.9/reference/lexical_analysis.html#f-strings][documentação oficial]] está lá para nos ajudar. Veja no exemplo abaixo uma seleção de possíveis configurações para sua f-string.

#+begin_src python
  from math import pi

  tau = 2 * pi

  print(f"O valor de pi é: {pi}")
  print()

  print(f"O valor de pi com cinco algarismos significativos é: {pi:.5}")
  print()

  print(f"O valor de pi com apenas duas casas decimais é: {pi:.2f}")
  print()

  # nome e valor de uma variável
  print(f"{tau = }")
  print()

  # executando operações dentro dos colchetes
  print(f"Tau é maior que pi? {tau > pi}")
  print()

  print(f"Converter um número para porcentagem com duas casas decimais: {(1/3):.2%}")
  print()

  # combinando execução com exibição
  print(f"{tau * 2 = }")
  print()

  print(f"Para exibir colchetes dentro de f-strings use eles dobrados. {{Desta forma!}}. O valor de pi é {pi}.")

#+end_src

#+RESULTS:
#+begin_example
O valor de pi é: 3.141592653589793

O valor de pi com cinco algarismos significativos é: 3.1416

O valor de pi com apenas duas casas decimais é: 3.14

tau = 6.283185307179586

Tau é maior que pi? True

Converter um número para porcentagem com duas casas decimais: 33.33%

tau * 2 = 12.566370614359172

Para exibir colchetes dentro de f-strings use eles dobrados. {Desta forma!}. O valor de pi é 3.141592653589793.
#+end_example

Existem duas outras maneiras de formatar uma string, porém elas não são mais recomendadas para uso geral e sim para casos muito específicos. Vale a pena saber que elas existem:

+ *%-strings*: leia sobre isso na [[https://docs.python.org/pt-br/3.9/library/stdtypes.html#printf-style-string-formatting][documentação oficial]]. Essa é a uma excelente forma para se formatar strings contendo códigos em LaTeX pois estes códigos contém muitos colchetes. No entanto, este método deve ser evitado caso possível. Diversos textos mais antigos ainda ensinam esse método pois as f-strings são uma invenção mais recente.

+ *método format*: leia sobre isso na [[https://docs.python.org/pt-br/3.9/library/stdtypes.html#str.format][documentação oficial]]. Não apresenta muita vantagem perante as f-strings. Uma pequena vantagem é quando queremos formatar uma string em várias posições com a mesma variável. Outra vantagem do método ~format~ é que ele é uma função, logo é um objeto de Python e pode ser utilizado como argumento de outras funções caso necessário. Ambos os casos atendem situações bastante específicas e não muito usuais.

*[A]* Faça um programa que recebe o nome do usuário pelo comando ~input~. Usando f-strings, inicie uma conversa chamando o usuário pelo nome dele e pergunte a sua cor favorita. Se a cor favorita do usuário começar com a letra "v", diga para ele que ele tem muito bom gosto. Do contrário, diga que hoje é um belo dia e deseje boa sorte na sua jornada.

** Processamento de texto

Podemos processar strings alterando a caixa de seus caracteres.

#+begin_src python
  texto = "Obrigado Mario! Mas a nossa princesa está em outro castelo..."

  # Apenas a primeira letra escrita com maiúscula
  print(texto.capitalize())

  # As primeiras letras de todas as palavras escritas com maiúsculas
  print(texto.title())

  # Todas as letras minúsculas
  print(texto.lower())

  # Todas as letras maiúsculas
  print(texto.upper())

  # Inverte a caixa das letras
  print(texto.swapcase())
#+end_src

#+RESULTS:
: Obrigado mario! mas a nossa princesa está em outro castelo...
: Obrigado Mario! Mas A Nossa Princesa Está Em Outro Castelo...
: obrigado mario! mas a nossa princesa está em outro castelo...
: OBRIGADO MARIO! MAS A NOSSA PRINCESA ESTÁ EM OUTRO CASTELO...
: oBRIGADO mARIO! mAS A NOSSA PRINCESA ESTÁ EM OUTRO CASTELO...

Podemos substituir certas partes de uma string por outras.

#+begin_src python
  texto = "Eu gosto de acarajé."

  print(texto.replace("gosto de", "aprecio"))
  print(texto.replace("gosto de", "adoro"))
  print(texto.replace("gosto de", "amo"))
  print(texto.replace("gosto de", "acredito que todas as refeições poderiam ter"))
#+end_src

#+RESULTS:
: Eu aprecio acarajé.
: Eu adoro acarajé.
: Eu amo acarajé.
: Eu acredito que todas as refeições poderiam ter acarajé.

Mas lembre-se que strings são imutáveis! Então quando usamos os métodos não estamos alterando as strings originais, mas sim criando strings novas.

#+begin_src python
  texto1 = "Seu nome é Jackie, Jackie Tequila"

  texto2 = texto1.upper()

  print(texto1)  # esta variável não foi alterada!
  print(texto2)
#+end_src

#+RESULTS:
: Seu nome é Jackie, Jackie Tequila
: SEU NOME É JACKIE, JACKIE TEQUILA

Uma parte importante do processamento de strings é a habilidade de dividir uma string longa e partes menores. Podemos fazer isso com o método ~split~. Este método recebe uma string como argumento e retorna uma lista. O argumento de entrada é o separador, ele que será usado para "dividir" sua string original. Vamos ver um exemplo.

#+begin_src python
  mini_historia_de_terror = "O último ser vivo do planeta estava na sua casa, sozinho. De repente, alguém bateu na sua porta."

  palavras = mini_historia_de_terror.split(" ")

  print(palavras)
  print(f"O texto tem {len(palavras)} palavras")

  frases = mini_historia_de_terror.split(".")
  print(frases)
  print(f"O texto tem {len(frases)} frases? ... acho que não!")
#+end_src

#+RESULTS:
: ['O', 'último', 'ser', 'vivo', 'do', 'planeta', 'estava', 'na', 'sua', 'casa,', 'sozinho.', 'De', 'repente,', 'alguém', 'bateu', 'na', 'sua', 'porta.']
: O texto tem 18 palavras
: ['O último ser vivo do planeta estava na sua casa, sozinho', ' De repente, alguém bateu na sua porta', '']
: O texto tem 3 frases? ... acho que não!

O método "oposto" ao ~split~ é o ~join~. Este método recebe uma lista de strings e agrupa elas. O exemplo abaixo ilustra a utilização desse método.

#+begin_src python
  lista = [
      "O",
      "último",
      "ser",
      "vivo",
      "do",
      "planeta",
      "estava",
      "na",
      "sua",
      "casa,",
      "sozinho.",
      "De",
      "repente,",
      "alguém",
      "bateu",
      "na",
      "sua",
      "porta.",
  ]

  cola = " "
  tudo_junto = cola.join(lista)
  print(tudo_junto)
  print()

  cola = "_"
  tudo_junto2 = cola.join(lista)
  print(tudo_junto2)
  print()

  cola = "👏"
  tudo_junto3 = cola.join(lista)
  print(tudo_junto3)
  print()

  cola = "*_ . _*"  # a cola pode ser o que você quiser
  tudo_junto4 = cola.join(lista)
  print(tudo_junto4)
#+end_src

#+RESULTS:
: O último ser vivo do planeta estava na sua casa, sozinho. De repente, alguém bateu na sua porta.
:
: O_último_ser_vivo_do_planeta_estava_na_sua_casa,_sozinho._De_repente,_alguém_bateu_na_sua_porta.
:
: O👏último👏ser👏vivo👏do👏planeta👏estava👏na👏sua👏casa,👏sozinho.👏De👏repente,👏alguém👏bateu👏na👏sua👏porta.
:
: O*_ . _*último*_ . _*ser*_ . _*vivo*_ . _*do*_ . _*planeta*_ . _*estava*_ . _*na*_ . _*sua*_ . _*casa,*_ . _*sozinho.*_ . _*De*_ . _*repente,*_ . _*alguém*_ . _*bateu*_ . _*na*_ . _*sua*_ . _*porta.

*[A]* Escolha uma notícia de jornal que tenha mais de 500 palavras. Crie uma string com o texto desta notícia (_dica_: strings com três aspas permitem texto com mais de uma linha!). Seu objetivo é processar este texto e mostrar quais são as 10 palavras mais usadas nele. Use apenas funções, módulos e estruturas de dados embutidos de Python para resolver esta questão (em outras palavras, não use nada de bibliotecas externas aqui).

*[B]* Faça uma função que recebe uma string qualquer e retorna uma lista contendo todos os números presentes na sua string. Por exemplo, se a função receber a string "Hoje fazem 2 dias que eu fiz 65 anos." ela deve retornar a lista "[2, 65]".

*[C]* Faça uma função que recebe uma string e checa se ela é um palíndromo. Palíndromos são palavras que não se alteram mesmo quando a ordem das suas letras é invertida. Exemplos de palíndromos: rir, salas, rever, sopapos e arara.

*[Desafio]* Faça uma função que recebe uma string contendo uma frase. A função deve retornar uma string contendo as mesmas palavras, porém invertidas. Por exemplo, caso a função receba a string "Ser ou não ser eis a questão" ela retorna "reS uo oãn res sie a oãtseuq".

** Expressões regulares :noexport:

Expressão regular (também conhecidas como regex que vem da expressão em inglês /regular expression/)

* Aula de problemas :noexport:

*[A]* Crie uma função que recebe um array 3 $\times$ 4. Este array representa a matriz de um sistema linear de equações com 3 equações e 3 incógnitas (veja o exemplo abaixo). A função deve checar se o sistema tem solução única. Em caso positivo, utilize o método de eliminação de Gauss para resolver o sistema e retorne para o usuário um array de 1 dimensão com os 3 valores da solução. Teste seu algoritmo com o array abaixo. Se seu algoritmo estiver correto, a resposta para esse sistema deve ser [2, 3, -1]. _Nota_: não precisamos dizer que não é permitido usar uma função pronta do ~numpy~ (ou de qualquer outra biblioteca) que resolve sistemas lineares, não é? [Problema sugerido pelo Prof. Vinicius]

\begin{cases}
2x+y-z & =8\\
-3x-y+2z & =-11\\
-2x+y+2z & =-3
\end{cases}

#+begin_src python -n :session pyvenv
  teste = np.array(
      [
          [2, 1, -1, 8],
          [-3, -1, 2, -11],
          [-2, 1, 2, -3],
      ]
  )
#+end_src

*[B]* Considere a série de Taylor da função exponencial ($e^x$) com $x_0=0$. Faça três gráficos do erro da série de Taylor em função no número de termos da série, cada gráfico deve ser feito para um valor de $x$ diferente. Calcule o erro considerando o retorno da função ~exp~ do módulo ~math~ ou ~numpy~. [Problema sugerido pelo Prof. Vinicius]

* Depuração de programas :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_debug
:EXPORT_OPTIONS: toc:t
:ID:       a822fa0b-e43c-4dc6-99f4-0f4f8a2e97fc
:END:

** Meu programa não roda pois dá um erro, e agora?

#+begin_quote
"YOU DIED" --- Dark Souls
#+end_quote

Existem diversas formas em que algo pode dar errado, e isso /não/ é diferente em programação. Idealmente queremos que nosso código rode e nada dê errado, mas se algo estiver errado é sempre bom que sejamos avisados para poder pelo menos tentar consertar. É exatamente isso que acontece quando o Python exibe uma mensagem de erro! Ele está te avisando que algo estranho aconteceu e precisa ser resolvido antes de prosseguir. Veja o código abaixo.

#+begin_src python -n
  def divisao(x, y):
      """Divide o primeiro valor pelo segundo."""
      return x / y


  print(divisao(100, 0))
#+end_src

#+RESULTS:

Se tentar rodar esse código no JupyterLab, você verá uma mensagem similar a mensagem abaixo:

#+begin_src python -n
  ---------------------------------------------------------------------------
  ZeroDivisionError                         Traceback (most recent call last)
  /tmp/ipykernel_8712/570243516.py in <module>
        4
        5
  ----> 6 print(divisao(100, 0))

  /tmp/ipykernel_8712/570243516.py in divisao(x, y)
        1 def divisao(x, y):
        2     """Divide o primeiro valor pelo segundo."""
  ----> 3     return x / y
        4
        5

  ZeroDivisionError: division by zero
#+end_src

Se você nunca tinha visto uma mensagem dessas, meus parabéns! Esta é uma mensagem de erro e seu objetivo é informar quem executou o código que algo errado aconteceu. Veja que logo no início da mensagem de erro conseguimos identificar o tipo do erro: ~ZeroDivisionError~ que significa que uma divisão por zero aconteceu em algum lugar. Mas onde isso aconteceu? Logo abaixo do nome do erro temos um ~---->~ na linha 6, indicando qual instrução estava rodando quando o problema foi encontrado. Essa instrução tem duas funções: ~print~ e ~divisao~. O erro em si poderia ter ocorrido em qualquer uma delas, mas na linha 8 fica claro que o erro ocorreu na função ~divisao~. Mais abaixo encontramos um segundo ~---->~ que finalmente mostra onde que o erro efetivamente aconteceu! Foi na divisão de ~x~ por ~y~! Nós passamos o valor ~y=0~ quando executamos a função ~divisao~ e isso resultou em uma divisão por zero!

Saber ler as mensagens de erro é tão importante quanto saber programar em si. É muito fácil cometer pequenos erros durante a escrita de qualquer código. Quanto mais código você escrever mais chances tem de errar! Como vemos corriqueiramente nas notícias, mesmo programadores experientes de grandes empresas cometem erros! Afinal, errar é humano! Entender o erro e conseguir consertá-lo é uma habilidade que se ganha com prática, então aproveite cada mensagem de erro para afinar suas habilidades!

*[A]* Todos os blocos de código abaixo resultam em um erro quando executados. Execute-os, identifique o erro, escreva uma breve explicação sobre o que o erro significa (busque na documentação do Python) e reescreva cada bloco de código para que ele execute sem erros.

#+begin_src python -n
  piratas = {
      "Ruffy": "Homem borracha",
      "Zoro": "Espadachim",
      "Nami": "Navegadora",
      "Sanji": "Cozinheiro",
  }

  print(piratas["Ussop"])
#+end_src

#+RESULTS:

#+begin_src python -n
  filmes = [
      "Meu vizinho Totoro",
      "Nausicaä no país dos ventos",
      "Princesa Mononoke",
  ]

  print(filmes[4])
#+end_src

#+RESULTS:

#+begin_src python -n
  soma = "4" + 2
#+end_src

#+RESULTS:

#+begin_src python -n
  valor = int('abc')
#+end_src

#+RESULTS:

#+begin_src python -n
  print(abcdefghij)
#+end_src

#+RESULTS:

#+begin_src python -n
  for n in [1, 2, 3]:
  print(n)
#+end_src

#+RESULTS:

** Tratamento de exceções

#+begin_quote
"/Fazer ou não fazer. Tentativa não há./" --- Mestre Yoda
#+end_quote

Vimos na seção anterior que quando um erro é identificado durante a execução de um código, o erro é exibido ao usuário e o programa interrompe imediatamente a sua execução. Entretanto, em certos casos nós gostaríamos que o programa não interrompesse sua execução ao encontrar um erro. Esse comportamente é possível em Python com as instruções ~try~/~except~ e o nome dessa estratégia é /tratamento de exceções/. Veja um exemplo abaixo.

#+begin_src python -n
  def divisao(x, y):
      """Divide o primeiro valor pelo segundo."""
      return x / y


  try:
      print(divisao(100, 10))
      print(divisao(100, 2))
      print(divisao(100, 0))
      print(divisao(100, -1))

  except ZeroDivisionError:
      print("Ocorreu uma divisão por zero durante a execução do código!")

  print("FIM")
#+end_src

#+RESULTS:
: 10.0
: 50.0
: Ocorreu uma divisão por zero durante a execução do código!
: FIM

Neste exemplo, um bloco ~try~ é declarado na linha 6. "Try" vem do verbo tentar em inglês e pode ser traduzido como "tente" neste contexto. O Python irá tentar executar todos os comandos dentro do bloco ~try~ normalmente (note que os comandos do bloco ~try~ devem ser indentados!). Caso alguma instrução dentro do bloco ~try~ acuse um erro, a execução do bloco ~try~ é interrompida e o erro é "capturado", isto é, o tipo do erro é armazenado na memória. Este erro capturado é então comparado com todos os erros declarados nos blocos ~except~ seguintes do bloco ~try~ ("except" significa "exceto" em português). Neste caso temos apenas um bloco ~except~ na linha 12, e ele corresponde ao erro do tipo ~ZeroDivisionError~. Se existir um bloco ~except~ correspondente ao erro capturado, então as instruções deste bloco são executadas e a execução do programa não para! Se não existir um bloco ~except~ correspondente ao erro capturado, então a execução do programa para e o erro é exibido ao usuário da mesma forma que vimos na seção anterior. Execute o código acima e veja o que acontece.

Podemos criar instruções ~try~/~except~ complexas considerando diversos tipos de erros diferentes. Quando um bloco ~except~ deve identificar mais de um tipo de erro, então é necessário agrupar todos os erros em parênteses (ver linha 7 no código abaixo). Podemos escrever quantos blocos ~except~ desejarmos para um mesmo bloco ~try~ (veja as linhas 10 e 13 abaixo).

#+begin_src python -n
  try:
      print("4" + 2)
      print(abcdefghij)
      print(1 / 0)
      print(int("abc"))

  except (ZeroDivisionError, TypeError):
      print("Tente não dividir por zero e se atente aos tipos das variáveis!")

  except ValueError:
      print("Tem algum valor inválido aí! Tome cuidado!")

  except NameError:
      print("Você tem certeza que definiu todas as suas variáveis?")

  print("FIM")
#+end_src

#+RESULTS:
: Tente não dividir por zero e se atente aos tipos das variáveis!
: FIM

O bloco ~try~ também admite duas outras instruções: ~else~ e ~finally~. A instrução ~else~ é apenas executada se o bloco ~try~ é executado até o fim, sem que haja nenhum erro! A instrução ~finally~ é sempre executada ao final do bloco ~try~, independente do que aconteceu (ela é executada mesmo caso um erro não contemplado pelas instruções ~except~ ocorra!). Veja um exemplo abaixo.

exemplo

Como você pode perceber, o tratamento de exceções em Python é bastante poderoso e nos permite um enorme controle sobre a execução do código. Além disso, este não é um processo computacionalmente custoso[fn:: Mas cuidado! Tratamento de exceções pode ser computacionalmente custoso em outras linguagens de programação. É sempre bom se informar antes!]. Desta forma, diversos programadores avançados de Python recomendam fortemente o uso do tratamento de exceções com a estratégia "faça primeiro e peça desculpas depois". Um exemplo desta estratégia é ilustrado no código abaixo. Neste código, digamos que não sabemos se a variável ~pode_ser_uma_lista~ é uma lista. No bloco ~try~ nós /assumimos/ que esta variável é uma lista e seguimos em frente. Caso ela não seja, nós "pedimos desculpas" no bloco ~except~ e realizamos uma conversão da variável em lista (linha 7).

#+begin_src python -n
  pode_ser_uma_lista = 10

  try:
      pode_ser_uma_lista.append(20)

  except AttributeError:
      pode_ser_uma_lista = [pode_ser_uma_lista]
      pode_ser_uma_lista.append(20)

  print(pode_ser_uma_lista)
#+end_src

#+RESULTS:
: [10, 20]

Se nenhum tipo de erro é declarado no bloco ~except~ então este bloco passa a ser executado caso _qualquer erro ocorra_ durante a execução do bloco ~try~! Isso pode parecer conveniente, mas não se deixe enganar: é melhor declarar explicitamente todos os erros que devem ser tratados do que aceitar _qualquer_ erro. Isto pois existem muitos tipos de erros que podem ocorrer durante a execução do seu código, juntar todos os erros "num mesmo saco" aumenta muito a chance de seu código não se comportar da forma como você gostaria. Blocos ~except~ sem declaração do tipo do erro são altamente desencorajados.

** Meu programa não faz o que eu queria que ele fizesse, e agora?

#+begin_quote
"Em última análise, é o desejo, não o desejado, que nós amamos." --- Friedrich Nietzsche
#+end_quote

Muitas pessoas ficam chateadas quando seu código exibe um erro ao ser executado... isso é normal. Mas veja pelo lado positivo: quando um erro é exibido você /sabe/ que tem algo de errado e tem a oportunidade de corrigir! Um problema que usualmente é /muito/ mais complicado é quando seu código roda sem erros, porém não faz o que você gostaria que ele fizesse...

Se esse é seu problema, a técnica mais fundamental de todas é checar linha por linha do seu código em busca do problema. Será que você esqueceu um operador em algum lugar? Será o valor de uma variável foi alterado em uma função sem que você tenha percebido? Será que faltou atualizar uma variável booleana? São tantas possibilidades do que pode dar errado que é impossível listar todas elas aqui. É necessário entender bem o propósito de seu código e entender bem todas linhas de instruções do mesmo para conseguir avaliar onde está o problema. Chamamos de _depuração_ ou _debug_ a busca por erros (também chamados de /bugs/) no código.

A técnica de /depuração linha por linha/ pode ser utilizada sempre, porém a energia gasta nessa tarefa aumenta com o número de linhas de código que devem ser avaliadas. Além disso, esta técnica exige que você tenha todas as informações das variáveis na sua memória e literalmente "rode" o código na sua mente. Esta é uma habilidade bastante útil que se adquire ao longo do tempo. Uma forma mais "visual" de usar esta técnica é com a ferramenta online Python Tutor disponível em https://pythontutor.com/visualize.html#mode=edit.

Uma forma mais eficiente de depurar seu programa é restringir o local de busca. Vamos supor que seu código tenha três funções diferentes. Uma estratégia possível é testar cada uma destas funções isoladamente em busca de comportamentos fora do esperado (isso pode ser feito em uma nova célula de código no Jupyter). Se um comportamento fora do esperado for detectado, então restringimos a busca do erro, neste caso será restrito para o corpo da função que teve comportamento fora do esperado. Se a nova área de busca é razoávelmente pequena, a técnica de avaliação linha por linha pode ser utilizada, do contrário é interessante utilizar outras ferramentas.

Uma forma de encontrar erros em muitas linhas de código é a /depuração interativa/. Este tipo de depuração consiste em avaliar o comportamento do seu código durante a sua execução.

1) O código roda normalmente até atingir um /ponto de parada/ definido pelo usuário;
2) Ao atingir um ponto de parada, a execução do código cessa e o controle volta ao usuário;
   a. Nesta etapa, o usuário pode executar qualquer comando válido de Python (por isso que chamamos de /depuração interativa/);
   b. É usual executar comandos para checar valores e tipos de variáveis, bem como testar o comportamento de funções;
3) Após o término de todas as checagens desejadas, é necessário escolher o próximo passo:
   a. Se um erro foi identificado, podemos sair do modo de depuração com a instrução ~exit~ e corrigir o erro;
   b. Se o erro não foi identificado, podemos seguir em frente com a depuração. A instrução ~continue~ faz com que o código continue sua execução a partir do ponto que parou e só ira parar novamente se encontrar algum ponto de parada. A instrução ~step~ executa a próxima linha de código a partir do ponto de parada e para logo em seguida, devolvendo o controle ao usuário.

Pontos de parada em Python são declarados com a função ~breakpoint~ (lembre-se de incluir parênteses no final do nome da função para executá-la!).

Outra forma de depuração é a /depuração com mensagens de registro/. Nesta modalidade, incluímos instruções no nosso código cujo objetivo é mostrar alguma informação ao usuário durante a sua execução (que ocorre sem pausas). A estratégia mais simples é incluir instruções ~print~ ao longo do código para exibir informações críticas ao usuário como, por exemplo, mostrar o valor de uma variável e seu tipo. Apesar de ser bastante utilizada, esta estratégia com a instrução ~print~ não é recomendada pois ao final da depuração devemos excluir todas as instruções ~print~ que usamos para depurar o código (afinal, esta informação não é pertinente ao usuário final). A forma recomendada para realizar a depuração com mensagens de registro é utilizando o módulo embutido ~logging~, que veremos na seção de Biblioteca padrão.

Não se esqueça que é sempre possível buscar ajuda quando nos deparamos com problemas no nosso código! Releia a seção /Buscando ajuda/ caso queira refrescar a memória.

** Controle o erro para ele não controlar você

#+begin_quote
"/E o meu erro foi crer que estar ao seu lado, bastaria./" --- Meu Erro, Paralamas do Sucesso
#+end_quote

É possível comandar o Python a acusar um erro com a instrução ~raise~. A vantagem de /você/ programar quando um erro é acusado é que, quando bem usado, isso aumenta seu controle sobre o código que é executado e evita comportamentos que não são desejados. Por exemplo, digamos que você vá escrever uma função que calcula o logarítmo natural de um número real usando uma série de Taylor. A série de Taylor abaixo funciona para valores de $x$ que satisfaçam $0 < x \leq 2$. Neste caso não podemos permitir que o usuário use valores que não satisfaçam essa inequação. Veja como podemos implementar isso no exemplo abaixo.

\[ \ln(x) = \sum_{k=1}^{\infty} (-1)^{k+1} \frac{(x-1)^k}{k} \]

#+begin_src python -n
  def log_natural(x, num_elementos=10000):
      """Calcula o logaritmo natural do valor recebido.

      Args:
        x:
          Valor real maior que zero e menor ou igual a dois.
        num_elementos:
          Número de elementos a serem considerados na soma infinita da série de
          Taylor.

      Returns:
        Logarítmo natural de `x`.

      Raises:
        ValueError: ocorre caso o valor de x não satisfaça a inequação 0 < x <= 2.
      """

      if not (0 < x <= 2):
          raise ValueError("O valor de x deve ser maior que 0 e menor ou igual a 2!")

      soma = 0
      for k in range(1, num_elementos + 1):
          soma = soma + (-1) ** (k + 1) * (x - 1) ** k / k

      return soma


  print(log_natural(1))
  print(log_natural(2))
  print(log_natural(10))
  print(log_natural(-3))
#+end_src

#+RESULTS:
: 0.0
: 0.6930971830599583


Na linha 19 do código acima temos a instrução ~raise~ responsável por acusar o erro. Ela só é executada caso o valor de $x$ esteja fora do intervalo esperado (checado pelo ~if~ da linha 18). Como o erro neste caso tem a ver com o /valor/ de uma variável, o erro que deve ser acusado pelo ~raise~ é o ~ValueError~. Observe que podemos escrever uma mensagem personalizada para ajudar o usuário a corrigir o problema caso encontre esse erro durante seu uso do código.

Checar uma condição e acusar um erro caso esta condição seja falsa é uma estrutura bastante comum no início do corpo de funções. Afinal, assim que o corpo da função inicia sua execução nós temos acesso a todos os argumentos e já podemos checar se eles têm valores dentro do esperado. A instrução ~assert~ facilita esse tipo de checagem. Veja no exemplo abaixo o uso da instrução ~assert~ para realizar a mesma tarefa do exemplo anterior.

#+begin_src python -n
  def log_natural(x, num_elementos=10000):
      """Calcula o logaritmo natural do valor recebido.

      Args:
        x:
          Valor real maior que zero e menor ou igual a dois.
        num_elementos:
          Número de elementos a serem considerados na soma infinita da série de
          Taylor.

      Returns:
        Logarítmo natural de `x`.

      Raises:
        ValueError: ocorre caso o valor de x não satisfaça a inequação 0 < x <= 2.
      """

      assert 0 < x <= 2, "O valor de x deve ser maior que 0 e menor ou igual a 2."

      soma = 0
      for k in range(1, num_elementos + 1):
          soma = soma + (-1) ** (k + 1) * (x - 1) ** k / k

      return soma


  print(log_natural(1))
  print(log_natural(2))
  print(log_natural(10))
  print(log_natural(-3))
#+end_src

#+RESULTS:
: 0.0
: 0.6930971830599583


A sintaxe da instrução ~assert~ requer uma condição a ser checada logo após a instrução. Caso a condição retorne ~False~ o código é interrompido e acusa um ~AssertionError~. Caso queira exibir uma mensagem ao usuário para ajudá-lo a entender o que ocorre, escreva uma string e coloque ela após uma vírgula. A mensagem não é obrigatória mas altamente recomendada.

Uma forma mais fácil de entender a instrução ~assert~ é lendo ela como "assegure-se que". Na linha 18 do código acima podemos ler como "assegure-se que o valor de ~x~ é maior que zero e menor ou igual a dois, do contrário, exiba uma mensagem de erro ao usuário alertando ele que esse é um requerimento necessário para executar a função".
* TODO Programação orientada a objetos :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_classes
:EXPORT_OPTIONS: toc:t
:ID:       59343370-093c-4c7c-b549-9e102aed7b5b
:END:

** Agrupando objetos com classes
+ classes como um único objeto para tratar de dados e funções
+ sintaxe
+ instância
+ parâmetros
+ =self=

** Classes e seus métodos
** Métodos mágicos
+ dunders
+ __init__
+ __str__
+ __repr__

** Herança de classes

~isinstance~

* TODO Leitura e manipulação de dados com o módulo =pandas= :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_pandas
:EXPORT_OPTIONS: toc:t
:ID:       94937cb1-718d-4eee-a3be-611c4badeb4b
:END:

** Análise dos dados
+ Estatística descritiva
** Criando e exportando um DataFrame a partir de listas
+ Criando um dataframe usando listas de python
+ Exportar para csv
+ Exportar para xlsx

* TODO Graficando dados :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_graficos
:EXPORT_OPTIONS: toc:t
:ID:       5c9942b1-d397-4d59-9891-6f6bfee01809
:END:

** Graficando dados de um DataFrame
** Graficando dados usando =matplotlib=

* TODO Controle de versão usando =git= :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_git
:EXPORT_OPTIONS: toc:t
:ID:       7ec34a02-1c92-4a3f-940a-955daab7050f
:END:

* TODO Computação científica com =numpy= e =scipy= :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_numpy
:EXPORT_OPTIONS: toc:t
:ID:       fc29118f-e0b5-4816-9034-4a83e7b520b4
:END:
* TODO Álgebra simbólica com =sympy= :noexport:
* TODO Propagação de erros com =uncertainties= :noexport:
* TODO Tópicos avançados :noexport:
** Funções anônimas

#+begin_quote
/Não sei por que as pessoas estão tão interessadas em colocar os detalhes de sua vida privada em público; elas esquecem que a invisibilidade é um superpoder./ --- Banksy
#+end_quote

Existe uma outra forma de declarar funções em Python, utilizando a instrução ~lambda~. Funções declaradas desta forma são chamadas de /funções anônimas/, /funções em linha/ ou simplesmente /funções lambda/. A função ~ola~ abaixo pode ser escrita como uma função não-anônima (linha 1) ou anônima (linha 8). Ambas fazem a mesma tarefa.

#+begin_src python -n
  def ola():
      """Retorna a string `Olá!`."""
      return "Olá!"


  print(ola())

  ola = lambda: "Olá"

  print(ola())
#+end_src

Perceba que uma função anônima ocupa apenas uma linha e não tem o valor de retorno explícito: a instrução que está após o "~lambda:~" é o retorno.

Funções anônimas podem ter argumentos e estes são declarados após o ~lambda~ e antes do dois-pontos (veja a linha 8 do código abaixo). Se existir mais de um argumento, eles devem ser separados por vírgulas (linha 20 do código abaixo).

#+begin_src python -n
  def multiplica_por_100(x):
      """Multiplica o valor recebido por 100."""
      return x * 100


  print(multplica_por_100(2))

  multiplica_por_100 = lambda x: x * 100

  print(multplica_por_100(2))


  def divide_um_pelo_outro(x, y):
      """Divide o primeiro valor recebido pelo segundo."""
      return x / y


  print(divide_um_pelo_outro(20, 5))

  divide_um_pelo_outro = lambda x, y: x / y

  print(divide_um_pelo_outro(20, 5))
#+end_src

Nos exemplos acima nós armazenamos as funções anônimas em variáveis. Mesmo esta sintaxe sendo perfeitamente válida, a PEP 8 recomenda que isso _não seja feito_. Sempre que precisar declarar uma função com nome utilize a instrução ~def~. Fica a pergunta: para que servem funções anônimas? Funções anônimas são excelentes em situações onde precisamos de funções simples de uso único. Exemplos incluem certos argumentos das funções ~sorted~, ~filter~ e ~map~.

A função ~sorted~, por exemplo, é capaz de ordenar os números de uma lista. Quando ela é usada com seu argumento ~key~ padrão, a função ordena os elementos em ordem crescente. O argumento ~key~, se utilizado, deve ser uma função com apenas um argumento que será aplicado aos números da lista antes de ordená-los. Veja o exemplo abaixo. Na linha 3, a função ~sorted~ utiliza o argumento ~key~ padrão (pois não recebeu ele quando foi chamada) e retorna os valores da lista em ordem crescente. Na linha 5, a função ~sorted~ recebeu o argumento ~key~: neste caso é uma função anônima que retorna o valor absoluto do argumento recebido. Com isso, a função ~sorted~ primeiro aplica essa função anônima para cada elemento da lista, ordena a lista levando em conta estes novos elementos, e depois "converte" os elementos para seus valores originais. O resultado final é que os números foram ordenados levando em conta seu valor absoluto.

#+begin_src python -n
  lista = [0, 1, -2, 3, -4, 5, -6]

  print(sorted(lista))  # resulta em [-6, -4, -2, 0, 1, 3, 5]

  print(sorted(lista, key=lambda x: abs(x)))  # resulta em [0, 1, -2, 3, -4, 5, -6]
#+end_src

#+RESULTS:
: [-6, -4, -2, 0, 1, 3, 5]
: [0, 1, -2, 3, -4, 5, -6]

Apenas para deixar claro, o exemplo anterior usou uma função anônima para o argumento ~key~ pois é uma função simples de uso único. Entretanto, poderíamos também usar uma função declarada com a instrução ~def~ como mostra o código abaixo. Nesse caso, o uso de uma função anônima é preferível por facilitar a leitura do código.

#+begin_src python -n
  lista = [0, 1, -2, 3, -4, 5, -6]

  def absoluto(x):
      """Retorna o valor absoluto."""
      return abs(x)

  print(sorted(lista, key=absoluto))  # resulta em [0, 1, -2, 3, -4, 5, -6]
#+end_src

#+RESULTS:
: [0, 1, -2, 3, -4, 5, -6]
** Decoradores

* TODO Exercícios :noexport:

https://github.com/azl397985856/leetcode/blob/9afe2386ce804beb263f1d6b27a86af2ee2e0546/README.en.md
https://github.com/azl397985856/leetcode
https://github.com/haoel/leetcode
https://github.com/rougier/numpy-100/blob/master/100_Numpy_exercises.md
https://github.com/zhiwehu/100_plus_Python_Projects_Challenge
https://github.com/topics/python-exercises
https://github.com/zhiwehu/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises.txt
https://github.com/jerry-git/learn-python3

+ Computar numericamente a soma de uma PA ou PG
+ Checar os números divisíveis por 5 em uma lista
+ Contar quais são as palavras mais comuns em um texto
+ Dadas duas listas, montar uma terceira com os maiores números de cada (element-wise)
+ função que soma todos os números do 1 até o n
+ programa que conta quantos digitos existem em um numero inteiro
+ inverter a ordem de uma lista
+ programa que calcula o fatorial de um inteiro positivo
+ programa que cria uma lista apenas com os itens nas posições impares de uma lista original
+ função que conta quantas letras, dígitos e caracteres especiais tem em uma string
+ encontrar números em uma string e armazena-los em uma lista
+ histograma de valores em uma lista
+ separar valores e chaves de dicionários em duas listas
+ concatenar duas listas de string element-wise
+ Create a program that asks the user to enter their name and their age. Print out a message addressed to them that tells them the year that they will turn 100 years old.
+ use compreensão de lista para identificar números impares em uma lista
+ criar um jogo de jokenpo a ser jogado por duas pessoas
+ exercicio onde o computador escolhe um numero aleatorio e o usuario deve adivinhar com dicas de maior ou menor


intermediário:
+ inverter chave e valores de um dicionário
+ mostrar todos os itens duplicados em uma lista

* TODO Comprehensive guides :noexport:
https://bas.codes/posts/python-slicing

* TODO Ideias de tópicos :noexport:

+ criando módulos de python
+ geradores
+ decoradores
