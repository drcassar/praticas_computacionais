#+TITLE: Práticas Computacionais I (~v0.0.2~)
#+AUTHOR: Daniel R. Cassar
#+EXPORT_FILE_NAME: PC1/PC1
#+STARTUP: overview
#+PROPERTY: header-args:python :results output
#+OPTIONS: TeX:t LaTeX:t toc:t html-style:t e:t
#+LATEX_HEADER: \usepackage[brazilian]{babel}
#+LATEX_HEADER: \addto\captionsenglish{\renewcommand\contentsname{Conteúdo}}
#+HTML_HEAD:<style>
#+HTML_HEAD:.linenr {color: #669999; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}
#+HTML_HEAD:</style>
#+todo: TODO(t) DANIEL(d) JAMES(j) | DONE(x)


* Introdução
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_intro
:EXPORT_OPTIONS: toc:nil
:ID:       be365bdb-8e61-4ed3-89ae-397c7855cdeb
:END:

#+HTML: Bem-vinda(o) à disciplina de Práticas Computacionais I.

#+LATEX: Você está lendo o caderno de práticas da disciplina Práticas Computacionais I. Como o próprio nome sugere, aqui você encontrará as práticas que serão realizadas durante a disciplina Práticas Computacionais I da Ilum. As práticas estão apresentadas na ordem de construção do conhecimento e é altamente recomendado realizá-las em sequência sem pular nenhuma etapa.

A maioria das práticas contém um breve texto introdutório e uma ou mais questões. As questões são marcadas com uma letra em negrito e entre chaves. *[A]* Por exemplo, aqui seria o enunciado da questão *A* se estivéssemos dentro do escopo de uma prática.

Realize as práticas seguindo as instruções discutidas em sala de aula. Lembre-se que a capacidade de ler, entender, escrever, e depurar seu próprio código de computador é /fundamental/ para realizar diversas disciplinas da Ilum (incluindo, obviamente, todas as disciplinas de computação). Por este motivo, se atente às dicas abaixo:

+ A maioria das práticas são individuais. Tente resolver as questões no seu computador antes de discutir em grupo. Depois de tentar resolver, fique à vontade para discutir em grupo e observar outras formas de resolver o mesmo problema;

+ Algumas práticas te convidam a executar algum código pronto para ver o que acontece. Mesmo sendo possível copiar e colar o código, é fortemente recomendado /escrever/ o código pois aprendemos mais quando escrevemos do que quando copiamos e colamos;

+ Praticamente todos os problemas computacionais que serão explorados nesta disciplina já foram resolvidos por alguém e a solução pode ser encontrada em livros ou na internet. Isso é inevitável para problemas /simples/. Mais adiante no curso (ou na vida) iremos nos deparar com problemas mais /difíceis/ e mais específicos, que não têm soluções prontas. Para resolver problemas difíceis precisamos ter uma base sólida que só adquirimos resolvendo problemas mais simples. Aproveite esse momento de aprendizado e evite buscar respostas prontas /antes/ de tentar resolver o problema! Depois que você tentou resolver, fique à vontade para procurar e estudar outras soluções.

Ao fim de todas as práticas é necessário enviar o seu caderno de notas Jupyter na plataforma Moodle. Preencha seu caderno de notas seguindo o modelo fornecido. O nome do arquivo deve conter seu nome, sobrenome, e RA.

* Jupyter, variáveis, e como buscar ajuda
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_jupyter
:EXPORT_OPTIONS: toc:t
:ID:       60b5365d-1c0c-4944-bb64-dcbb673a2e4f
:END:

** Meu primeiro caderno de notas Jupyter

Usualmente, a primeira prática quando se está aprendendo uma linguagem de programação nova é a chamada "Olá, mundo!". Nesta prática, o objetivo é criar seu primeiro programa na linguagem Python que, quando executado, exiba a mensagem "Olá, Mundo!".

*[A]* Crie um caderno de notas Jupyter seguindo o modelo discutido na Introdução. Neste caderno, crie uma célula de código contendo o código abaixo. Execute esta célula e observe o que acontece. Escreva brevemente sobre o que você observou.

#+begin_src python
  print("Olá, mundo!")
#+end_src

Observe que no código acima temos três elementos: o comando ~print~, um conjunto de parênteses, e um texto delimitado por aspas duplas. O comando ~print~ é o que chamamos de função. Veremos funções mais adiante, mas por hora basta saber que funções são "apelidos" para executar códigos que já foram escritos. Neste caso, ~print~ é uma função embutida de Python cujo código já foi escrito pelos próprios criadores do Python, por isso você pode usar esta função sem a necessidade de defini-la. A palavra /print/ poderia ser traduzida para o português como /imprimir/, porém o termo /exibir/ se encaixa melhor no uso corriqueiro desta função.

Para executar funções precisamos chamá-las usando os parênteses. Se tiver curiosidade, tente criar e executar uma célula no Jupyter apenas com a palavra ~print~ para ver o que acontece quando escrevemos o nome de uma função sem chamá-la com o parênteses.

Por fim, dentro dos parênteses que usamos para chamar a função ~print~ nós escrevemos os argumentos da função. Neste caso, temos apenas um argumento e ele foi o texto "Olá, mundo!".

Aprender qualquer linguagem, seja ela de programação ou não, requer treino. Não se preocupe se as regras de Python parecem esquisitas, com o passar do tempo você irá ler e escrever códigos em Python com mais facilidade. Afinal, você não aprendeu português de um dia para o outro, não é?

** Criando variáveis de diferentes tipos

É comum em programação situações onde precisamos armazenar informações em variáveis para usá-las mais tarde. Python oferece diversos tipos de variáveis como, por exemplo, números inteiros (~int~), números reais (~float~), e variáveis que armazenam texto (~string~).

*[A]* O código abaixo cria diversas variáveis. Reescreva e execute este código em uma célula do Jupyter. Veja que para atribuir valores à variáveis nós usamos o sinal de igual (~=~). Note que para o Python, o separador decimal é o ponto (~.~) e não a vírgula (~,~); muita atenção com essa distinção pois a vírgula tem outro significado em Python e não necessariamente vai acusar um erro no seu código!! _Lembrete_: mesmo sendo possível copiar e colar o código, sugiro fortemente /escrever/ o código abaixo pois aprendemos muito mais quando escrevemos do que quando copiamos e colamos.

Usando a função ~type~ e a função ~print~, identifique os tipos das variáveis definidas no código que você escreveu. Exemplo: ~print(type(numero_inteiro))~. Quantos tipos diferentes você identificou? Quais foram eles?

#+LATEX: \par\noindent\rule{\textwidth}{0.4pt}
#+begin_src python
  texto_com_aspas_simples = 'Olá, Mundo!'
  texto_com_aspas_duplas = "Olá, Mundo!"
  texto_com_aspas_triplas = '''Olá, Mundo!'''

  numero_inteiro = 10
  numero_inteiro_positivo = +10
  numero_inteiro_negativo = -10

  numero_real = 10.0
  numero_real_sem_digitos_depois_do_ponto = 10.
  numero_real_positivo = +10.0000
  numero_real_negativo = -10.0000
  numero_real_base_dez = 1.5e7
  pi = 3.1415

  numero_complexo = 2 + 3j
  numero_complexo_apenas_parte_imaginaria = 5j
  numero_complexo_apenas_parte_real = 1 + 0j

  variavel_booleana_verdadeiro = True
  variavel_booleana_falso = False

  variavel_nula = None
#+end_src

#+RESULTS:

#+LATEX: \par\noindent\rule{\textwidth}{0.4pt}

*[B]* Em uma célula de texto responda as perguntas:

1) Existe diferença de se criar uma string usando aspas simples, duplas, ou triplas? Reflita sobre a resposta e busque informações na internet antes de escrever. Não se esqueça de colocar as fontes na sua resposta.
2) Qual a diferença entre um número real e um número inteiro? Pelos exemplos do código acima, qual seria a regra para definir números inteiros e números reais?
3) Qual a regra para declarar números complexos? O que é o ~j~ na declaração dos números complexos?
4) Na sua opinião, existe diferença entre as variáveis ~numero_inteiro~ e ~numero_inteiro_positivo~? Explique brevemente seu raciocínio.
5) Na sua opinião, existe diferença entre as variáveis ~numero_real~, e ~numero_real_positivo~, e ~numero_real_sem_digitos_depois_do_ponto~? Explique brevemente seu raciocínio. De que forma você faria para confirmar a sua resposta?

*[C]* O código abaixo /supostamente/ cria novas variáveis. No entanto, algumas das declarações parecem... diferente... quem sabe até estranhas! Seu objetivo é testar cada uma destas declarações e separar as que funcionam das que não funcionam. Para as declarações que não funcionam, descreva o erro que ocorreu e proponha uma correção.

#+begin_src python
  variavel_que_o_nome_termina_com_numero_100 = 1
  100_variavel_que_o_nome_comeca_com_numero = 1
  numero_do_agente_secreto = 007

  nome_da_variável_com_acento = True
  booleano_sem_primeira_letra_maiuscula = true

  espaco_entre_os_numeros = 100 000
  numero_com_sublinhado = 10_000_000

  numero_com_muitos_sinais_de_menos = -----10
  numero_com_muitos_sinais_de_mais = +++++10
  numero_com_muitos_sinais_de_mais_e_menos = +--++-10

  muitos_espacos_entre_o_sinal_de_igual     =      10
  nenhum_espaco_entre_o_sinal_de_igual=10

  texto = Olá, Mundo!
  texto = "Olá, Mundo!'
#+end_src

#+RESULTS:

** Buscando ajuda

Nas práticas anteriores usamos a função ~print~ para exibir informações na forma de texto dentro do próprio caderno de notas do Jupyter. A função ~print~ é uma /função embutida/ do Python. Isto que dizer que qualquer usuário que tenha o Python instalado (idealmente na mesma versão que a sua) terá acesso a esta função sem a necessidade de executar nenhum comando adicional.

Na prática, nós já sabemos que a função ~print~ recebe como argumento o texto ou variável que será exibido. Argumentos de funções são as informações que estão dentro dos parênteses quando executamos as funções; o argumento da função ~print~ em ~print(1234)~ é o número 1234. Funções podem receber um ou mais argumentos, bem como podem receber zero argumentos (tente rodar ~print()~ e veja o que acontece!). Os argumentos das funções são definidos no momento quando a função é definida (vamos ver isso em mais detalhes em uma prática futura).

O que você faria se não soubesse o que função ~print~ faz? Digamos, por exemplo, que você viu essa função sendo usada em um código de Python mas não sabe sua funcionalidade. Como proceder? Algumas sugestões neste caso são:

1) Pesquisar na internet em busca de alguma página com explicações (Python é uma linguagem de programação muito usada, existe muito material didático disponível online);
2) Pesquisar na documentação oficial do Python disponível em português no link https://docs.python.org/pt-br/3/. Todas as funções embutidas de Python, por exemplo, estão descritas aqui: https://docs.python.org/pt-br/3/library/functions.html;
3) Usar a função ~help~ do próprio Python (tente rodar ~help(print)~ no seu caderno de notas e veja o que acontece);
4) Usar a sintaxe própria do Jupyter para buscar ajuda. Para isso basta digitar a função que quer saber mais informações junto com um sinal de interrogação. Neste caso seria ~print?~.

*[A]* Escolha uma das quatro sugestões acima para ler mais sobre a função ~print~ do Python. Observe que a função ~print~ aceita diferentes argumentos, sendo eles: ~value~, ~file~, ~flush~, ~end~, e ~sep~. Escreva como foi sua busca (incluindo fontes se for o caso) e descreva com suas palavras o que os argumentos ~end~ e ~sep~ fazem. Tente outras formas de busca caso julge necessário.

*[B]* Escolha pelo menos duas funções da lista abaixo. Para cada função escolhida, faça uma busca online (buscas 1 ou 2) e uma busca offline (buscas 3 ou 4) para entender o que estas funções fazem. Escreva como foi sua busca (incluindo fontes) e descreva com suas palavras o que estas funções fazem.

+ ~round~
+ ~pow~
+ ~oct~
+ ~abs~

* Operadores e estrutura de decisão
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_operadores
:EXPORT_OPTIONS: toc:t
:ID:       af8757f4-e890-4b3d-96ea-a9c2c73c39e5
:END:

** Operadores aritméticos

A linguagem Python contém diversos operadores aritméticos como adição (~+~), subtração (~-~), multiplicação (~*~), divisão (~/~), e exponencial (~**~). Estes operadores permitem realizar cálculos aritméticos com números inteiros, reais, e complexos. _Cuidado_: em Python, a exponenciação é representada por dois asteriscos; não confundir com o acento circunflexo (~^~) que é o operador de exponenciação usado no Excel!

*[A]* Reescreva o código abaixo em uma célula do Jupyter e veja o que acontece. Comente porque o resultado da terceira linha foi ~100.25~ e não ~5.25~.

#+begin_src python
  print(1 + 1)
  print(1 - 1 + 1 - 1)
  print(-10 + 10.5 * 10.5)
  print(10 / 2 * 5)
  print(10 ** 10)
  print(2 ** 1 / 2)
  print(2 ** (1 / 2))
  print((1 + 1j) / (1 - 1j))
#+end_src

#+RESULTS:
: 2
: 0
: 100.25
: 25.0
: 10000000000
: 1.0
: 1.4142135623730951
: 1j

A ordem de precedência dos operadores aritméticos (isto é, qual é a ordem de execução dos operadores) segue a regra do PEMDAS: parênteses, exponencial, multiplicação, divisão, adição, e subtração. Assim como na notação matemática, usamos parênteses para dar preferência para certas operações.

*[B]* Utilizando os operadores aritméticos do Python, compute:
1) Quantos segundos existem em 16 horas e 42 minutos?
2) Quantos centímetros existem em 72,8 milhas?
3) Se você percorrer 72,8 milhas em 16 horas e 42 minutos, qual a sua velocidade média em centímetros por segundo?
4) Quanto tempo você demoraria para percorrer a circunferência da Terra na linha do equador se permanecer na velocidade média obtida no item acima?

*[C]* Além dos operadores discutidos acima, existem diversos outros em Python. Dois operadores bastante úteis são a divisão inteira (~//~) e o módulo (~%~, também conhecido como resto da divisão inteira). Teste estes operadores e descreva como eles funcionam (em caso de dúvida, busque ajuda assim como discutido na Seção Buscando Ajuda). Discorra brevemente sobre possíveis situações onde estes operadores podem ser úteis.

_Atenção_: operadores aritméticos usualmente funcionam com qualquer combinação de números inteiros, reais, ou complexos. No entanto, preste atenção no tipo do resultado final!

*[D]* Escreva e execute o código abaixo e comente sobre o resultado obtido. Escreva um código similar ao código abaixo, porém alterando o operador de adição pelo operador de divisão. Você obteve algum resultado inusitado? Comente.

#+begin_src python
  inteiro_mais_inteiro = 1 + 1
  print(type(inteiro_mais_inteiro))

  inteiro_mais_real = 1 + 1.5
  print(type(inteiro_mais_real))

  real_mais_real = 1.5 + 1.5
  print(type(real_mais_real))

  inteiro_mais_complexo = 10 + (1 - 2j)
  print(type(inteiro_mais_complexo))

  real_mais_complexo = 10.5 + (1 - 2j)
  print(type(real_mais_complexo))
#+end_src

#+RESULTS:
: <class 'int'>
: <class 'float'>
: <class 'float'>
: <class 'complex'>
: <class 'complex'>

*Desafio*: durante um exercício de geometria, você decidiu realizar suas contas utilizando Python. Você escreveu o código abaixo em uma célula no seu caderno de notas Jupyter e o resultado que obteve foi inusitado! Por que o resultado é inusitado? Qual era o resultado esperado? Qual é a explicação para isso? Na sua opinião, este tipo de "problema" compromete o uso de Python como uma calculadora aritmética?

#+begin_src python
  pi = 3.14
  valor = pi + 2
  print(valor)
#+end_src

#+RESULTS:
: 5.140000000000001

** Operadores lógicos

Variáveis lógicas (também conhecidas como variáveis booleanas) são objetos que podem assumir apenas dois valores diferentes: verdadeiro ou falso. Na sintaxe de Python, escrevemos verdadeiro ou falso em inglês e com a primeira letra maiúscula: ~True~ ou ~False~.

Uma expressão booleana é uma expressão que, quando resolvida, resulta em um valor verdadeiro (~True~) ou em um valor falso (~False~). Expressões booleanas podem ser escritas com os operadores lógicos E (~and~), OU (~or~), e NÃO (~not~). Os operadores ~and~ e ~or~ são chamados de operadores binários pois requerem sempre dois argumentos para serem resolvidos. A sintaxe para usar estes operadores com os argumentos ~A~ e ~B~, por exemplo, é a seguinte: ~A and B~ e ~A or B~.

*[A]* Escreva e execute o código abaixo; comente sobre qual ou quais situações o operador ~and~ retorna o valor ~True~.

#+begin_src python
  print(True and True)
  print(True and False)
  print(False and True)
  print(False and False)
#+end_src

#+RESULTS:
: True
: False
: False
: False

Se quisermos, podemos rescrever o código acima usando variáveis para facilitar a visualização:

#+begin_src python
  A = True
  B = False

  print(A and A)
  print(A and B)
  print(B and A)
  print(B and B)
#+end_src

#+RESULTS:
: True
: False
: False
: False

*[B]* Escreva e execute um código similar ao código acima, substituindo ~and~ por ~or~; comente sobre qual ou quais situações o operador ~or~ retorna o valor ~True~.

O operador ~not~ é um operador unário; ele requer apenas um argumento para ser computado. A sintaxe para usar este operador com o argumento ~A~, por exemplo, é a seguinte: ~not A~.

*[C]* Escreva e execute o código abaixo e comente sobre como o operador ~not~ funciona.

#+begin_src python
  print(not True)
  print(not False)
#+end_src

#+RESULTS:
: False
: True

Operadores lógicos podem ser combinados na mesma declaração. Sempre que for fazer uma combinação de operadores lógicos, lembre-se de usar o parênteses para garantir a ordem de execução desejada.

#+begin_src python
  A = True
  B = False
  print((A or B) and not (B and A))
#+end_src

#+RESULTS:
: True

** Operadores de comparação

Operadores de comparação (também conhecidos como operadores relacionais) fazem exatamente o que o nome sugere: comparam dois objetos. O resultado dessa comparação é uma variável booleana (~True~ ou ~False~).

Existem 6 operadores de comparação em Python:
+ igualdade (~==~)
+ diferença (~!=~)
+ maior que (~>~)
+ menor que (~<~)
+ maior ou igual que (~>=~)
+ menor ou igual que (~<=~)

*[A]* Suponha que ~A = 1~, ~B = 2~, ~C = 4~, ~D = 8~, e ~E = 16~. Atribua o valor verdadeiro ou falso para cada uma das expressões abaixo. Escreva um código em Python para checar se você acertou. Comente sobre como funcionam as expressões com mais de um operador de comparação.

#+begin_src python
  A == B
  A < B
  B > C
  D <= E
  A != E
  E >= D >= C
  A < C == D
  A + A != B
  A + A < B < C - B
  A + A <= B <= C - B
  A != B < C == E - D - C
#+end_src

_Cuidado_: é muito comum confundir o operador de atribuição (~=~) com o operador de comparação de igualdade (~==~). O operador de atribuição é usado para atribuir um valor a uma variável, por exemplo: ~A = 10~ atribui o valor 10 para a variável ~A~. Já o operador de comparação de igualdade responde a pergunta se os objetos sendo comparados são iguais. Neste caso, a expressão ~A == 10~ responde a pergunta se o valor armazenado em ~A~ é igual a 10, resposta esta que pode ser verdadeiro ou falso.

** Estrutura de decisão e operador condicional

Em diversos momentos da vida nos adaptamos mediante às condições do ambiente. Por exemplo, ao sair de casa, /se/ estiver chovendo /então/ pegamos o guarda-chuva, /se não/ nós saímos de casa sem o guarda-chuva. Esta estrutura condicional também existe nas linguagens de programação. Em certos momentos, queremos que a execução de um ou mais comandos só ocorra caso uma ou mais condições sejam atendidas.

*[A]* Em que outros momentos da sua vida você faz escolhas segundo uma estrutura condicional contendo /se/, /então/, e /se não/? Escreva sobre três destes momentos dizendo como você se comporta (tome como base o exemplo do guarda-chuva).

O exemplo do guarda-chuva pode ser escrito em Python. Vamos supor que a variável booleana ~esta_chovendo~ armazena o valor ~True~ caso esteja chovendo ou o valor ~False~ caso não esteja chovendo. Queremos armazenar na variável booleana ~pegar_guardachuva~ o valor de ~True~ para o caso onde vamos pegar o guarda-chuva e o valor de ~False~ para o caso onde não vamos pegar o guarda-chuva. O código abaixo ilustra uma forma possível de programar essa decisão em Python (note o uso dos dois-pontos na sintaxe abaixo!).

#+begin_src python -n
  esta_chovendo = True  # troque esse True for False para ver o que acontece

  if esta_chovendo == True:
      pegar_guardachuva = True
      print("Vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

No código acima, o comando ~if~ checa se a condição "~esta_chovendo == True~" é verdadeira. Esta condição será verdadeira se a variável ~esta_chovendo~ tiver o valor ~True~. Existem duas possibilidades:

1) Se a condição checada for /verdadeira/, o bloco do ~if~ será executado e o bloco do ~else~ será ignorado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão executadas e as linhas 7 e 8 não serão executadas);

2) Se a condição checada for /falsa/, o bloco do ~if~ será ignorado, e o bloco do ~else~ será executado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão ignoradas e as linhas 7 e 8 serão executadas).

Independentemente do resultado do teste da condição, a primeira e a última linha do código serão executadas pois elas não estão dentro da estrutura de decisão.

Observe que a sintaxe de estruturas de decisão requer que o bloco referente ao ~if~ e o bloco referente ao ~else~ estejam /indentados/. Indentação de código é quando utilizamos uma certa quantidade de espaços para agrupar visualmente linhas de código pertencentes a um mesmo bloco. Segundo o guia de estilo do Python (chamado de PEP8 caso tenha curiosidade de saber mais), é recomendado usar 4 espaços para indentar seu código.

É bom saber que se seu código não estiver indentado corretamente, ele muito provavelmente não irá realizar a tarefa que você tinha em mente. Em certos casos, uma falha e indentar corretamente seu programa irá acusar um erro. Tente rodar o código abaixo e veja o que acontece (veja que ele é o mesmo código que vimos acima, porém sem indentação).

#+begin_src python -n
  esta_chovendo = True  # troque esse True for False para ver o que acontece

  if esta_chovendo == True:
  pegar_guardachuva = True
  print("Vou pegar o guarda-chuva")
  else:
  pegar_guardachuva = False
  print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

*[B]* Escreva um código de Python para cada um dos três momentos de decisão que você descreveu na questão *A*.

É bastante comum nos depararmos com situações onde nossa decisão depende de mais de uma condição. Digamos, por exemplo, que só queremos pegar o guarda-chuva se estiver chovendo e se for um dia de semana (do contrário, decidimos que vamos ficar em casa e não precisamos do guarda-chuva). Para isso precisaremos de um ~if~ adicional; veja o exemplo abaixo e note que o contexto de cada bloco de código é ditado pela sua indentação (sempre em múltiplos de 4 espaços).

#+begin_src python
  esta_chovendo = True
  final_de_semana = False

  if esta_chovendo == True:
      if final_de_semana == False:
          pegar_guardachuva = True
          print("Vou pegar o guarda-chuva")
      else:  # este else está relacionado ao if da variavel final_de_semana
          pegar_guardachuva = False
          print("Não vou pegar o guarda-chuva")
  else:  # este else está relacionado ao if da variavel esta_chovendo
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

*[C]* Pense em uma situação onde você precisa considerar duas condições para tomar uma decisão e escreva ela em um código de Python.

A linguagem Python contém uma série de expressões que são o que chamamos de /açúcar sintático/. Um açúcar sintático é uma forma de comunicar uma informação de maneira mais fácil ou mais expressiva. O código acima pode ser reescrito da seguinte maneira:

#+begin_src python
  esta_chovendo = True
  final_de_semana = False

  if esta_chovendo:
      if not final_de_semana:
          pegar_guardachuva = True
          print("Vou pegar o guarda-chuva")
      else:
          pegar_guardachuva = False
          print("Não vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

*[E]* Teste e reporte se novo código funciona. O que mudou em comparação com o original? Explique como funciona o açúcar sintático exemplificado acima. Na sua opinião, este tipo de açúcar sintático facilitou a sua leitura do código?

*[D]* Reescreva o código acima de forma que ele se comporte da mesma maneira, porém usando apenas um ~if~ e apenas um ~else~. Dica: pense em qual operador lógico poderia te ajudar aqui!

O código abaixo checa em qual faixa está o valor de pH fornecido (https://pt.wikipedia.org/wiki/PH) e reporta para o usuário se sua solução é ácida, básica, neutra, ou se houve algum equívoco e o valor de pH é inválido. Veja que a cláusula ~else~ é opcional e não foi usada no código abaixo.

#+begin_src python -n
  # teste o código com diferentes valores para a variável ph
  ph = 7

  if (ph < 0) or (ph > 14):
      print("pH inválido")

  if 0 <= ph < 6.5:
      print("pH ácido")

  if 6.5 <= ph <= 7.5:
      print("pH neutro")

  if 7.5 < ph <= 14:
      print("pH básico")
#+end_src

#+RESULTS:
: PH neutro

Imagine que você mediu o pH de um vinagre e obteve o valor de 2,5. Ao rodar o código acima, o programa irá te dizer "pH ácido" (teste você mesma(o)!). Veja que o programa poderia ter parado de rodar depois de resolver o ~if~ da linha 7 (afinal, não faz sentido checar se o pH é neutro ou básico após identificar que se trata de um pH ácido), porém ele *irá* rodar os ~if~ das linhas 10 e 13.

*[E]* Reescreva o código acima usando cláusulas ~else~ de forma que o programa não rode nenhuma cláusula ~if~ desnecessária para entregar a resposta ao usuário (isto é: após ter encontrado a resposta, nenhum outro ~if~ deve ser executado).

Uma estrutura muito comum em programação é quando queremos dizer "se a condição testada não for verdadeira, então teste esta outra condição aqui". Para isso usamos a cláusula ~elif~ que seria um ~else~ com um ~if~ "grudados". O código abaixo é similar ao anterior, porém usando ~elif~

#+begin_src python -n
  # teste o código com diferentes valores para a variável ph
  ph = 7

  if 0 <= ph < 6.5:
      print("pH ácido")

  elif 6.5 <= ph <= 7.5:
      print("pH neutro")

  elif 7.5 < ph <= 14:
      print("pH básico")

  else:
      print("pH inválido")
#+end_src

#+RESULTS:
: pH neutro

O código acima checa se o pH é ácido. Caso seja ácido o programa exibe "pH ácido" para o usuáro e nada mais será executado. Caso não seja ácido, o programa checa então se é neutro. Caso seja neutro o programa exibe "pH neutro" para o usuário e nada mais será executado. Caso não seja neutro também, o programa faz uma última checagem para confirmar se é um pH básico. Assim sendo o usuário verá o texto "pH básico" e o programa se encerra. Se o pH não for ácido, nem neutro, nem básico, então podemos afirmar que o programa recebeu um valor inválido de pH.

*[F]* Escreva um programa similar ao programa do pH que checa alguma grandeza escalar e exibe para o usuário uma informação sobre esta grandeza. Utilize pelo menos duas cláusulas ~elif~ no seu programa.

Além da estrutura de decisão ~if~/~else~ existe o operador condicional. É importante saber que ele existe, porém na maioria dos casos é preferível que você use a estrutura de decisão mesmo por ser uma construção mais legível. O exemplo abaixo mostra uma estrutura condicional e o operador condicional, ambos realizam a mesma tarefa. Note que a cláusula ~else~ é opcional na estrutura condicional porém obrigatória no operador condicional.

#+begin_src python
  condicao = True

  # estrutura condicional
  if condicao:
      a = 100
  else:
      a = 5

  # operador condicional
  a = 100 if condicao else 5
#+end_src

* JAMES Listas, tuplas, e conjuntos
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_listas
:EXPORT_OPTIONS: toc:t
:ID:       979099a4-9da2-48d1-9d6a-308a97868f1c
:END:

** Agrupando objetos com listas
+ listas simples
+ listas dentro de listas

** Modificando, particionando, e desempacotando listas
+ métodos =append=, =extend=, =pop=
+ slicing
+ a, \ast{}b, c = lista

** "Tuplas são listas imutáveis"
+ diferença entre objetos mutáveis e imutáveis
+ cópia rasa e cópia profunda

** "Conjuntos são listas sem elementos repetidos"
+ métodos de união, subtração, e intersecção de conjuntos

* JAMES Laço de repetição
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_laco
:EXPORT_OPTIONS: toc:t
:ID:       25e5272b-ad01-463a-815a-7b4345a4b35a
:END:

** Laço de repetição usando =while=
+ não esquecer de comentar do loop infinito =while True=

** Laço de repetição usando =for=
** Iterando sobre listas com o operador de filiação
+ operador =in=

** Compreensão de listas
+ açúcar sintático
+ pode ser tanto mais rápido quanto mais legível (mas nem sempre!)

* DANIEL Funções
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_funcoes
:EXPORT_OPTIONS: toc:t
:ID:       b20f8635-108a-49d4-9903-6a397dc4fed2
:END:

** Funções embutidas

O que é uma função? O que são argumentos? O que é o valor de retorno?

Existem diversas funções embutidas em Python.

dir(__builtins__)

+ =len=
+ =print=
+ =range=
+ =list=
+ =set=
+ =type=
+ =input=
+ =help=

** Definindo novas funções
+ argumentos
+ corpo da função
+ retorno

** Argumentos posicionais, argumentos nomeados, e argumentos com valor padrão

** Variáveis globais e variáveis locais
** Documentando suas funções com docstring
+ comentar sobre =pep8=

* TODO Depuração de programas
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_debug
:EXPORT_OPTIONS: toc:t
:ID:       a822fa0b-e43c-4dc6-99f4-0f4f8a2e97fc
:END:

** Meu programa não roda pois dá um erro, e agora?
+ tipos de erros

** Meu programa não faz o que eu queria que ele fizesse, e agora?
+ técnicas de debug
+ pythontutor https://pythontutor.com/visualize.html#mode=edit
+ módulo =pdb=
+ recordar o tópico "buscando ajuda"

** Tratamento de exceções
+ bloco =try= / =except= / =finally=

* TODO Dicionários
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_dicionarios
:EXPORT_OPTIONS: toc:t
:ID:       982992c4-400b-4d79-a738-e86116b14ebc
:END:

** Associando objetos com dicionários
** Modificando e desempacotando dicionários
+ método =pop=
+ adicionando nova chave
+ deletando uma chave

** Iterando sobre dicionários
+ métodos =items=, =get=, =keys=, =values=

** Funções com argumentos estrela \ast{}args e \ast\ast{}kwargs

* TODO Strings e processamento de texto
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_strings
:EXPORT_OPTIONS: toc:t
:ID:       6feb275c-31de-49dd-87a1-d3576f4dbfc2
:END:

** Agrupando caracteres com strings
+ strings são imutáveis
+ convertendo objetos para strings com =str=
+ convertendo strings para inteiros e reais com =int= e =float=
+ iterando em strings com =for=
+ checando prefixos e sufixos com =startswith= e =endswith=
+ checando caracteres com =isnumeric=, =isupper=, =islower=

** Recebendo informações do usuário com o comando =input=

** Tipos de strings
+ utf-8
  - caracteres especiais tipo \n e \t
+ raw
+ fstring

** Processamento de texto
+ =split= e =join=
+ =translate= e =maketrans=
+ =capitalize=, =title=, =lower=, =upper=, =swapcase=
+ =replace=

** Expressões regulares
* JAMES script .py + Bash + HPC
* TODO Programação orientada a objetos
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_classes
:EXPORT_OPTIONS: toc:t
:ID:       59343370-093c-4c7c-b549-9e102aed7b5b
:END:

** Agrupando objetos com classes
+ classes como um único objeto para tratar de dados e funções
+ sintaxe
+ instância
+ parâmetros
+ =self=

** Classes e seus métodos
** Métodos mágicos
+ dunders
+ __init__
+ __str__
+ __repr__

** Herança de classes

* TODO Biblioteca padrão
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_bibpadrao
:EXPORT_OPTIONS: toc:t
:ID:       a5a1dec7-4ac1-4c97-a064-75b93b837a5c
:END:

** O que são e como importar módulos de Python
+ sintaxe para importar um módulo (com ou sem apelido)
+ sintaxe para importar objetos de um módulo
+ conceito de namespace ("espaço de nome")
+ reforçar que cada módulo tem sua documentação (ou deveria ter...)
+ Módulos para usar como exemplo: =math= e =random=

** Módulos embutidos
+ os que eu acho mais interessantes são:
  + os
  + sys
  + functools
  + itertools
  + math
  + pathlib
  + pdb
  + pprint
  + random
  + re
  + statistics
  + pickle
  + abc?
  + collections
  + datetime

* TODO Leitura e manipulação de dados com o módulo =pandas=
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_pandas
:EXPORT_OPTIONS: toc:t
:ID:       94937cb1-718d-4eee-a3be-611c4badeb4b
:END:

** Criando e manipulando DataFrames a partir de arquivos
** Análise dos dados
+ Estatística descritiva
** Criando e exportando um DataFrame a partir de listas
+ Criando um dataframe usando listas de python
+ Exportar para csv
+ Exportar para xlsx

* TODO Graficando dados
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_graficos
:EXPORT_OPTIONS: toc:t
:ID:       5c9942b1-d397-4d59-9891-6f6bfee01809
:END:

** Graficando dados de um DataFrame
** Graficando dados usando =matplotlib=

* TODO Controle de versão usando =git=
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_git
:EXPORT_OPTIONS: toc:t
:ID:       7ec34a02-1c92-4a3f-940a-955daab7050f
:END:

* TODO Computação científica com =numpy= e =scipy=
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_numpy
:EXPORT_OPTIONS: toc:t
:ID:       fc29118f-e0b5-4816-9034-4a83e7b520b4
:END:
* TODO Algebra simbólica com =sympy=
* TODO Propagação de erros com =uncertainties=
* TODO Exercícios :noexport:

+ Computar numericamente a soma de uma PA ou PG
+ Função que checa se um número é palímdromo (sem usar string!)
+ Checar os números divisíveis por 5 em uma lista
+ Contar quais são as palavras mais comuns em um texto
+ Dadas duas listas, montar uma terceira com os maiores números de cada (element-wise)
+ mostrar a sequencia de fibonacci até o número n
+ checar se um número é primo
+ função que soma todos os números do 1 até o n
+ programa que conta quantos digitos existem em um numero inteiro
+ inverter a ordem de uma lista
+ programa que calcula o fatorial de um inteiro positivo
+ programa que cria uma lista apenas com os itens nas posições impares de uma lista original
+ encontre o segundo maior número em uma lista
+ função que conta quantas letras, dígitos e caracteres especiais tem em uma string
+ histograma de contagem de caracteres em uma string
+ encontrar números em uma string e armazena-los em uma lista
+ histograma de valores em uma lista
+ criar uma lista sem itens repetidos
+ identificar os elementos em comum entre duas listas
+ separar valores e chaves de dicionários em duas listas
+ concatenar duas listas de string element-wise
+ Create a program that asks the user to enter their name and their age. Print out a message addressed to them that tells them the year that they will turn 100 years old.
+ Ask the user for a number. Depending on whether the number is even or odd, print out an appropriate message to the user.
+ use compreensão de lista para identificar números impares em uma lista
+ criar um jogo de jokenpo a ser jogado por duas pessoas
+ exercicio onde o computador escolhe um numero aleatorio e o usuario deve adivinhar com dicas de maior ou menor


intermediário:
+ reverter cada palavra de uma lista
  - 'My Name is Jessa'
  - yM emaN si asseJ
+ inverter chave e valores de um dicionário
+ mostrar todos os itens duplicados em uma lista
* TODO Ideias de tópicos :noexport:

+ criando módulos de python
+ geradores
+ decoradores
