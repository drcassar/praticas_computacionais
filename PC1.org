#+TITLE: Práticas em Ciência de Dados
#+AUTHOR: Daniel R. Cassar & James M. de Almeida
:config:
#+EXPORT_FILE_NAME: PC1/PC1
#+STARTUP: overview
#+PROPERTY: header-args:python :results output
#+OPTIONS: TeX:t LaTeX:t toc:t html-style:t e:t
#+LATEX_HEADER: \usepackage[brazilian]{babel}
#+LATEX_HEADER: \addto\captionsenglish{\renewcommand\contentsname{Conteúdo}}
#+todo: TODO(t) DANIEL(d) JAMES(j) | DONE(x)
:END:
:style:
#+BEGIN_EXPORT html
<style>
  .linenr {
    color: #669999;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  <!-- blockquote { -->
  <!--   margin-bottom: 10px; -->
  <!--   padding: 10px; -->
  <!--   background-color: #FFF8DC; -->
  <!--   border-left: 2px solid #ffeb8e; -->
  <!--   border-left-color: rgb(255, 228, 102); -->
  <!--   display: block; -->
  <!--   margin-block-start: 1em; -->
  <!--   margin-block-end: 1em; -->
  <!--   margin-inline-start: 40px; -->
  <!--   margin-inline-end: 40px; -->
  <!-- } -->

  <!-- .verse { -->
  <!--   margin-bottom: 10px; -->
  <!--   padding: 10px; -->
  <!--   background-color: #FFF8DC; -->
  <!--   border-left: 2px solid #ffeb8e; -->
  <!--   border-left-color: rgb(255, 228, 102); -->
  <!--   display: block; -->
  <!--   margin-block-start: 1em; -->
  <!--   margin-block-end: 1em; -->
  <!--   margin-inline-start: 40px; -->
  <!--   margin-inline-end: 40px; -->
  <!-- } -->
</style>
#+END_EXPORT
:END:


* Conteúdo da disciplina :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/toc
:EXPORT_OPTIONS: toc:nil
:END:

1. Jupyter, variáveis e como buscar ajuda
2. Operadores e estrutura de decisão
3. Funções
4. Listas, tuplas e conjuntos
5. Laço de repetição
6. Dicionários e depuração de programas
7. Strings e processamento de texto
8. Scripts de python, bash e HPC
9. Biblioteca padrão e bibliotecas externas
10. Computação científica com numpy e scipy
11. Leitura e manipulação de dados com o módulo pandas
12. Graficando dados
13. Controle de versão usando git
14. Tópicos avançados
15. Apresentação dos trabalhos de conclusão do semestre

* Introdução
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_intro
:EXPORT_OPTIONS: toc:nil
:ID:       be365bdb-8e61-4ed3-89ae-397c7855cdeb
:END:

** Olá! Que bom que você veio, aprochegue-se!

#+begin_quote
"/A mente que se abre a uma nova ideia jamais voltará ao seu tamanho original./" --- Albert Einstein
#+end_quote

Bem-vinda(o) à apostila de Práticas em Ciência de Dados. Esta apostila foi escrita[fn:: Está sendo escrita na verdade, e provavelmente continuará sendo escrita por muito tempo pois a área de computação é muito dinâmica.] tendo em mente a disciplina de /Práticas em Ciência de Dados/ do Bacharelado em Ciência, Tecnologia e Inovação da Ilum Escola de Ciência. Assim, esta apostila leva em consideração que os problemas propostos serão realizados em sala de aula em um ambiente dinâmico com interações alunos-alunos e alunos-professores. Esta é uma abordagem diferente da maioria dos livros-texto disponíveis em língua portuguesa.

A apostila está dividida em tópicos gerais e cada um deles divididos em subtópicos com diversas práticas. Todos os subtópicos contém um texto explicativo (com exemplos) e uma ou mais práticas. As práticas são marcadas com uma letra em negrito e entre chaves.

*[A]* Aqui, por exemplo, seria o enunciado da prática *1.1.A* (prática A da Seção 1.1).

Realize as práticas seguindo as instruções discutidas em sala de aula. Lembre-se que a capacidade de ler, entender, escrever e depurar seu próprio código é /fundamental/ para realizar as diversas disciplinas da Ilum (incluindo, obviamente, todas as disciplinas de computação). Por este motivo, se atente às dicas abaixo:

+ As práticas são individuais. Tente resolver as questões no seu computador antes de discutir em grupo. Depois de tentar resolver, você é incentivada(o) a discutir em grupo e observar outras formas de resolver o mesmo problema (aprendemos muito vendo outras soluções!);

+ Algumas práticas te convidam a executar algum código pronto para ver o que acontece. Mesmo sendo possível copiar e colar o código, é fortemente recomendado /escrever/ o código pois aprendemos mais quando escrevemos (ação ativa) do que quando copiamos e colamos (ação passiva);

+ Praticamente todos os problemas computacionais que serão explorados nesta disciplina já foram resolvidos por alguém e a solução pode ser encontrada em livros ou na internet. Isso é inevitável para problemas /simples/. Mais adiante no curso (ou na vida) iremos nos deparar com problemas mais /difíceis/ e mais específicos, que não têm soluções prontas. Para resolver problemas difíceis precisamos ter uma base sólida que só adquirimos resolvendo problemas mais simples. Aproveite esse momento de aprendizado e evite buscar respostas prontas /antes/ de tentar resolver o problema! Depois que você tentou resolver, fique à vontade para procurar e estudar outras soluções. Aprendemos muito quando estudamos diferentes soluções para o mesmo problema.

** Python e o caderno de notas Jupyter

#+begin_quote
"/Além do saneamento, da medicina, da educação, do vinho, da ordem pública, da irrigação, das estradas, do sistema de água doce, da saúde pública... o que os romanos já fizeram por nós?/" --- Monty Python, A vida de Brian
#+end_quote

Esta apostila toda foi escrita considerando a linguagem de programação _Python_. Python é uma linguagem de programação criada por Guido van Rossun com grande ênfase em produzir códigos expressivos que sejam mais fáceis de serem lidos[fn:: O fato de que Python foi criado intencionalmente com a ideia de ser mais legível sugere que existem linguagens de programação que foram criadas sem essa preocupação. Existem ainda linguagens de programação chamadas de exotéricas que são deliberadamente criadas para serem o mais ilegível possível (muitas vezes para fins humorísticos). Provavelmente a mais conhecida é a Brainfuck https://esolangs.org/wiki/Brainfuck.]. Por este e outros motivos, Python chamou a atenção da comunidade científica e hoje é uma das linguagens de programação mais utilizada nesta área. Existem diversas bibliotecas científicas livres e de código aberto disponíveis para Python, muitas delas são o estado da arte em suas respectivas áreas.

Uma ferramenta para execução de códigos em Python muito utilizada no meio científico são os cadernos de nota Jupyter (/Jupyter Notebooks/, em inglês). Jupyter é um programa que permite a execução interativa de códigos em Python separados em blocos de códigos chamados de células. A possibilidade de incluir células de texto, imagens e gráficos interativos são muito bem-vindas no contexto de análises científicas. Além disso, os cadernos de nota Jupyter armazenam os resultados obtidos e, se bem utilizados, nos ajudam com a reprodutibilidade do nosso trabalho. Reprodutibilidade significa que seu trabalho pode ser reproduzido por um par com conhecimento técnico suficiente, e isso é essencial para avançar o nosso conhecimento científico coletivo.

Apesar de não ser estritamente necessário utilizar os cadernos de notas Jupyter para realizar as práticas desta apostila, o texto irá assumir que as práticas serão realizadas no ambiente Jupyter.

** Links interessantes

#+begin_quote
"/É perigoso seguir sozinho, pegue isso!/" --- Ancião, The Legend of Zelda
#+end_quote

Existem alguns links que são sempre bons de ter em mãos. Um dos mais importantes é o link para a documentação oficial do Python, disponível em https://docs.python.org/3.9/ (Inglês, versão 3.9 do Python) e https://docs.python.org/pt-br/3.9/ (Português, versão 3.9 do Python). A documentação oficial é sempre uma boa escolha para investigar o funcionamento de qualquer /software/, e isso não é diferente para o Python. Leva um tempo até se acostumar com o formato da apresentação, mas vale a pena.

Python é uma linguagem de programação que constantemente recebe atualizações de funcionalidades. O processo de inclusão de novas funcionalidades envolve a escrita e o aceite das /Propostas de Melhorias do Python/ (PEP). Você pode checar todas as propostas em https://www.python.org/dev/peps/. Algumas propostas são especialmente úteis:

+ [[https://www.python.org/dev/peps/pep-0020/][PEP 20]] - O Zen do Python. Uma PEP breve contendo um poema sobre a filosofia do Python. Se for ler apenas uma PEP na sua vida, leia essa;
+ [[https://www.python.org/dev/peps/pep-0008/][PEP 8]] - Guia de estilo. Recomendações sobre o que é considerado bom estilo para a escrita de códigos em Python;
+ [[https://www.python.org/dev/peps/pep-0257/][PEP 257]] - Convenções para docstrings. Veremos docstrings no capitulo sobre funções. Lá iremos comentar sobre esta PEP. Docstrings servem para documentar seu código para torná-lo mais fácil de ser entendido por outras pessoas.

Existe uma enorme quantidade de bibliotecas de Python prontas para uso. Algumas destas bibliotecas nós veremos nesta apostila, como a ~numpy~, ~matplotlib~ e ~pandas~. Muitas outras existem! Veja neste link uma lista curada de diversas bibliotecas: https://awesome-python.com. Note que Python pode ser utilizado para diversas tarefas, não apenas para computação científica!

# *[A]* Vá até a seção de bibliotecas científicas do site awesome-python (disponível em https://awesome-python.com/#science) e escolha a biblioteca que mais te chamar a atenção. Se informe brevemente sobre o que a sua biblioteca escolhida faz e escreva o que aprendeu em uma célula de texto.

Você verá ao longo desta apostila que existem diversos detalhes para escrever código em Python (o que não é algo objetivamente bom ou ruim, apenas uma observação sobre a realidade como ela se apresenta). Com tempo e treino, muitos destes detalhes serão naturais para você. Mesmo assim, é normal esquecer certos detalhes quando ficamos um tempo sem usar. Por isso é sempre bom ter uma cola para refrescar a mente. Os links abaixo te levam para boas colas online gratuitas:

+ [[https://github.com/gto76/python-cheatsheet][Python cheatsheet no github]]
+ [[https://www.pythoncheatsheet.org/][pythoncheatsheet.org]]
+ [[https://programmingwithmosh.com/wp-content/uploads/2019/02/Python-Cheat-Sheet.pdf][Python Cheat Sheet escrito por Mosh Hamedani]]
+ [[https://github.com/ehmatthes/pcc/releases/download/v1.0.0/beginners_python_cheat_sheet_pcc_all.pdf][Python Crash Course Cheat Sheet]]

Por fim, existem diversos materiais (tanto pagos quanto gratuitos) para aprendizado de Python disponíveis online. Abaixo estão alguns links de materiais gratuitos que podem te interessar:

+ [[https://github.com/pamoroso/free-python-books][Lista de livros gratuitos de Python]] lista curada e constantemente atualizada sobre diversos livros de Python que você pode ler sem custo algum. A lista separa os livros em tópicos e também no nível de aprendizado;
+ [[https://books.goalkicker.com/PythonBook/][Notas de Python para profissionais]]: material bastante extenso cobrindo praticamente tudo sobre Python. Não é necessariamente o melhor material para aprender a linguagem, mas é um excelente material para uma consulta rápida;
+ [[https://automatetheboringstuff.com/#toc][Automatize tarefas maçantes com Python]]: livro online gratuito com uma didática muito interessante e focada em aprendizado "mão-na-massa". Sua última versão é de 2015. A recomendação é usar este livro para aprender o funcionamento básico do Python, mas não utilizá-lo para aprender as bibliotecas que ele sugere (algumas delas estão desatualizadas).
+ [[https://greenteapress.com/thinkpython2/html/index.html][Think Python 2]] [[https://penseallen.github.io/PensePython2e/][(versão em português)]]: livro online gratuito. Última versão é de 2015, então não aborda certas características mais recentes da linguagem;
** TODO Quando tudo mais falhar :noexport:
+ Técnica da NASA

* Jupyter, variáveis e como buscar ajuda
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_jupyter
:EXPORT_OPTIONS: toc:t
:ID:       60b5365d-1c0c-4944-bb64-dcbb673a2e4f
:END:

** Meu primeiro caderno de notas Jupyter

#+begin_quote
"/O segredo para chegar à frente é começar./" --- Mark Twain
#+end_quote

Usualmente, a primeira prática quando se está aprendendo uma linguagem de programação nova é a chamada "Olá, mundo!". Nesta prática, o objetivo é criar seu primeiro programa na linguagem de interesse (Python neste caso) que, quando executado, exiba a mensagem "Olá, Mundo!".

*[A]* Em um caderno de notas do Jupyter, crie uma célula de código contendo o código abaixo. Execute esta célula e observe o que acontece. Reflita e escreva brevemente sobre o que você observou em uma célula de texto.

#+begin_src python
  print("Olá, mundo!")
#+end_src

Observe que no código acima temos três elementos: o comando ~print~, parênteses e um texto delimitado por aspas duplas. O comando ~print~ é o que chamamos de _função_. Veremos funções mais adiante, mas por hora basta saber que funções são "apelidos" para executar códigos que já foram escritos. Neste caso, ~print~ é uma função embutida de Python cujo código já foi escrito pelos próprios criadores do Python, por isso você pode usar esta função sem a necessidade de defini-la. A palavra /print/ poderia ser traduzida para o português como /imprimir/, porém o termo /exibir/ se encaixa melhor no uso corriqueiro desta função.

Para executar funções precisamos chamá-las usando os parênteses. Se tiver curiosidade, tente criar e executar uma célula no Jupyter apenas com a palavra ~print~ para ver o que acontece quando escrevemos o nome de uma função sem chamá-la com o parênteses.

Por fim, dentro dos parênteses que usamos para chamar a função ~print~ nós escrevemos os /argumentos/ da função. Neste caso, temos apenas um argumento e ele é o texto "Olá, mundo!".

*[B]* Escreva o código abaixo em uma célula de código e rode ele. Descreva o que aconteceu e proponha uma solução para o problema.

#+begin_src python
  print "Olá, mundo!"
#+end_src

#+RESULTS:

*[C]* Escreva o código abaixo em uma célula de código e rode ele. Descreva o que aconteceu e proponha uma solução para o problema.

#+begin_src python
  print(Olá, mundo!)
#+end_src

#+RESULTS:

*[D]* Crie três blocos de código no seu caderno de notas do Jupyter. No primeiro bloco de código, faça com que o Python exiba seu nome completo usando a função ~print~. No segundo bloco de código, faça com que o Python exiba a data de hoje. Finalmente, no terceiro bloco de código faça com que o Python exiba uma frase que você goste muito.

Aprender qualquer linguagem, seja ela de programação ou não, requer treino. Não se preocupe se as regras de Python parecem esquisitas, com o passar do tempo você irá ler e escrever códigos em Python com mais facilidade. Afinal, você não aprendeu português de um dia para o outro, não é?

** Criando variáveis de diferentes tipos

#+begin_quote
"/Ninguém é igual a ninguém. Todo o ser humano é um estranho ímpar./" --- Carlos Drummond de Andrade
#+end_quote

É comum em programação situações onde precisamos armazenar informações em variáveis para usá-las mais tarde. Python oferece diversos tipos de variáveis como números inteiros (~int~), números reais (~float~) e variáveis que armazenam texto (~string~), por exemplo.

Para criar uma variável basta escolher um nome válido e usar o sinal de igual (~=~). O sinal de igual também é chamado de /operador de atribuição/ pois ele atribui um valor a uma variável.

*[A]* Crie uma célula de código contendo o código abaixo. Execute esta célula e observe o que acontece. Na primeira linha do código abaixo o operador de atribuição está sendo usado. Comente sobre isso e comente o que ocorreu na linha 2.

#+begin_src python -n
  frase = "Olá, mundo!"
  print(frase)
#+end_src

#+RESULTS:
: Olá, mundo!

Quando criamos uma variável nova dizemos que a variável foi /declarada/. No código acima, a variável ~frase~ foi declarada na linha 1.

Quando criamos uma variável nova, precisamos indicar de alguma forma qual o /tipo/ dessa variável. A variável ~frase~ declarada acima é um texto. Chamamos textos em programação de variáveis do tipo ~string~. Para indicar que um objeto é uma ~string~ nós usamos aspas.

*[B]* Existem quatro formas diferentes de declarar variáveis do tipo ~string~ em Python como você pode ver no código abaixo. Crie 4 variáveis diferentes (fique a vontade para nomeá-las da forma que preferir), todas elas sendo ~strings~ e cada uma delas usando uma forma diferente de declaração. Cada uma destas variáveis deve conter um frase de um cientista, artista, escritor ou pensador famoso.

#+begin_src python
  texto_com_aspas_simples = 'Olá, Mundo!'
  texto_com_aspas_duplas = "Olá, Mundo!"
  texto_com_tres_aspas_simples = '''Olá, Mundo!'''
  texto_com_tres_aspas_duplas = """Olá, Mundo!"""
#+end_src

#+RESULTS:

Além de ~strings~, variáveis podem armazenar objetos de outros tipos. Variáveis podem armazenar valores numéricos, por exemplo. Veja no código abaixo diversas formas de declarar variáveis contendo valores numéricos. Note que para o Python, o separador decimal é o _ponto_ (~.~) e não a _vírgula_ (~,~). Muita atenção com essa distinção pois a vírgula tem outro significado em Python (veremos mais adiante) e não necessariamente vai acusar um erro no seu código!!

*[C]* Execute o código abaixo. Após a execução, utilize a função ~print~ junto com a função ~type~ para identificar os tipos das variáveis declaradas (veja um exemplo na linha 16). Quantos tipos diferentes você identificou? Quais foram eles? Na sua opinião, existe uma vantagem de termos diferentes formas de declarar números inteiros, reais e complexos?

#+begin_src python -n
  numero_inteiro = 10
  numero_inteiro_positivo = +10
  numero_inteiro_negativo = -10

  numero_real = 10.0
  numero_real_sem_digitos_depois_do_ponto = 10.
  numero_real_positivo = +10.0000
  numero_real_negativo = -10.0000
  numero_real_base_dez = 1.5e7
  pi = 3.1415

  numero_complexo = 2 + 3j
  numero_complexo_apenas_parte_imaginaria = 5j
  numero_complexo_apenas_parte_real = 1 + 0j

  print(type(numero_inteiro))
#+end_src

#+RESULTS:
: <class 'int'>

*[D]* Em uma célula de texto responda as perguntas:

1) Existe diferença de se criar uma string usando aspas simples ou duplas? Existe diferença de se criar uma string usando três aspas? Reflita sobre a resposta e busque informações na internet antes de escrever. Não se esqueça de colocar as fontes na sua resposta.
2) Qual a diferença entre um número real e um número inteiro? Observando o exemplo acima, qual seria a regra para definir números inteiros e números reais?
3) Qual a regra para declarar números complexos? O que é o ~j~ na declaração dos números complexos?
4) Na sua opinião, existe diferença entre as variáveis ~numero_inteiro~ e ~numero_inteiro_positivo~? Explique brevemente seu raciocínio.
5) Na sua opinião, existe diferença entre as variáveis ~numero_real~ e ~numero_real_positivo~ e ~numero_real_sem_digitos_depois_do_ponto~? Explique brevemente seu raciocínio. De que forma você faria para confirmar a sua resposta?

*[E]* O código abaixo /supostamente/ cria novas variáveis. No entanto, algumas das declarações parecem um tanto... diferentes... quem sabe até estranhas! Seu objetivo é testar cada uma destas declarações e separar as que funcionam das que não funcionam (as que não funcionam acusam um erro quando executadas). Para as declarações que não funcionam, descreva o erro que ocorreu e proponha uma correção.

#+begin_src python
  variavel_que_o_nome_termina_com_numero_100 = 1
  100_variavel_que_o_nome_comeca_com_numero = 1
  numero_do_agente_secreto = 007

  nome_da_variável_com_acento = True
  nome da variavel com espaco = True
  booleano_sem_primeira_letra_maiuscula = true

  espaco_entre_os_numeros = 100 000
  numero_com_sublinhado = 10_000_000

  numero_com_muitos_sinais_de_menos = -----10
  numero_com_muitos_sinais_de_mais = +++++10
  numero_com_muitos_sinais_de_mais_e_menos = +--++-10

  muitos_espacos_entre_o_sinal_de_igual     =      10
  nenhum_espaco_entre_o_sinal_de_igual=10

  texto = Olá, Mundo!
  texto = "Olá, Mundo!'
#+end_src

#+RESULTS:

*[F]* Explore e comente o que acontece quando declaramos variáveis com o mesmo nome.

Existem diversos outros tipos de variáveis que veremos ao longo desta apostila. Sempre que em dúvida, cheque o tipo da variável com a função ~type~.

** Buscando ajuda

#+begin_verse
"/Socorro! Eu preciso de alguém.
Socorro! Não uma pessoa qualquer.
Socorro! Você sabe que eu preciso de alguém.
Socorro!/"
     --- Help, The Beatles
#+end_verse

Nas práticas anteriores usamos a função ~print~ para exibir informações na forma de texto no próprio caderno de notas do Jupyter. A função ~print~ é uma /função embutida/ do Python. Isto quer dizer que qualquer usuário que tenha o Python instalado (idealmente na mesma versão que a sua) terá acesso a esta função sem a necessidade de executar nenhum passo adicional.

Na prática, nós já sabemos que a função ~print~ recebe como argumento o texto ou variável que será exibido. Argumentos de funções são as informações que estão dentro dos parênteses quando executamos as funções. Por exemplo, o argumento da função ~print~ em ~print(1234)~ é o número 1234. Funções podem receber um ou mais argumentos, bem como podem receber zero argumentos (tente rodar ~print()~ e veja o que acontece! Tente também rodar ~print(1234, 4321)~). Os argumentos das funções são definidos no momento quando a função é definida (veremos isso em mais detalhes mais adiante).

O que você faria se não soubesse o que função ~print~ faz? Digamos, por exemplo, que você viu essa função sendo usada em um código de Python na internet, mas não sabe sua funcionalidade. Como proceder? Algumas sugestões neste caso são:

1) Pesquisar na internet em busca de alguma página com explicações (Python é uma linguagem de programação muito usada, existe muito material didático disponível online);
2) Pesquisar na documentação oficial do Python disponível em português no link https://docs.python.org/pt-br/3/. Todas as funções embutidas de Python, por exemplo, estão descritas aqui: https://docs.python.org/pt-br/3/library/functions.html;
3) Usar a função ~help~ do próprio Python (tente rodar ~help(print)~ no seu caderno de notas e veja o que acontece);
4) Usar a sintaxe própria do Jupyter para buscar ajuda. Para isso basta digitar a função que quer saber mais informações junto com um sinal de interrogação, assim como mostra o exemplo abaixo.

#+begin_src python
  print?
#+end_src

*[A]* Escolha uma das quatro sugestões acima para ler mais sobre a função ~print~ do Python. Observe que a função ~print~ aceita diferentes argumentos, sendo eles: ~value~, ~file~, ~flush~, ~end~ e ~sep~. Escreva como foi sua busca (incluindo fontes) e descreva com suas palavras o que os argumentos ~end~ e ~sep~ fazem. Tente outras formas de busca caso julgue necessário.

*[B]* Para cada função abaixo, faça uma busca online (buscas 1 ou 2) e uma busca offline (buscas 3 ou 4) para entender o que estas funções fazem. Escreva como foi sua busca (incluindo fontes) e descreva com suas palavras o que estas funções fazem.

+ ~round~
+ ~pow~
+ ~oct~
+ ~abs~

* Operadores e estrutura de decisão
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_operadores
:EXPORT_OPTIONS: toc:t
:ID:       af8757f4-e890-4b3d-96ea-a9c2c73c39e5
:END:

** Operadores aritméticos

#+begin_quote
"/Dizia eu que a aritmética.../" --- Professor Girafalez, Chaves
#+end_quote

A linguagem Python contém diversos operadores aritméticos como adição (~+~), subtração (~-~), multiplicação (~*~), divisão (~/~) e exponencial (~**~). Estes operadores permitem realizar cálculos aritméticos com números inteiros, reais e complexos. _Cuidado_: em Python, a exponenciação é representada por dois asteriscos (~**~); não confundir com o acento circunflexo (~^~) que é o operador de exponenciação usado no Excel!

# *[A*]* Reescreva o código abaixo em uma célula do Jupyter e veja o que acontece. Comente porque o resultado da terceira linha foi ~90~ e não ~0~.

# #+begin_src python -n
#   print(1 + 1)
#   print(1 - 1 + 1 - 1)
#   print(-10 + 10 * 10)
#   print(10 / 2 * 5)
#   print(10 ** 10)
#   print(2 ** 1 / 2)
#   print(2 ** (1 / 2))
#   print((1 + 1j) / (1 - 1j))
# #+end_src

# #+RESULTS:
# : 2
# : 0
# : 90
# : 25.0
# : 10000000000
# : 1.0
# : 1.4142135623730951
# : 1j

A ordem de precedência dos operadores aritméticos (isto é, a ordem de execução dos operadores) segue a regra do PEMDAS: parênteses, exponencial, multiplicação, divisão, adição e subtração. Assim como na notação matemática, usamos parênteses para dar preferência para certas operações.

# *[B*]* Escreva 5 formas diferentes de se obter o número 12 usando os operadores aritméticos que aprendeu (por exemplo ~print(7 + 5)~). Certifique-se que usou todos os operadores aritméticos que você conhece neste exercício.

*[A]* Utilizando o Python como calculadora, compute:
1) Quantos segundos existem em 16 horas e 42 minutos?
2) Quantos centímetros existem em 72,8 milhas?
3) Se você percorrer 72,8 milhas em 16 horas e 42 minutos, qual a sua velocidade média em centímetros por segundo?
4) Quanto tempo você demoraria para percorrer a circunferência da Terra na linha do equador se permanecer na velocidade média obtida no item acima?

*[B]* Além dos operadores discutidos acima, existem diversos outros em Python. Dois operadores bastante úteis são a divisão inteira (~//~) e o módulo (~%~, também conhecido como resto da divisão inteira). Veja abaixo um exemplo de como usá-los. Teste estes operadores e descreva como eles funcionam (em caso de dúvida, busque ajuda assim como apresentado na seção Buscando Ajuda). Discorra brevemente sobre possíveis situações onde estes operadores podem ser úteis.

#+begin_src python
  print(10 // 3)
  print(17 % 2)
#+end_src

#+RESULTS:
: 3
: 1

_Atenção_: operadores aritméticos usualmente funcionam com qualquer combinação de números inteiros, reais ou complexos. No entanto, preste atenção no tipo do resultado final! Use a função ~type~ para checar os tipos das variáveis em caso de dúvida.

*[C]* Escreva e execute o código abaixo e comente sobre o resultado obtido quando somamos variáveis de tipos iguais e tipos diferentes.

#+begin_src python
  inteiro_mais_inteiro = 1 + 1
  print(type(inteiro_mais_inteiro))

  inteiro_mais_real = 1 + 1.5
  print(type(inteiro_mais_real))

  real_mais_real = 1.5 + 1.5
  print(type(real_mais_real))

  inteiro_mais_complexo = 10 + (1 - 2j)
  print(type(inteiro_mais_complexo))

  real_mais_complexo = 10.5 + (1 - 2j)
  print(type(real_mais_complexo))
#+end_src

#+RESULTS:
: <class 'int'>
: <class 'float'>
: <class 'float'>
: <class 'complex'>
: <class 'complex'>

*[D]* Escreva um código similar ao código acima, porém alterando o operador de adição pelo operador de divisão. Você obteve algum resultado inusitado? Comente.

# #+begin_src python
#   inteiro_mais_inteiro = 1 / 1
#   print(type(inteiro_mais_inteiro))
#
#   inteiro_mais_real = 1 / 1.5
#   print(type(inteiro_mais_real))
#
#   real_mais_real = 1.5 / 1.5
#   print(type(real_mais_real))
#
#   inteiro_mais_complexo = 10 / (1 - 2j)
#   print(type(inteiro_mais_complexo))
#
#   real_mais_complexo = 10.5 / (1 - 2j)
#   print(type(real_mais_complexo))
# #+end_src

# #+RESULTS:
# : <class 'float'>
# : <class 'float'>
# : <class 'float'>
# : <class 'complex'>
# : <class 'complex'>

*[Desafio]* Crie uma a variável chamada ~numero~ que armazena um número inteiro entre 1000 e 9999. _Usando apenas operadores aritméticos_, separe todos os dígitos da variável ~numero~ em 4 outras variáveis. Seu código deve funcionar para qualquer valor da variável ~numero~ dentro do domínio definido. Exemplo: o número 1234 deve ser separado em uma variável contendo o número 1, uma contendo o número 2, outra contendo o número 3 e a última contendo o número 4.

*[Desafio 2]* Durante um exercício de geometria, você decidiu realizar suas contas utilizando Python. Você escreveu o código abaixo em uma célula no seu caderno de notas Jupyter e o resultado que obteve foi inusitado! Por que o resultado é inusitado? Qual era o resultado esperado? Qual é a explicação para isso? Na sua opinião, este tipo de "problema" compromete o uso de Python como uma calculadora aritmética? _Dica_: quantos números reais existem entre zero e um?

#+begin_src python
  pi = 3.14
  valor = pi + 2
  print(valor)
#+end_src

#+RESULTS:
: 5.140000000000001

** Operadores lógicos

#+begin_quote
"/Existem 10 tipos de pessoas no mundo: as que sabem binário e as que não sabem./" --- Autor desconhecido
#+end_quote

Variáveis lógicas (também conhecidas como variáveis booleanas) são objetos que podem assumir apenas dois valores diferentes: verdadeiro ou falso. Na sintaxe de Python, escrevemos verdadeiro ou falso em inglês e com a primeira letra maiúscula: ~True~ ou ~False~.

Uma expressão booleana é uma expressão que, quando resolvida, resulta em um valor verdadeiro (~True~) ou em um valor falso (~False~). Expressões booleanas podem ser escritas com os operadores lógicos E (~and~), OU (~or~) e NÃO (~not~). Os operadores ~and~ e ~or~ são chamados de operadores binários pois requerem sempre dois argumentos para serem resolvidos. A sintaxe para usar estes operadores com os argumentos ~A~ e ~B~, por exemplo, é a seguinte: ~A and B~ e ~A or B~.

*[A]* Execute o código abaixo; comente sobre qual ou quais situações o operador ~and~ retorna o valor ~True~.

#+begin_src python
  print(True and True)
  print(True and False)
  print(False and True)
  print(False and False)

  print(False and False and False)
  print(False and False and True)
  print(False and True and True)
  print(True and True and True)
#+end_src

#+RESULTS:
: True
: False
: False
: False
: False
: False
: False
: True

Se quisermos, podemos rescrever o código acima usando variáveis para facilitar a visualização:

#+begin_src python
  A = True
  B = False

  print(A and A)
  print(A and B)
  print(B and A)
  print(B and B)

  print(B and B and B)
  print(B and B and A)
  print(B and A and A)
  print(A and A and A)
#+end_src

#+RESULTS:
: True
: False
: False
: False
: False
: False
: False
: True

*[B]* Escreva e execute um código similar ao código acima, substituindo ~and~ por ~or~; comente sobre qual ou quais situações o operador ~or~ retorna o valor ~True~.

O operador ~not~ é um operador unário; ele requer apenas um argumento para ser computado. A sintaxe para usar este operador com o argumento ~A~, por exemplo, é a seguinte: ~not A~.

*[C]* Escreva e execute o código abaixo e comente sobre como o operador ~not~ funciona.

#+begin_src python
  print(not True)
  print(not False)
#+end_src

#+RESULTS:
: False
: True

Operadores lógicos podem ser combinados na mesma declaração. Quando for fazer uma combinação de operadores lógicos, lembre-se de usar o parênteses para garantir a ordem de execução desejada.

#+begin_src python
  A = True
  B = False
  print((A or B) and not (B and A))
#+end_src

#+RESULTS:
: True

*[D]* É possível somar variáveis booleanas? Quanto vale ~True + True~? Quanto vale ~False + False~? Quanto vale ~True + False~? Descubra a resposta para estas questões usando o Jupyter e busque online ou em livros o motivo para o resultado obtido. Escreva sobre o que encontrou. _Observação_: note que essa possibilidade de somar variáveis booleanas é apenas uma característica de como o Python armazena as variáveis booleanas. Isso não funciona dessa forma em lógica matemática.

*[Desafio]* Faça um programa que calcula a tabela verdade de uma expressão lógica. O programa deve exibir todas as variáveis e seus valores verdade, bem como o valor verdade da expressão lógica arbitrária fornecida pelo usuário. Fica a seu critério como a expressão lógica é inserida pelo usuário (pode ser no formato de string, função, lista, etc). Este é um desafio recomendado para que já souber laço de repetição.

** Operadores de comparação

#+begin_quote
"/O bolo é uma mentira./" --- frase escrita na parede, Portal
#+end_quote

Operadores de comparação (também conhecidos como operadores relacionais) fazem exatamente o que o nome sugere: comparam dois objetos. O resultado dessa comparação é uma variável booleana (ou seja, pode ter o valor ~True~ ou ~False~).

Existem 6 operadores de comparação em Python:
+ igualdade (~==~)
+ diferença (~!=~)
+ maior que (~>~)
+ menor que (~<~)
+ maior ou igual que (~>=~)
+ menor ou igual que (~<=~)

*[A]* Suponha que ~A = 1~, ~B = 2~, ~C = 4~, ~D = 8~ e ~E = 16~. Atribua o valor verdadeiro ou falso para cada uma das expressões abaixo. Escreva um código em Python para checar se você acertou. Comente sobre como funcionam as expressões com mais de um operador de comparação.

#+begin_src python
  A == B
  A < B
  B > C
  D <= E
  A != E
  E >= D >= C
  A < C == D
  A + A != B
  A + A < B < C - B
  A + A <= B <= C - B
  A != B < C == E - D - C
#+end_src

#+RESULTS:
#+begin_example
False
True
False
True
True
True
False
False
False
True
True
#+end_example

_Cuidado_: é muito comum confundir o operador de atribuição (~=~) com o operador de comparação de igualdade (~==~). O operador de atribuição é usado para atribuir um valor a uma variável, por exemplo: ~A = 10~ atribui o valor 10 para a variável ~A~. Já o operador de comparação de igualdade responde a pergunta se os objetos sendo comparados são iguais. Neste caso, a expressão ~A == 10~ responde a pergunta se o valor armazenado em ~A~ é igual a 10 (resposta esta que pode ser ~True~ ou ~False~).

** Estrutura de decisão e operador condicional

#+begin_quote
"/Se você ouvir com muita atenção, a música finalmente chegará até você./" --- Stairway to Heaven, Led Zeppelin
#+end_quote

Em diversos momentos da vida nos adaptamos mediante às condições do ambiente. Por exemplo, ao sair de casa, /se/ estiver chovendo /então/ pegamos o guarda-chuva, /se não/ nós saímos de casa sem o guarda-chuva. Esta estrutura condicional também existe nas linguagens de programação. Em diversos momentos, queremos que a execução de certos comandos só ocorram caso uma ou mais condições sejam atendidas.

O exemplo do guarda-chuva pode ser escrito em Python. Vamos supor que a variável booleana ~esta_chovendo~ armazena o valor ~True~ caso esteja chovendo ou o valor ~False~ caso não esteja chovendo. Queremos armazenar na variável booleana ~pegar_guardachuva~ o valor de ~True~ para o caso onde vamos pegar o guarda-chuva e o valor de ~False~ para o caso onde não vamos pegar o guarda-chuva. O código abaixo ilustra uma forma possível de programar essa decisão em Python. Veja que a palavra "if" em inglês traduz para "se" em português e que a palavra "else" traduz para "se não". Fique à vontade para trocar o valor da variável ~esta_chovendo~ para ~False~ para ver o que acontece.

#+begin_src python -n
  esta_chovendo = True

  if esta_chovendo == True:
      pegar_guardachuva = True
      print("Vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

No código acima, a instrução ~if~ checa se a condição "~esta_chovendo == True~" é verdadeira. Esta condição será verdadeira se a variável ~esta_chovendo~ tiver o valor ~True~. Existem duas possibilidades:

1) Se a condição checada for /verdadeira/, o bloco do ~if~ será executado e o bloco do ~else~ será ignorado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão executadas e as linhas 7 e 8 não serão executadas);

2) Se a condição checada for /falsa/, o bloco do ~if~ será ignorado, e o bloco do ~else~ será executado (neste caso, isso quer dizer que as linhas 4 e 5 do código serão ignoradas e as linhas 7 e 8 serão executadas).

Independentemente do resultado do teste da condição, a primeira e a última linha do código serão executadas pois elas /não/ estão dentro da estrutura de decisão.

Observe que a sintaxe de estruturas de decisão requer que o bloco referente ao ~if~ e o bloco referente ao ~else~ estejam /indentados/. Indentação de código é quando utilizamos uma certa quantidade de espaços para agrupar visualmente linhas de código pertencentes a um mesmo bloco. Segundo o guia de estilo do Python (a PEP 8 que vimos lá na Introdução), é recomendado usar 4 espaços para cada indentação do seu código.

É bom saber que se seu código não estiver indentado corretamente, ele muito provavelmente não irá realizar a tarefa que você tinha em mente. Em certos casos, uma falha em indentar corretamente seu programa irá acusar um erro. Tente rodar o código abaixo e veja o que acontece (veja que ele é o mesmo código que vimos acima, porém sem indentação)[fn:: Aqui vale a pena comentar que o requisito de blocos de códigos estarem indentados é uma característica de algumas linguagens de programação, porém não todas! Códigos em ~C~, por exemplo, não têm esse requisito. Mesmo assim, é considerado bom estilo sempre indentar seu código para facilitar a leitura, independente da linguagem de programação que você está utilizando.].

#+begin_src python -n
  esta_chovendo = True

  if esta_chovendo == True:
  pegar_guardachuva = True
  print("Vou pegar o guarda-chuva")
  else:
  pegar_guardachuva = False
  print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

*[A]* Em que outros momentos da sua vida você faz escolhas seguindo uma estrutura condicional contendo /se/, /então/ e /se não/? Escreva (em português mesmo) sobre um destes momentos dizendo como você se comporta (tome como base o exemplo do guarda-chuva). Escreva um código de Python para a decisão que você descreveu.

É bastante comum nos depararmos com situações onde nossa decisão depende de mais de uma condição. Digamos, por exemplo, que só queremos pegar o guarda-chuva se estiver chovendo e se for um dia de semana (do contrário, decidimos que vamos ficar em casa e não precisamos do guarda-chuva). Uma solução para isso é adicionar um novo ~if~ ao código; veja o exemplo abaixo e note as diferentes indentações para indicar diferentes blocos de código. Note também que cada par de instruções ~if~ e ~else~ devem estar na mesma indentação. Isso significa que o ~else~ da linha 11 faz par com o ~if~ da linha 4. Da mesma forma, o ~else~ da linha 8 faz par com o ~if~ da linha 5.

#+begin_src python -n
  esta_chovendo = True
  final_de_semana = False

  if esta_chovendo == True:
      if final_de_semana == False:
          pegar_guardachuva = True
          print("Vou pegar o guarda-chuva")
      else:
          pegar_guardachuva = False
          print("Não vou pegar o guarda-chuva")
  else:
      pegar_guardachuva = False
      print("Não vou pegar o guarda-chuva")

  print("Fim do programa")
#+end_src

#+RESULTS:
: Vou pegar o guarda-chuva
: Fim do programa

*[B]* Descreva uma situação onde você precisa considerar duas condições para tomar uma decisão e escreva ela em um código de Python.

# A linguagem Python contém uma série de expressões que são o que chamamos de /açúcar sintático/. Um açúcar sintático é uma forma de comunicar uma informação de maneira mais fácil ou mais expressiva. O código acima pode ser reescrito da seguinte maneira:

# #+begin_src python -n
#   esta_chovendo = True
#   final_de_semana = False
#
#   if esta_chovendo:
#       if not final_de_semana:
#           pegar_guardachuva = True
#           print("Vou pegar o guarda-chuva")
#       else:
#           pegar_guardachuva = False
#           print("Não vou pegar o guarda-chuva")
#   else:
#       pegar_guardachuva = False
#       print("Não vou pegar o guarda-chuva")
#
#   print("Fim do programa")
# #+end_src

# *[D]* Teste o código acima e reporte se ele funciona da forma esperada. O que mudou em comparação com o original? Explique como funciona o açúcar sintático exemplificado acima. Na sua opinião, este tipo de açúcar sintático facilitou a sua leitura do código?

*[C]* Reescreva o código acima de forma que ele se comporte da mesma maneira, porém usando apenas uma instrução ~if~ e apenas uma instrução ~else~. _Dica_: pense em qual operador lógico poderia te ajudar aqui!

O código abaixo checa em qual faixa está um certo valor de pH fornecido (relembre o que é o pH lendo o artigo da [[https://pt.wikipedia.org/wiki/PH][Wikipedia]] caso necessário) e reporta para o usuário se sua solução é ácida, básica, neutra ou se houve algum equívoco e o valor de pH é inválido. Observe que a cláusula ~else~ é _opcional_ e não foi usada no código abaixo. Fique à vontade para testar o código abaixo com diferentes valores para a variável ~ph~.

#+begin_src python -n
  ph = 7

  if (ph < 0) or (ph > 14):
      print("pH inválido")

  if 0 <= ph < 6.5:
      print("pH ácido")

  if 6.5 <= ph <= 7.5:
      print("pH neutro")

  if 7.5 < ph <= 14:
      print("pH básico")
#+end_src

#+RESULTS:
: PH neutro

Imagine que você mediu o pH de um vinagre e obteve o valor de 2,5. Ao rodar o código acima, o programa irá te dizer "pH ácido" (teste e veja!). Veja que o programa poderia ter parado de rodar depois de resolver o ~if~ da linha 6 (afinal, não faz sentido checar se o pH é neutro ou básico após identificar que se trata de um pH ácido), porém ele _irá_ rodar os ~if~ das linhas 9 e 12 pois é assim que o programa foi escrito.

*[D]* Reescreva o código acima usando cláusulas ~else~ de forma que o programa não rode nenhuma cláusula ~if~ desnecessária para entregar a resposta ao usuário (isto é: após ter encontrado a resposta, nenhum outro ~if~ deve ser executado!).

Uma estrutura muito comum em programação é quando queremos dizer "se a condição testada não for verdadeira, então teste esta outra condição aqui". Para isso usamos a cláusula ~elif~ que seria um ~else~ com um ~if~ "grudados". O código abaixo é similar ao anterior, porém usando ~elif~

#+begin_src python -n
  ph = 7

  if 0 <= ph < 6.5:
      print("pH ácido")

  elif 6.5 <= ph <= 7.5:
      print("pH neutro")

  elif 7.5 < ph <= 14:
      print("pH básico")

  else:
      print("pH inválido")
#+end_src

#+RESULTS:
: pH neutro

O código acima checa se o pH é ácido. Caso seja ácido o programa exibe "pH ácido" para o usuário e nada mais será executado. Caso não seja ácido, o programa checa então se é neutro. Caso seja neutro o programa exibe "pH neutro" para o usuário e nada mais será executado. Caso não seja neutro também, o programa faz uma última checagem para confirmar se é um pH básico. Assim sendo, o usuário verá o texto "pH básico" e o programa se encerra. Se o pH não for ácido, nem neutro, nem básico, então podemos afirmar com segurança que o programa recebeu um valor inválido de pH.

*[E]* Escreva um programa similar ao programa do pH que checa alguma grandeza escalar e exibe para o usuário uma informação sobre esta grandeza. Utilize pelo menos duas cláusulas ~elif~ no seu programa.

# Além da estrutura de decisão ~if~ / ~else~ existe o /operador condicional/. É importante saber que ele existe, porém na maioria dos casos é preferível que você use a estrutura de decisão mesmo por ser uma construção mais legível. O exemplo abaixo mostra uma estrutura condicional (linhas 3 a 6) e o operador condicional (linha 8), ambos realizam a mesma tarefa. Note que a cláusula ~else~ é opcional na estrutura condicional porém obrigatória no operador condicional.

# #+begin_src python -n
#   condicao = True
#
#   if condicao:
#       a = 100
#   else:
#       a = 5
#
#   a = 100 if condicao else 5
# #+end_src
#
# #+RESULTS:

*[F]* Escreva um código que tem uma variável inteira chamada ~numero~. Este código deve reportar ao usuário se este número é par ou ímpar.

*[G]* Escreva um programa que tem três variáveis numéricas ~a~, ~b~ e ~c~. O programa deve exibir ao usuário os valores contidos em ~a~, ~b~ e ~c~ em ordem crescente. Ele deve funcionar para qualquer valor numérico de ~a~, ~b~ e ~c~.

*[Desafio]* Escreva um programa que contém uma variável inteira positiva chamada ~ano~. O programa deve mostrar ao usuário se o ano em questão é um ano bissexto ou não. As regras para um ano ser bissexto são as seguintes:

1) Se o ano é divisível por 4, execute o passo 2. Do contrário, vá ao passo 5.
2) Se o ano é divisível por 100, execute o passo 3. Do contrário, vá ao passo 4.
3) Se o ano é divisível por 400, vá ao passo 4. Do contrário, vá ao passo 5.
4) Conclusão: o ano é bissexto!
5) Conclusão: o ano não é bissexto!

*[Desafio 2]* Escreva um programa que contém uma variável inteira chamada ~numero~. Esta variável armazena um número que deve estar entre 1000 e 9999. O programa deve checar se esse número é um número palíndromo e reportar essa informação ao usuário. Um número palíndromo é aquele que tem o mesmo valor quando a ordem dos seus dígitos é invertida, por exemplo:
1) o número 1234 não é número palíndromo pois é diferente de 4321.
2) o numero 3223 é um número palíndromo.

** Uma breve introdução sobre estilo

#+begin_verse
"/Bonito é melhor que feio.
Explícito é melhor que implícito.
Simples é melhor que complexo.
Complexo é melhor que complicado.
Linear é melhor do que aninhado.
Esparso é melhor que denso.
Legibilidade conta./"
     --- [[https://www.python.org/dev/peps/pep-0020/][O Zen do Python]]
#+end_verse

#+begin_quote
"/Devia ter complicado menos.../" --- Epitáfio, Titãs
#+end_quote

Em geral, programadores gastam muito mais tempo /lendo/ código do que /escrevendo/ código. Toda vez que recebemos um código escrito por outra pessoa, temos que ler para entender o que ele faz (exemplo: todos os códigos desta apostila). Toda vez que vamos corrigir um problema no código que nós escrevemos, devemos ler para identificar o local da correção. Toda vez que vamos adicionar uma nova funcionalidade para um código já escrito, devemos ler para entender a melhor forma de implementar essa adição.

Quando estamos lendo um código, nossa cabeça está "compilando" o que lemos internamente, isto é: estamos montando as peças do quebra-cabeça que é o que o código faz. Veja que isso não é diferente de ler algo em português! Esta frase que você está lendo agora é apenas um amontoado de letras para uma pessoa que não sabe português, mas para você ela faz sentido e comunica algo pois você sabe interpretar a linguagem.

Veja o código abaixo. Qual você acha que é o valor exibido pela função ~print~? Está bastante claro, não é? Trata-se de um código trivial para quem sabe o tanto de Python que você já sabe.

#+begin_src python
  x = 10
  y = x + x
  print(y)
#+end_src

#+RESULTS:
: 20

Agora veja o código abaixo. Novamente, qual valor você acha que é o valor exibido pela função ~print~? A verdade é que é exatamente o mesmo valor do código acima (teste no Jupyter!). No entanto, este código foi escrito de propósito para ser ilegível (nem parece que funciona, não é?). O objetivo dessa provocação é mostrar que existem diversas formas de realizar uma mesma tarefa em Python. Neste exemplo, uma delas é trivial de ler enquanto a outra demanda muito tempo para ser entendida!

#+begin_src python
  x = 2 ** \
      6 \
      / 6.4
  y = (
      [x +
       [
          x * \
           x // \
           x
      ][0]
       ][0]
  )
  print(y)
#+end_src

#+RESULTS:
: 20.0

Em geral, um código que funciona é /melhor/ que um código que não funciona. Porém, um código legível que funciona é /bem melhor/ que um código que apenas funciona. É muito tentador escrever códigos que funcionam sem se preocupar que eles sejam legíveis... cuidado para não cair no paradigma do POG ([[https://www.livropog.com.br/][Programação Orientada à Gambiarra]]).

# *[A]* Escreva um código que executa uma tarefa simples, porém escreva-o da forma mais ilegível que você conseguir. Troque o seu código com um colega e tente entender o código que recebeu antes de executá-lo no Python.

Veja que nem sempre conseguimos nos expressar em Python de forma que a leitura seja trivial. Isso acontece em qualquer linguagem! Existem certos conceitos e tarefas que simplesmente são complexos de serem representados. Isso é normal! Para facilitar nossas vidas, em programação existe o conceito de /comentários/. Comentários são linhas de texto ao longo do código que são ignoradas pelo compilador quando o código é executado. Comentários servem para ajudar quem está lendo o código a entender mais facilmente o que ele faz. É uma forma do criador do código de se comunicar com seu leitor sem que isso interfira na execução do código em si. Veja o exemplo abaixo.

#+begin_src python
  # este é um comentário. Tudo que está após o `#` será ignorado pelo Python
  x = -10

  y = abs(x)  # `y` recebe o valor absoluto de `x` (explicação na linha)

  # exibe o valor de `y` (explicação antes do que será executado)
  print(y)
#+end_src

#+RESULTS:
: 10

Para iniciantes é recomendado sempre comentar seu código. Isso não só irá te ajudar a organizar suas ideias mas também ajudar quem for ler seu código a entender o que ele faz. Em níveis intermediários, recomenda-se deixar comentários apenas em partes do código que não são triviais de se entender.

*[A]* Escreva um código que calcula as raízes de uma equação de segundo grau $f(x) = ax^2 + bx + c$ usando a fórmula de Bhaskara. Comente todas as etapas do seu código. Siga o modelo abaixo.

#+begin_src python
  # valores dos coeficientes (pode alterar se quiser)
  a = 10
  b = 3
  c = -5

  # delete este comentário e escreva seu código aqui.

  # mostra as raízes para o usuário
  print(raiz_1)
  print(raiz_2)
#+end_src

*[Desafio]* Escreva um código que resolve um problema de física, matemática, química ou biologia a sua escolha. Escreva um comentário com seu nome, a data e o que seu código faz. Escreva um comentário em cada etapa que considere não-trivial do seu código.

# *[D*]* Escreva em uma célula o código abaixo e execute. Nós ainda não vimos essa sintaxe, mas mesmo assim tente e veja o que acontece. A mensagem exibida é um poema chamado /O Zen do Python/. Veremos adiante que a sintaxe com a instrução ~import~ é usada para carregar (importar) módulos. Neste caso, o ~import this~ não faz nada mais do que exibir o poema, mas veremos adiante que a instrução ~import~ é absurdamente útil e importante!

# #+begin_src python
#   import this
# #+end_src

* Funções
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_funcoes
:EXPORT_OPTIONS: toc:t
:ID:       b20f8635-108a-49d4-9903-6a397dc4fed2
:END:

** O que é uma função?

#+begin_quote
"/É função da ciência descobrir a existência de um regime geral de ordem na natureza e encontrar as causas que governam esta ordem./" --- Dmitri Mendeleev
#+end_quote

Durante o exercício "Olá, Mundo!" nós utilizamos a função ~print~. Naquele momento, definimos funções como sendo "apelidos" para executar códigos que já foram escritos. De fato, esta é uma das grandes vantagens de funções: você escreve o código apenas uma vez e reaproveita ele quantas vezes forem necessárias! Além de economizar tempo, o uso apropriado de funções deixa o propósito do código mais fácil de ser entendido.

De maneira geral, uma função tem quatro partes:

1) um /nome/,
2) zero ou mais objetos chamados de /argumento/,
3) um bloco de código chamado de /corpo da função/,
4) zero ou mais objetos chamados de /retorno/.

Basicamente, ao executar uma função ela recebe zero ou mais objetos (argumento), executa seu bloco de código (usando ou não os argumentos recebidos) e retorna zero ou mais objetos (retorno). Veja que o conceito de função em programação não é o mesmo que o conceito de função em matemática. Certas funções em programação podem ser chamadas de funções matemáticas, porém não todas!

** Funções embutidas

#+begin_quote
"/Vou querer Spam, Spam, Spam, Spam, Spam, Spam, feijão cozido, Spam, Spam, Spam e Spam!/" --- Sr. Bun, Monty Python's Flying Circus
#+end_quote

Existem diversas funções embutidas em Python. Estas funções podem ser usadas _a qualquer momento_, sem a necessidade de executar nenhum comando prévio. Além das funções embutidas que já vimos (~print~ e ~help~, por exemplo) existem diversas outras! A lista completa pode ser conferida na [[https://docs.python.org/pt-br/3/library/functions.html][documentação oficial]].

# *[A]* Para cada uma das funções embutidas abaixo, escreva em uma célula de texto o nome da função, descreva seus argumentos, explique em suas palavras o que a função faz e descreva seus valores de retorno. Na célula seguinte, escreva um código que use esta função. Comente seu código!

# + ~any~
# + ~all~
# + ~len~
# + ~abs~

** Definindo novas funções

#+begin_quote
"/Definir é limitar./" --- Oscar Wilde, O Retrato de Dorian Gray
#+end_quote

Podemos definir nossas próprias funções utilizando a instrução ~def~. O código abaixo mostra diversos exemplos de definições de funções. Observe que todas as definições começam com ~def~, seguido do nome da função, seguido de parêntesis e por fim dois-pontos. É considerado bom estilo pular duas linhas antes e depois da definição de funções e nomear funções com a primeira letra minúscula. Ao fim do código abaixo, as funções definidas são executadas. Para executar funções basta escrever o nome delas seguido de parênteses (os argumentos vão dentro destes parênteses).

#+begin_src python -n
  def funcao_1():
      print("Esta é a função 1")


  def funcao_2(argumento1):
      print("Esta é a função 2")
      print(argumento1)


  def funcao_3(argumento1, argumento2):
      print("Esta é a função 3")
      print(argumento1)
      print(argumento2)


  def funcao_4(argumento1, argumento2):
      print("Esta é a função 4")
      soma = argumento1 + argumento2
      return soma


  def funcao_5(argumento1, argumento2):
      print("Esta é a função 5")
      return 10


  def funcao_6(argumento1, argumento2, argumento3):
      print("Esta é a função 6")
      return argumento3, argumento2, argumento1


  print('Testando a funcao_1')
  retorno = funcao_1()
  print(retorno)
  print()

  print('Testando a funcao_2')
  retorno = funcao_2("Olá")
  print(retorno)
  print()

  print('Testando a funcao_3')
  retorno = funcao_3("Olá", "mundo")
  print(retorno)
  print()

  print('Testando a funcao_4')
  retorno = funcao_4(1, 2)
  print(retorno)
  print()

  print('Testando a funcao_5')
  retorno = funcao_5(1, 2)
  print(retorno)
  print()

  print('Testando a funcao_6')
  retorno = funcao_6("a", "b", "c")
  print(retorno)
  print()

  print('Testando a funcao_6 novamente')
  retorno1, retorno2, retorno3 = funcao_6("a", "b", "c")
  print(retorno1, retorno2, retorno3)
  print()
#+end_src

#+RESULTS:
#+begin_example
Testando a funcao_1
Esta é a função 1
None

Testando a funcao_2
Esta é a função 2
Olá
None

Testando a funcao_3
Esta é a função 3
Olá
mundo
None

Testando a funcao_4
Esta é a função 4
3

Testando a funcao_5
Esta é a função 5
10

Testando a funcao_6
Esta é a função 6
('c', 'b', 'a')

Testando a funcao_6 novamente
Esta é a função 6
c b a

#+end_example

A ~funcao_1~ não recebe nenhum argumento. Sabemos que este é o caso pois não existe nenhuma informação dentro dos parênteses logo após o comando ~def funcao_1~. Quando executada, esta função exibe a mensagem "Esta é a função 1". Não existem valores de retorno pois em nenhum local do corpo da função existe a instrução ~return~. Funções que não possuem valor de retorno explícito sempre retornam ~None~ quando encerram sua execução. ~None~ é o chamado /objeto nulo/ e ele passa a mensagem que não existe valor associado ao objeto. Observe que ~None~ não significa o valor zero nem o valor ~False~.

A ~funcao_2~ recebe um argumento chamado ~argumento1~. Todos os argumentos recebidos pelas funções podem ser utilizados no corpo da função. No caso desta função, o valor do ~argumento1~ é exibido ao usuário através da função ~print~. Novamente, não existem valores de retorno.

A ~funcao_3~ recebe dois argumentos, ~argumento1~ e ~argumento2~. Note que os nomes dos argumentos são separados por vírgula. Funções podem ter quantos argumentos forem necessários, desde que todos eles sejam declarados no local apropriado (isto é, dentro dos parênteses). Novamente, não existem valores de retorno.

A ~funcao_4~ recebe dois argumentos, calcula a soma deles e retorna este valor. O retorno do valor é feito pela instrução ~return~ no corpo do da função. Observe na linha 48 como podemos armazenar o valor retornado pela função em uma variável.

A ~funcao_5~ recebe dois argumentos e retorna o valor 10. Observe que não é necessário utilizar os argumentos da função no corpo da mesma. No entanto, não é uma boa prática definir argumentos que não serão utilizados no corpo da função! Evite este tipo de comportamento.

Finalmente, a ~funcao_6~ recebe três argumentos e retorna os mesmos argumentos em ordem inversa . Observe que a instrução ~return~ permite retornar mais que um valor. Se retornar mais que um valor, estes devem estar separados por vírgulas. Na linha 58 temos uma situação inusitada: a ~funcao_6~ retorna três valores, mas estamos atribuindo o retorno desta função a apenas uma variável chamada ~retorno~. Se você rodar este código perceberá que não ocorrem erros. Neste caso, os três valores de retorno são agrupados em um objeto chamado de /tupla/ e armazenados na variável ~retorno~ (veremos tuplas mais adiante). Observe a sintaxe da linha 63 para ver como separar os valores de retorno em variáveis independentes.

*[A]* Crie e execute funções para realizar as tarefas abaixo:

+ Uma função que recebe um valor numérico e retorna o cubo deste valor.
+ Uma função que recebe cinco valores e retorna o valor médio e o desvio padrão destes valores.
+ Uma função que recebe três números e retorna os números recebidos em ordem decrescente.

*[B]* Crie uma função que recebe um argumento e tente executar ela sem fornecer nenhum argumento. Após este teste, tente executar ela fornecendo dois argumentos quaisquer. Observe e relate o que aconteceu.

*[C]* Execute o código abaixo e comente o que ocorre quando executamos a linha 6. Nesta linha a função ~ola~ foi executada sem os parênteses. Seu código rodou com erro ou se erro? De qualquer forma elabore o que aconteceu.

#+begin_src python -n
  def ola():
      return "Olá!"


  print(ola())
  print(ola)
#+end_src

#+RESULTS:
: Olá!
: <function ola at 0x7f69502dfd90>

*[Desafio]* Escreva uma função que recebe 5 argumentos numéricos e retorna o valor do segundo maior número recebido.

*[Desafio 2]* Escreva uma função que recebe 5 argumentos numéricos e exibe todos os valores únicos que recebeu (isto é, não exibe valores repetidos).

** Argumentos posicionais, argumentos nomeados e argumentos com valor padrão

#+begin_quote
"/O raciocínio é um argumento em que, estabelecidas certas coisas, outras coisas diferentes se deduzem necessariamente das primeiras./" --- Aristóteles
#+end_quote

A ordem dos argumentos é muito importante durante a execução de funções com dois ou mais argumentos. O exemplo abaixo ilustra isso: a inversão da ordem dos argumentos altera o resultado do retorno da função. Cada argumento de uma função tem a sua _posição_, então é necessário se atentar a ordem dos argumentos para evitar erros.

#+begin_src python
  def exponenciacao(base, expoente):
      return base ** expoente


  print(exponenciacao(10, 2))  # resulta em 100
  print(exponenciacao(2, 10))  # resulta em 1024
#+end_src

#+RESULTS:
: 100
: 1024

Todo argumento tem um _nome_[fn:: Na verdade, veremos adiante que existem casos onde argumentos podem não ter nome, são os chamados argumentos estrela. Não se preocupe com isso agora.]. Na função ~exponenciacao~ acima temos dois argumentos, um chamado de ~base~ e outro de ~expoente~. Podemos executar essa função chamando os argumentos pelo nome! Veja no exemplo abaixo.

#+begin_src python -n
  def exponenciacao(base, expoente):
      return base ** expoente


  print(exponenciacao(base=10, expoente=2))  # resulta em 100
  print(exponenciacao(expoente=2, base=10))  # resulta em 100
  print(exponenciacao(10, expoente=2))       # resulta em 100
  print(exponenciacao(expoente=2, 10))       # ERRO!
  print(exponenciacao(expoente=2))           # ERRO!
  print(exponenciacao(base=10))              # ERRO!
#+end_src

#+RESULTS:
: 100
: 100
: 100

Na linha 5 acima, a função ~exponenciacao~ é executada com seus argumentos chamados pelo nome.

Na linha 6 vemos que não é necessário apresentar os argumentos nomeados seguindo a mesma ordem dos argumentos assim como definida na função. Isso funciona desde que todos os argumentos tenham um valor atribuído no momento de execução da função.

Na linha 7 vemos que é possível misturar argumentos nomeados com argumentos posicionais. Neste caso, o valor "10" está na posição zero, logo ele será atribuído à variável ~base~ da função ~exponenciacao~. O valor do argumento ~expoente~ foi nomeado durante a execução e atribuído o valor de "2".

A linha 8 parece similar a linha 7, porém ela acusa um erro quando executada!! Isso porque não é permitido argumentos posicionais /após/ argumentos nomeados. Se você for utilizar uma mistura de argumentos posicionais com nomeados, certifique-se que os argumentos nomeados estão todos após os argumentos posicionais.

As linhas 9 e 10 mostram que precisamos garantir que todos os argumentos tenham valores atribuídos, do contrário a função não executa.

Argumentos nomeados ajudam na leitura do código, principalmente quando as funções e argumentos receberam bons nomes. Por exemplo: as linhas 5 e 6 do código acima deixam bem clara a intenção do código.

Por fim, além de uma posição e um nome, argumentos opcionalmente podem ter um _valor padrão_. O valor padrão é atribuído com o operador de atribuição ~=~ logo após o nome do argumento. Veja o exemplo abaixo.

#+begin_src python -n
  def exponenciacao(base, expoente=5):
      return base ** expoente


  print(exponenciacao(base=10, expoente=2))  # resulta em 100
  print(exponenciacao(base=10))              # resulta em 100000
  print(exponenciacao(10))                   # resulta em 100000
  print(exponenciacao(expoente=2))           # ERRO! Falta o valor da base
#+end_src

#+RESULTS:
: 100
: 100000
: 100000

A nova função ~exponenciacao~ tem um valor padrão para o argumento expoente (no caso, é o valor 5). Ela continua funcionando da mesma maneira que a função anterior. Execute a linha 5 e verá que isso é verdade. Com o valor padrão do argumento ~expoente~, podemos executar as linhas 6 e 7 sem problema. Em ambos os casos, nós informamos apenas o valor do argumento ~base~ quando executamos a função. Ao fazer isso, estamos dizendo à função que ela deve usar o valor padrão para o argumento ~expoente~. Finalmente, a linha 8 resulta em um erro pois o valor para o argumento ~base~ não foi informado para a execução da função ~exponenciacao~.

Observe que não é permitido declarar argumentos sem valor padrão após argumentos com valor padrão. Por conta disso o código abaixo resulta em erro ao ser executado.

#+begin_src python
  def exponenciacao(base=10, expoente):
      return base ** expoente
#+end_src

*[A]* Crie uma função que tira a n-ézima raiz de um número. Faça com que o índice da raiz tenha um valor padrão de 2.

*[B]* Crie uma função que recebe o raio de um círculo e retorna seu perímetro e sua área.

** Variáveis globais e variáveis locais

#+begin_quote
"/Pense globalmente, aja localmente./" --- Paul McCartney
#+end_quote

Variáveis criadas dentro de funções são /locais/ e só existem dentro do escopo da função.

*[A]* Teste se a afirmação acima é verdade executando o código abaixo. Relate o que aconteceu.

#+begin_src python -n
  def refeicao():
      opcao_1 = "SPAM"
      opcao_2 = "SPAM"
      opcao_3 = "ovos"
      opcao_4 = "bacon"
      return opcao_1, opcao_2, opcao_3, opcao_4

  lanche_da_tarde = refeicao()
  print(opcao_1)
#+end_src

#+RESULTS:

No código acima a função ~refeicao~ declara internamente 4 variáveis, sendo elas ~opcao_1~, ~opcao_2~, ~opcao_3~ e ~opcao_4~. Executamos essa função na linha 8 e na linha 9 tentamos exibir o valor da variável ~opcao_1~. Entretanto, o compilador acusa um erro nos dizendo que a variável ~opcao_1~ não existe! Isso ocorre pois a variável ~opcao_1~ foi declarada /dentro do escopo/ da função ~refeicao~ e ela só existe dentro do escopo onde foi declarada. Após o término da execução da função todas as suas variáveis locais são _destruídas_ para liberar memória.

Variáveis declaradas fora do escopo de funções são variáveis /globais/. Variáveis globais podem ser acessadas em _qualquer escopo_, inclusive dentro do escopo de funções!

*[B]* Tendo em mente o que foi discutido, escreva e justifique o que você acha que irá acontecer se executarmos o código abaixo. Rode o código para checar se seu palpite estava certo.

#+begin_src python
  melhor_album = "The Dark Side of the Moon"  # esta é uma variável global


  def qual_o_melhor_album():
      print("O melhor album de todos os tempos é :")
      print(melhor_album)


  qual_o_melhor_album()
#+end_src

#+RESULTS:
: O melhor album de todos os tempos é :
: The dark side of the moon

Mesmo sabendo que variáveis globais podem ser utilizadas dentro de funções, este comportamento é _desencorajado_! Isso torna a leitura do código mais difícil, o uso da função menos geral e aumenta a chance de /bugs/ no seu código! Se necessário utilizar uma variável global em uma função, opte por adicionar um argumento com a variável global como valor padrão.

*[C]* O que acontece quando um argumento de uma função tem o mesmo nome de uma variável global? Teste isso escrevendo seu próprio código e explique em suas palavras o que observou.

*[D]* O que acontece quando uma variável global é alterada dentro de uma função? Explique em suas palavras o que observou.

** Documentando suas funções com a docstring

#+begin_quote
"/Depois de tudo o que passamos. Tudo o que eu fiz. Isto não pode ser em vão./" --- Ellie, The Last of Us
#+end_quote

Funções podem ser tão simples ou tão complexas quanto quisermos. As versões mais recentes do Python permitem que as funções tenham quantos argumentos e retornos nós desejarmos. Também não há limites quanto a quantidade de linhas de código no corpo da função.

Mas como dizia o tio Ben: com grandes poderes vem grandes responsabilidades! Você pode escrever hoje a função mais complexa do mundo e resolver todos os seus problemas. Tudo certo enquanto a função está fresca na sua mente. Daqui a três meses você precisa utilizar essa função novamente e já não se recorda mais o que cada argumento controla, não entende mais o valor de retorno e não tem tempo de interpretar as doze mil linhas de código que compõe o corpo da função... e agora?

Uma solução para +evitar+ reduzir dor de cabeça no futuro é documentar sua função escrevendo a chamada /docstring/. Documentar a função nada mais é do que escrever o que ela faz, detalhando todas as partes importantes para que qualquer um que venha a usar a função entenda qual é o seu propósito e o que pode esperar quando executá-la. O guia de estilo de docstrings em Python é a PEP 257 e pode ser acessada em https://www.python.org/dev/peps/pep-0257/.

A docstring mais simples de todas é a "docstring em uma linha". Trata-se de uma descrição breve do que a função faz e, como o nome sugere, não deve ultrapassar uma linha. Veja a docstring da função ~soma_pares~ na linha 2 abaixo. Note que docstrings devem ser a primeira linha do corpo da função (logo abaixo a definição da mesma) e são strings declaradas com três aspas. Na descrição em uma linha, use verbos no imperativo! Podemos acessar a docstring de qualquer função usando o comando ~help~ (veja a linha 20) ou acessando o atributo especial ~__doc__~ (veja a linha 22).

#+begin_src python -n
  def soma_pares(numero1, numero2, numero3):
      """Recebe três números e soma apenas os pares."""
      soma = 0

      if numero1 % 2 == 0:
          soma = soma + numero1

      if numero2 % 2 == 0:
          soma = soma + numero2

      if numero3 % 2 == 0:
          soma = soma + numero3

      return soma


  print(soma_pares(10, 5, 6))

  print()
  help(soma_pares)  # mostra informações sobre a função

  print(soma_pares.__doc__)  # mostra a doscring da função
#+end_src

#+RESULTS:
: 16
:
: Help on function soma_pares in module __main__:
:
: soma_pares(numero1, numero2, numero3)
:     Recebe três números e soma apenas os pares.
:
: Recebe três números e soma apenas os pares.

*[A]* Escreva uma função que recebe três números e retorna a multiplicação de todos os números ímpares. Escreva uma docstring em uma linha para sua função.

Docstrings em uma linha são suficientes para funções mais simples com poucas linhas de código. Funções mais complexas se beneficiam de mais informações na docstring para deixar claro seu funcionamento, como por exemplo:

1) Uma descrição mais aprofundada da função;
2) Uma listagem de todos os argumentos da função, descrevendo o que eles controlam;
3) Uma listagem de todos os retornos da função, descrevendo o que eles são;
4) Uma listagem de todos os erros capturados e levantados pela função;
5) Exemplos do uso da função;
6) Notas e informações adicionais como links e referências.

Para armazenar mais informações, precisamos fazer uso das "docstrings de múltiplas linhas". A PEP 257 não define como docstrings de múltiplas linhas devem ser escritas e, por conta disso, existem diversos guias de estilos diferentes. Nenhum estilo é objetivamente melhor ou pior que o outro, no entanto é considerado bom costume escolher um estilo para cada projeto e se ater a ele (misturar diferentes estilos pode confundir quem está lendo o código!). Esta apostila segue o Guia de Estilo de Python da Google que pode ser conferido em https://google.github.io/styleguide/pyguide.html?showone=Comments#s3.8.1-comments-in-doc-strings. Veja um exemplo abaixo.

#+begin_src python -n
  def soma_pares_ou_impares(numero1, numero2, numero3, tipo="pares",
                            verbose=False):
      """Recebe três números e retorna a soma dos pares ou ímpares.

      O cálculo da soma depende do argumento `tipo`. Cuidado, se o valor do
      argumento tipo não estiver correto o programa acusa um erro!

      Args:
        numero1:
          Um número inteiro qualquer.
        numero2:
          Um número inteiro qualquer.
        numero3:
          Um número inteiro qualquer.
        tipo:
          String que pode ter o valor `pares` ou `impares`. Controla quais números
          serão considerados para a soma. Valor padrão é `pares`.
        verbose:
          Booleano que controla se o resultado final será exibido ao usuário.
          `True` exibe o resultado. Valor padrão é `False`.

      Returns:
        Soma dos números pares ou ímpares.

      Raises:
        ValueError: ocorre se a variável `tipo` recebe um valor inválido.
      """

      if tipo == "pares":
          resto_divisao_por_dois = 0
      elif tipo == "impares":
          resto_divisao_por_dois = 1
      else:
          raise ValueError("Valor incorreto da variável `tipo`.")

      soma = 0

      if numero1 % 2 == resto_divisao_por_dois:
          soma = soma + numero1

      if numero2 % 2 == resto_divisao_por_dois:
          soma = soma + numero2

      if numero3 % 2 == resto_divisao_por_dois:
          soma = soma + numero3

      if verbose:
          print(soma)

      return soma


  soma_pares = soma_pares_ou_impares(10, 5, 6, "pares", True)
  soma_impares = soma_pares_ou_impares(10, 5, 6, "impares", True)

  # da erro!
  soma_complexos = soma_pares_ou_impares(10, 5, 6, "complexos", True)
#+end_src

#+RESULTS:
: 16
: 5

Vamos analisar as diversas partes do exemplo acima:

1) A primeira linha da docstring (linha 3) ainda é a descrição da função em uma linha. Ela sempre deve estar presente.

2) Na linha 5 temos a descrição mais aprofundada da função. Use quantas linhas quiser para essa descrição. Esta descrição não é obrigatória.

3) Na linha 8 damos início a descrição dos argumento com o cabeçalho ~Args:~. O nome de cada argumento é escrito com indentação de dois espaços seguido de dois-pontos. A descrição de cada argumento é feita com indentação de quatro espaços e pode conter quantas linhas quiser. Descreva o tipo de variáveis esperadas e o que o argumento controla. Conte para o leitor os valores esperados caso existam e deixe claro qual é o valor padrão quando for o caso. Esta seção é obrigatória caso a função receba um ou mais argumentos.

4) Na linha 22 damos início a descrição dos valores de retorno com o cabeçalho ~Returns:~. Aqui nós contamos quais os valores de retorno e o tipo deles, podemos usar quantas linhas forem necessárias. Esta seção é obrigatória caso existam retornos.

5) Na linha 25 damos início a descrição dos possíveis erros levantados pelo código. Estes são erros deliberadamente programados no corpo da função. Veremos mais sobre erros na seção de depuração de programas, mas por hora é relevante saber que se a variável ~tipo~ tiver um valor fora do esperado, a própria função acusa um erro e envia uma mensagem ao usuário para que ele possa corrigir seu código. Esta seção é obrigatória caso exista gerência de erros no corpo da função (instruções ~raise~ e ~assert~).

*[B]* Crie uma função com pelo menos três argumentos e escreva uma docstring em múltiplas linhas para ela. Sua função deve executar um código que tenha relevância científica.

** Funções também são objetos!

#+begin_quote
"/As vezes não é nada fácil encontrar uma citação minimamente relacionada ao tópico em questão."/ --- Daniel Cassar
#+end_quote

Funções em Python são objetos assim como números e strings. Desta forma, podemos passar funções como argumentos de funções (linhas 16, 19, 32 e 35 do código abaixo) e podemos ter funções como valores de retorno de outras funções (veja a linha 29)! Podemos inclusive definir novas funções no corpo de funções (linha 26).

#+begin_src python -n
  def soma_dois(x):
      """Soma dois a o valor recebido."""
      return x + 2


  def multiplica_dois(x):
      """Multiplica o valor recebido por dois."""
      return x * 2


  def aplica_funcao_composta(f1, f2, x):
      """Calcula a função composta de f1 e f2."""
      return f1(f2(x))


  retorno = aplica_funcao_composta(soma_dois, multiplica_dois, 10)
  print(retorno)  # mostra o número 22

  retorno = aplica_funcao_composta(multiplica_dois, soma_dois, 10)
  print(retorno)  # mostra o número 24


  def retorna_funcao_composta(f1, f2):
      """Retorna a função composta de f1 e f2."""

      def funcao_composta(x):
          return f1(f2(x))

      return funcao_composta


  funcao_composta = retorna_funcao_composta(soma_dois, multiplica_dois)
  print(funcao_composta(10))  # retorna 22

  funcao_composta = retorna_funcao_composta(multiplica_dois, soma_dois)
  print(funcao_composta(10))  # retorna 24
#+end_src

#+RESULTS:
: 22
: 24
: 22
: 24

*[Desafio]* Escreva uma função chamada ~poli~ que recebe um argumento chamado ~x~ e mais $n$ argumentos ($n > 2$) chamados de ~c_0~, ~c_1~, ... Estes argumentos que começam com a letra ~c~ serão os coeficientes de um polinômio de grau $n$. A função ~poli~ recebe todos estes argumentos e calcula o valor do polinômio no ponto ~x~. Agora crie uma função chamada ~integral~ que recebe 3 argumentos: ~a~, ~b~ e ~fun~. A função ~integral~ deve computar numericamente a integral entre ~a~ e ~b~ da função ~fun~. Teste sua função ~integral~ usando a função ~poli~. Não se esqueça de documentar suas funções com docstrings!

* Listas, tuplas e conjuntos
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_listas
:EXPORT_OPTIONS: toc:t
:ID:       979099a4-9da2-48d1-9d6a-308a97868f1c
:END:

** Agrupando objetos com listas

#+begin_quote
"/Lists are how I parse and manage the world./" --- Adam Savage
#+end_quote

Vamos começar pensando no seguinte cenário, você está em casa e não tem nada para comer... logo, você precisa ir até o supermercado comprar ingredientes para uma receita. A primeira coisa que vem a sua cabeça é comprar um pacote de miojo pois, afinal, é fácil de preparar. Mas, sua fome está grande, então poderia comprar dois pacotes de miojo, mas isso não parece tão atraente. Lhe ocorre a ideia de incrementar o miojo. Você pode adicionar queijo ralado, talvez cozinhar um ovo junto com o miojo. Além disso, você resolve comprar uma bebida para acompanhar, um refrigerante. Então, você lembra que a pasta de dentes está acabando, então decide comprar também, para aproveitar a ida ao mercado. O número de itens a se comprar já começa a ficar grande, então é melhor organizar suas compras em uma lista.

*[A]* Escreva a /sua/ lista de compras de supermercado desta semana em uma célula de texto no jupyter.

Maravilha! Agora você pode ir ao mercado fazer minhas compras. Então você passa no banheiro antes de sair e nota que falta papel higiênico. Hora, então você adiciona mais este item em sua lista.

*[B]* Atualize sua lista com um item que você esqueceu em uma nova célula de markdown.

Ótimo, agora está tudo pronto e você vai ao mercado fazer suas compras!

Este tipo de organização de itens ou objetos em listas é muito prático, podemos então aplicar o mesmo conceito a programação. Vamos criar uma lista de compras em um código Python, a sintaxe será a seguinte:

#+begin_src python
  listadecompras = ["Miojo", "Queijo ralado", "Ovo", "Pasta de dentes"]
  print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo ralado', 'Ovo', 'Pasta de dentes']

Poxa, mas esqueci de incluir o papel higiênico na lista! Tudo bem, podemos adicionar itens a nossa lista com o método ~append~. Façamos o seguinte:

#+begin_src python
  listadecompras = ["Miojo", "Queijo ralado", "Ovo", "Pasta de dentes"]
  print(listadecompras)

  listadecompras.append("Papel higiênico")
  print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo ralado', 'Ovo', 'Pasta de dentes']
: ['Miojo', 'Queijo ralado', 'Ovo', 'Pasta de dentes', 'Papel higiênico']

Perfeito, veja que o item foi adicionado a sua lista! Mas... de onde veio esse ~append~? E por que chamamos ele de método e não de função?

A resposta da primeira pergunta está intimamente relacionada ao fato de Python ser uma linguagem de programação orientada a objetos. Tudo em Python é um objeto[fn:: OK, /praticamente/ tudo em Python é um objeto. Certas coisas como os operadores e instruções como ~if~ e ~while~ não são objetos. Tudo que você declara é um objeto!]! Um objeto em Python é simplesmente um agrupamento de informações e funções; ao criar um objeto, você automaticamente "ganha de brinde" essas informações e funções sem a necessidade de fazer nada extra. É aqui que entra o ~append~ que vimos acima. Ele é uma "função" de todo objeto do tipo lista que serve para acrescentar um novo item no final da lista. Essas "funções de objeto" são chamadas de _métodos_ para diferenciar das funções que não estão associadas a objetos em particular. Métodos se comportam de maneira similar às funções que nós já vimos: devem ser chamados com parênteses, podem ter zero ou mais argumentos e podem ter zero ou mais valores de retorno.

*[C]* Escreva a lista da prática [A] acima como uma lista de Python. Após atribuir os objetos da lista, use o ~print~ para mostrar sua lista na tela. Use o método ~append~ para inserir o item da prática [B] acima e então exiba todos os itens da lista com ~print~ novamente.

** Listas dentro de listas.

#+begin_quote
"/This category contains pages which catalog other lists./" --- Wikipedia
#+end_quote

Agora voltando a sua saída ao supermercado, antes de sair você lembra que precisa comprar um caderno, papel e caneta. Mas, infelizmente o mercado que você irá não tem esses itens, você precisará ir a papelaria ao lado para comprar esses itens. Então você naturalmente faz uma nova lista de compras para a papelaria, incluindo os itens necessários.

+ Caderno
+ Papel
+ Caneta

No Python, podemos fazer listas dentro de listas, então vamos fazer uma lista de listas com os objetos do mercado e da papelaria:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  print(listadecompras)
#+end_src

#+RESULTS:
: [['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes'], ['Caderno', 'Papel', 'Caneta']]

Agora você pode notar que temos duas listas na variável ~listadecompras~, uma com os itens do mercado e uma com os itens da papelaria. Podemos exibir as listas individualmente, para isso façamos o seguinte:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  print(listadecompras[0])
  print(listadecompras[1])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes']
: ['Caderno', 'Papel', 'Caneta']

Note que o primeiro ~print~ exibe a primeira lista, de índice 0 e o segundo ~print~ exibe a segunda lista, de índice 1. Em Python a contagem começa sempre de zero e usamos os colchetes para resgatar os itens de listas.

Perfeito, mas agora deu vontade de comer uma sobremesa após o miojo incrementado, então você quer adicionar este item a lista do supermercado. Além disso, você achou que convém comprar um pacote de post-it, para colocar na geladeira, para não esquecer tanto dos itens que você tem que comprar. Portanto, é necessário adicionarmos estes itens nas listas. Podemos fazer isso com a seguinte sintaxe no Python:

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  listadecompras[0].append("Chocolate")
  listadecompras[1].append("Post-it")

  print(listadecompras[0])
  print(listadecompras[1])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: ['Caderno', 'Papel', 'Caneta', 'Post-it']

*[A]* Crie uma lista de listas. Faça isso de tal forma que todas as listas que você criou sejam diferentes, assim como no exemplo da lista do supermercado e da papelaria. Lembre-se de utilizar a sua lista, não repetir as que demos de exemplo aqui.

*[B]* Exiba cada uma das listas da prática acima separadamente com o comando ~print~.

Pronto, as listas estão atualizadas com os itens que você incluiu.

*[C]* Agora, nas listas da atividade *[B]*, use o método ~append~ para adicionar itens a cada uma das suas listas na lista de listas. Lembre-se de exibir cada uma delas com a função ~print~.

** Modificando, particionando e desempacotando listas

Já foi apresentado um dos métodos utilizados em listas, o ~append~. Mas, existem outros métodos para listas, a seguir veremos alguns deles.

Vamos voltar a nossa lista de compras. Você mudou de ideia quanto a sua sobremesa, não querendo mais o chocolate, mas sim um flan pronto de pote, sobrou VA no final do mês, então dá pra se dar esse luxo :). Então precisamos remover o chocolate e inserir o flan.

#+begin_src python
  listadecompras = [
      ["Miojo", "Queijo Ralado", "Ovo", "Pasta de Dentes"],
      ["Caderno", "Papel", "Caneta"],
  ]

  listadecompras[0].append("Chocolate")

  print(listadecompras[0])

  listadecompras[0].remove("Chocolate")
  listadecompras[0].append("Flan")

  print(listadecompras[0])
#+end_src

#+RESULTS:
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Chocolate']
: ['Miojo', 'Queijo Ralado', 'Ovo', 'Pasta de Dentes', 'Flan']

Agora sim, podemos ver que a alteração foi realizada como você queria.

*[A]* Na sua lista da prática anterior, remova um item e adicione outro utilizando os métodos ~remove~ e ~append~.

E caso você queira saber se já existe algo na lista, seria tedioso consultar toda a lista para conferir. No entanto, existe um método de listas do Python para fazer isto, chamada count. Vamos fazer um exemplo, para conferir se o miojo está na lista:

#+begin_src python
  print(listadecompras[0].count("Miojo"))
#+end_src

#+RESULTS:
: 1

Note que o programa retorna "1", ou seja, ele está lhe dizendo que há o Miojo na lista uma vez. Agora teste buscar por "miojo" utilizando somente letras minúsculas, o que acontece?

Além disso, o programa retornou um número, ou seja, você poderia ter mais que uma ocorrência para o item consultado. Isso signica que podem existir itens duplicados na lista, caso você tivesse adicionado miojo suas vezes, o count retornaria 2.

*[B]* Existem vários métodos de listas no Python, que serão muito úteis na sua vida de programação. Abaixo seguem alguns e suas explicações e algumas perguntas:

+ ~insert~: Adiciona um elemento na posição especificada.\\
	Exemplo: ~listadecompras[0].insert(0, "Banana")~, adiciona Banana na posição zero da lista.\\
	*Pergunta 1:* O que acontece com os outros elementos?

+ ~extend~: Adicionar vários elementos de uma lista no final da sua lista.\\
	Exemplo: ~listadecompras[0].extend(['Pão', 'Queijo', 'Presunto'])~\\
	*Pergunta 2:* Os elementos foram adicionados corretamente? Note que ao invés de adicionar os itens na sintaxe anterior, você poderia adicionar outra lista, definida anteriormente.

+ ~index~: Retorna o índice do primeiro elemento com o valor requisitado.\\
	Exemplo: ~listadecompras[0].index('Ovo')~\\
	*Pergunta 3:* O índice reportado é o que você esperava?

+ ~pop~: Remove o elemento da posição requida.\\
	Exemplo: ~listadecompras[0].pop(5)~\\
	*Pergunta 4:* Qual item foi removido? Foi o esperado?

+ ~sort~: Ordena sua lista de maneira crescente, tanto com números como ordem alfabética. Note que você pode ordenar a lista, mas não a lista dentro da lista.\\

+ ~reverse~: Inverte a ordem de sua lista. Novamente tome cuidado pois este método ordena listas, não listas dentro de listas. Além disso, ele simplesmente reverte a ordem existente, ou seja, ele não coloca em ordem decrescente.\\

*[C]* Com a sua lista de listas, escolha 2 métodos e os aplique a sua lista (fora o ~append~ e ~remove~ que já foram utilizados). Algum método lhe pareceu particularmente útil?

*[Desafio 1]* Como você faria para ordenar alfabeticamente suas duas listas de compras, tendo no final ainda as duas listas dentro de uma lista de listas?

# #+RESULTS:
# : mercado = listadecompras[0]
# : mercado.sort()
# : print(mercado)
# : papelaria = listadecompras[1]
# : papelaria.sort()
# : print(papelaria)
# : listadecompras = []
# : listadecompras.append(mercado)
# : listadecompras.append(papelaria)

*[Desafio 2]* Coloque cada lista de sua lista de listas na ordem contrária a alfabética.

# #+RESULTS:
# : mercado = listadecompras[0]
# : mercado.reverse()
# : print(mercado)
# : papelaria = listadecompras[1]
# : papelaria.reverse()
# : print(papelaria)
# : listadecompras = []
# : listadecompras.append(mercado)
# : listadecompras.append(papelaria)
# : print(listadecompras)

** Particionamento de listas

Já foi apresentado como acessar um item específico da lista anteriormente, com o argumento entre colchetes (~listadecompras[0]~). Porém, podemos particinar as listas, pegando vários elementos de interesse. Novamente utilizaremos índices entre colchetes, com a seguinte sintaxe: lista[Inicial:Final:Passo]. O 'Inicial' é o primeiro elemento da lista que desejamos, 'Final' é o elemento final desejado. Já 'Passo' é o de quantos em quantos elementos queremos, por exemplo, se o passo for 1, todos elementos na faixa específicada são impressos, se o passo for 2, só serão fornecidos elementos a cada dois. Vamos exemplificar para facilitar:

#+begin_src python
  listadecompras = [
      [
          "Queijo Ralado",
          "Queijo",
          "Pão",
          "Pasta de Dentes",
          "Ovo",
          "Miojo",
          "Flan",
          "Banana",
      ],
      [
          "Caderno",
          "Papel",
          "Caneta",
          "Post-it",
      ],
  ]

  print(listadecompras[0][0:6:2])
#+end_src

Porque temos dois colchetes? Porque estamo particionando a primeira lista de nossa lista de listas. No primeiro colchetes ~[0]~, estamos específicando a primeira de nossas duas listas. No segundo colchetes estamos particionando a lista começando do elemento zero até o elemento 6, pulando de dois em dois.

A saída do código anterior é ~['Queijo Ralado', 'Pão', 'Ovo']~, sendo que nossa lista completa é ~['Queijo Ralado', 'Queijo', 'Pão', 'Pasta de Dentes', 'Ovo', 'Miojo', 'Flan', 'Banana']~. Logo foram impressos os elementros 0, 2 e 4. Mas o elemento 6 também não deveria ser exibido? Parece lógico, mas, como o Python começa sua contagem de zero, ao invés de um, sempre que especificamos faixas de valores o elemento final do intervalo não é considerado. Portanto, caso queira o último elemento incluso sempre considere n+1. Façamos isso então:

#+begin_src python
  print(listadecompras[0][0:7:2])
#+end_src

Com este comando o código exibiu ~['Queijo Ralado', 'Pão', 'Ovo', 'Flan']~, incluindo o sexto elemento da lista. Então, tenha isso sempre em mente com o Python, a contagem começa em zero e o último elemento das faixas de valores não é incluído.

Também podemos utilizar índices negativos no particionamento de listas, mas como assim? O que acontece quando usamos índices negativos? Basicamente a contagem é de traz para frente. Então, se pedirmos a seguinte faixa ~[-4,-1]~ para nossa lista de compras do supermercado, o código imprimirá ~['Ovo', 'Miojo', 'Flan']~, sendo esses os elementos -4, -3 e -2, já que o último elemento não vai ser incluído por ser o final do intervalo. Se quisermos também o último elemento e colocarmos o intervalo como ~[-4:0]~ teremos um erro de sintaxe, então, para obter os quatro últimos elementos a sintaxe correta será ~[-4:]~, que irá imprimir do elemento -4 até o último.

*[A]* Utilize o particionamento de lista em uma lista que você criou. Faça para dois passos e duas faixas de valores.

*[B]* Exiba os três últimos elementos de uma lista criada por você (esta deve ter pelo menos 4 elementos).

*[Desafio 1]* Crie uma lista de quatro números e some todos os números da lista, também encontre a média dos quatro números da lista.

*[Desafio 2]* Encontre os valores máximo e mínimo de uma lista de quatro números.

*[Desafio 3]* Crie uma função que recebe duas listas de mesmo tamanho (estas listas devem conter apenas valores numéricos). O programa deve retornar uma lista que é a multiplicação por elementos das listas (isto é, o elemento na posição zero da lista final é a multiplicação dos elementos da posição zero das listas de entrada; o mesmo vale para os elementos das demais posições). Sua função deve conter uma docstring e para esse desafio não é permitido usar funções importadas de outras bibliotecas.

*[Desafio 4]* Crie uma função que recebe um número posinivo $n$ e retorna uma lista com os $n$ primeiros valores da sequência de Fibonacci. Sua função deve conter uma docstring e para esse desafio não é permitido usar funções importadas de outras bibliotecas.

*[Desafio 5]* Crie uma função que recebe uma lista contendo números inteiros. Esta função retorna duas listas: a primeira lista (~lista_retorno_1~) deve conter todos os números da lista original em ordem crescente e sem repetição; a segunda lista deve conter a contagem em que cada número da ~lista_retorno_1~ aparece na lista original recebida pela função. Sua função deve conter uma docstring e para esse desafio não é permitido usar funções importadas de outras bibliotecas.

** Copiando listas

Agora vamos tratar de cópias no Python. Para listas o Python tem uma maneira bastante peculiar para cópias, onde são criados links entre as listas e não simplesmente copiados os objetos. Vamos a um exemplo para deixar mais claro:

#+begin_src python -n
  lista1 = ["Miojo", "Ovo", "Queijo Ralado"]
  lista2 = lista1  # Criamos uma lista2 igual a lista1

  print("Lista 1 Original")
  print(lista1)
  print("Lista 2 Original")
  print(lista2)

  print()

  lista2[2] = "Orégano"  # Altera o elemento 2 da lista2 para Orégano

  print("Lista 2 Alterada")
  print(lista2)  # Exibe a lista2 alterada
  print("Lista 1 depois de alterar lista 2")
  print(lista1)  # Exibe a lista1 após a alteração da lista2
#+end_src

#+RESULTS:
: Lista 1 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
: Lista 2 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
:
: Lista 2 Alterada
: ['Miojo', 'Ovo', 'Orégano']
: Lista 1 depois de alterar lista 2
: ['Miojo', 'Ovo', 'Orégano']

Bom, nesse código definimos uma ~lista1~, criamos uma ~lista2~ igualando a ~lista1~, por fim alteramos a ~lista2~. Como a cópia é criada com links, ou vínculos, a ~lista1~ e a ~lista2~ dependem uma da outra. Em outras palavras: elas estão conectadas! Então, quando a ~lista2~ foi alterada, a ~lista1~ também foi, como vocês podem notar na saída do código. Isso pode ser interessante para alguns casos, porém, na maioria das vezes o desejável é ter dados independentes uns dos outros. Para isso, precisamos utilizar o método ~copy~ de listas. Veja o exemplo abaixo.

#+begin_src python -n
  lista1 = ["Miojo", "Ovo", "Queijo Ralado"]
  lista2 = lista1.copy()  # Usando o método `copy`

  print("Lista 1 Original")
  print(lista1)
  print("Lista 2 Original")
  print(lista2)

  print()

  lista2[2] = "Orégano"  # Altera o elemento 2 da lista2 para Orégano

  print("Lista 2 Alterada")
  print(lista2)  # Exibe a lista2 alterada
  print("Lista 1 depois de alterar lista 2")
  print(lista1)  # Exibe a lista1 após a alteração da lista2
#+end_src

#+RESULTS:
: Lista 1 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
: Lista 2 Original
: ['Miojo', 'Ovo', 'Queijo Ralado']
:
: Lista 2 Alterada
: ['Miojo', 'Ovo', 'Orégano']
: Lista 1 depois de alterar lista 2
: ['Miojo', 'Ovo', 'Queijo Ralado']

*[A]* Para uma lista criada por você, mostre os dois casos de cópia, um usando o operador de atribuição (~=~) e outro usando o método ~copy~, lembre de mostrar a diferença quando alteramos uma das listas após a cópia.

** Desempacotamento e Operador Asterisco

No Python podemos utilizar uma notação específica para definir várias variáveis ao mesmo tempo, como segue:

#+begin_src python
  item0, item1, item2 = "Miojo", "Ovo", "Queijo"

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: Queijo

Notem que item0="Miojo", item1="Ovo" e item2="Queijo". Podemos utilizar isso para desempacotar uma lista, por exemplo:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo"]

  item0, item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: Queijo

*[A]* Desempacote uma lista criada por você. Lembre-se de imprimir todos os itens com a função ~print~.

Os itens0, 1 e 2 foram definidos de acordo com os elementos da lista, no código mostrado anteriormente. Caso a lista não tenha a mesma dimensão do número de variáveis que estamos definindo, o que acontece?

*[B]* Para averiguar, utilize o código a seguir, comente sobre o que aconteceu.

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]

  item0, item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:

Para lidar com este tipo de situação podemos utilizar o operador asterisco (também conhecido como operador estrela), que pegará os elementos restantes e atribuirá a variável indicada, por exemplo:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]

  item0, item1, *resto = lista

  print(item0)
  print(item1)
  print(resto)
#+end_src

#+RESULTS:
: Miojo
: Ovo
: ['Queijo', 'Pão', 'Orégano']

Agora nosso comando funciona! Tivemos então o item0="Miojo", item1="Ovo" e resto=['Queijo', 'Pão', 'Orégano'].

A posição do operador asterisco não precisa ser necessáriamente na última variável, ela pode ficar na primeira, ou na do meio, por exemplo:

#+begin_src python
  lista = ["Miojo", "Ovo", "Queijo", "Pão", "Orégano"]

  item0, *item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)

  print()

  *item0, item1, item2 = lista

  print(item0)
  print(item1)
  print(item2)
#+end_src

#+RESULTS:
: Miojo
: ['Ovo', 'Queijo', 'Pão']
: Orégano
:
: ['Miojo', 'Ovo', 'Queijo']
: Pão
: Orégano

*[C]* Como se comportou o código acima de acordo com onde ficou o asterisco?

** Tuplas

Existe outro tipo de dados no Python que são chamadas tuplas. As tuplas são basicamente listas imutáveis. Como assim imutáveis? Isso significa que uma vez que ela foi definida, não podemos mais adicionar ou remover elementos, bem como não é possível modificar sua ordem. Então, voltando ao nosso exemplo do supermercado, se você quiser estabelecer uma lista perpétua de itens a serem comprados (que jamais serão alterados), você pode colocá-los em uma tupla. Vamos a um exemplo:

#+begin_src python
  itensrecorrentes = ("Miojo", "Ovo", "Queijo Ralado")
  print(itensrecorrentes)
#+end_src

#+RESULTS:
: ('Miojo', 'Ovo', 'Queijo Ralado')

Então, agora esta tupla será composta sempre por estes itens, não podendo modificá-los ou alterar sua ordem. Por conta disso as tuplas só tem dois métodos possíveis, o ~count~ e o ~index~, que tem a mesma função que nas listas, que é contar quantos itens existem na tupla e qual o índice do objeto requisitado.

*[A]* Qual a diferença na sintaxe para a declaração de tuplas, comparando com a de listas? Seja atento, pois pequenos detalhes fazem muita diferença do Python.

O interessante é que podemos utilizar o método ~extend~ com uma tupla como argumento. Veja que, neste caso, quem está sendo alterado é a lista, não a tupla. A tupla seria apenas a fonte de informação com a qual vamos atualizar a lista. Vamos ver um exemplo:

#+begin_src python -n
  itensrecorrentes = ("Miojo", "Ovo", "Queijo Ralado")

  listadecompras = []
  listadecompras.extend(itensrecorrentes)

  print(listadecompras)
#+end_src

#+RESULTS:
: ['Miojo', 'Ovo', 'Queijo Ralado']

Na linha 3 inicializamos uma lista vazia, apenas para criá-la, para poder utilizar o método ~extend~ nela na linha 4. Podemos ver que agora temos uma lista criada a partir da tupla, então podemos voltar a adicionar os itens de interesse.

*[B]* Crie uma tupla com itens de seu interesse. Após isso, construa uma lista a partir dessa tupla.

** Conjuntos

Outro objeto de Python são os conjuntos, que são basicamente listas sem elementos repetidos. Os conjuntos possuem seus métodos específicos também, que englobam métodos equivalentes aos das listas, como: ~remove~ e ~pop~. Mas especificamente para conjuntos, temos operações matemáticas já conhecidas, como união e intersecção. Vamos definir dois conjuntos e operá-los, com nossa analogia de listas de compras, vamos pensar que você fez anotações para compras em dois lugares diferentes e agora você quer juntá-las.

#+begin_src python
  conjunto1 = {"Miojo", "Ovo", "Queijo"}
  conjunto2 = {"Miojo", "Pão", "Queijo", "Orégano", "Pão"}

  print(conjunto1)
  print(conjunto2)
#+end_src

#+RESULTS:
: {'Ovo', 'Miojo', 'Queijo'}
: {'Miojo', 'Pão', 'Queijo', 'Orégano'}

*[A]* Qual a diferença na sintaxe para a declaração de conjuntos, tuplas e listas?

*[B]* Quando você imprimiu o ~conjunto2~, quantas vezes apareceu "Pão"? Quantas vezes ele estava na declaração? Porque desta diferença? Pode usar a internet para descobrir, mas lembre-se de citar suas fontes!

Agora vamos realizar algumas operações com os conjuntos:

#+begin_src python
  conjunto1 = {"Miojo", "Ovo", "Queijo"}
  conjunto2 = {"Miojo", "Pão", "Queijo", "Orégano", "Pão"}

  intersection = conjunto1.intersection(conjunto2)
  print(intersection)

  union = conjunto1.union(conjunto2)
  print(union)
#+end_src

#+RESULTS:
: {'Miojo', 'Queijo'}
: {'Orégano', 'Miojo', 'Ovo', 'Queijo', 'Pão'}

*[C]* Os resultados estão de acordo com o que você esperava?

Além desses métodos temos outros exclusivos de conjuntos, como segue:

+ ~add~: Adiciona um elemento ao conjunto. Sintaxe: conjunto.add("Presunto")
+ ~difference~: Faz a subtração de dois conjuntos. Sintaxe: ~difference = conjunto1.difference(conjunto2)~
+ ~discard~: Remove o elemento especificado do conjunto. Parece igual ao remove, mas, neste caso você não terá uma mensagem de erro caso o elemento não exista no conjunto. Sintaxe: ~conjunto.discard("Banana")~
+ ~update~: Com este método você pode incluir um iterável no conjunto, que pode ser outro conjunto, lista, tupla, ...

*[D]* Crie três conjuntos com itens de seu interesse. Realize operações de adição, diferença, interseção e união com eles.

* Laço de repetição :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_laco
:EXPORT_OPTIONS: toc:t
:ID:       25e5272b-ad01-463a-815a-7b4345a4b35a
:END:

#+begin_quote
"/Once you free your mind about a concept of
Harmony and of music being correct
You can do whatever you want
So nobody told me what to do
And there was no preconception of what to do/" --- Giovanni Giorgio
#+end_quote

Laços de repetição, ou seu termo mais comum em inglês o loop, serve para iterar elementos de listas, tuplas, conjuntos ou mesmo números em uma faixa definida. Existem diferentes maneiras de implementar loops, sendo as principais do Python o =while= e o =for=, que mostraremos pra vocês a seguir.

** Laço de repetição usando =while=
#+begin_quote
"/Do it while yo can/" --- Billy Preston
#+end_quote

Vamos iniciar com um =while loop=, ou laço de repetição com =while=. A tradução da palavra =while= do inglês é =enquanto=, então a ideia deste loop é fazer algo enquanto uma condição não for verdadeira. Vamos começar com um exemplo simples, onde o loop será executado enquanto a variável =i= for menor que 10, e vamos somando 1 a mesma variável a cada iteração. Para isso usamos um operador que não foi apresentado ainda, o =+==, que basicamente soma o valor ou variável indicado após ele, por exemplo, i += 1 é o mesmo que i = i + 1.

*[A]* Execute o código abaixo no seu Jupyter Notebook, descreva o que ocorreu com o código.
#+begin_src python
i = 0
while i < 10:
	print(i)
	i += 1
#+end_src

Fique atento a identação! Assim como no caso dos condicionais (=if=) você precisa colocar a parte da execução identada, pois esta é a maneira do Python interpretar o loop. Note que estamos utilizando os operadores lógicos, que vocês já foram apresentados em uma aula anterior. Eles são fundamenteis para a implementação de loops while, pois quando a condição retornar =False=, o loop irá parar. Na execução do código vocês podem notar que os números de 0 à 9 foram impressos, quando =i= ficou igual a 10 o loop parou, pois a sentença =i < 10= passou a ser =False=. Você pode confirmar isso alterando seu código para o seguinte:

*[B]* Execute o código abaixo no seu Jupyter Notebook. O que aconteceu agora? Quais são o significado dos dois print executados?
#+begin_src python
i = 0
while i < 10:
      print(i, i < 10)
      i += 1
print(i, i < 10)
#+end_src

#+BEGIN_COMMENT
#Com isso, estamos imprimindo a variável =i= e o valor booleano da operação =i < 10=. Ao final do loop há mais uma operação de print, para mostrar que quando =i = 10= a operação =i < 10= retorna =False=.
#+END_COMMENT

*IMPORTANTE*
O uso de loops pode facilmente levar o seu código a loops infinitos! Sempre avalie com cuidado a condição a ser adotada em seu loop, vamos a um exemplo de loop infinito:

#+begin_src python
i = 0
while i < 10:
      print(i, i < 10)
#+end_src

*Caso tenha executado, precisará desligar (shut down) seu kernel, pois o código não irá parar nunca!*

Neste caso, foi esquecido o incrementador de =i= (+=), logo o valor de =i= nunca será alterado! Isso levará o código a rodar indefinidamente, sem nunca parar, teste para você conferir. Esse é um dos erros mais catastróficos em códigos, pois o programa simplesmente executa operações sem parar, muitas vezes utilizando todos os recursos computacionais disponíveis e inutilizando a máquina. Neste caso a única alternativa é terminar o programa forçosamente, ou em alguns casos só reiniciando o computador.

Também temos outra maneira de sair ou continuar em loops, usando o comando =break= e =continue=. Basicamente ao se dar o comando =break=, o loop é interrompido, e se o comando =continue= for utilizado o loop continua sua execução. Isso pode ser útil para se utilizar em conjunto com operadores condicionais, como no exemplo abaixo, onde o código cálcula o máximo divisor de um número fornecido.

#+begin_src python
a = 8733				#Número que desejamos saber o divisor
i = a-1					#Definimos i como a-1, pois se começarmos a testar o divisor como o próprio a, teríamos uma solução trivial
while i > 0:                            #Vamos iterar de a-1 até 1
    print(i)                            #
    b = a/i				#
    if (b - int(b)) == 0:		#Aqui checamos se o resultado da divisão tem componente decimal
        print(a, 'é divisível por', i)  #Caso a parte decimal seja zero, isso significa que a é divisível por i
        break				#Com este break o programa sai do loop
    else:				#Caso a divisão não tenha a parte decimal igual a zero, seguimos por aqui
        i -= 1				#Diminuímos 1 do i
        continue			#Voltamos ao início do loop
#+end_src

*[C]* Modifique o código acima, para utilizar o operador resto ~%~, isso simplificará o código.

O código apresentado está comentado, lembrem-se sempre de comentar seus códigos, pois caso você não comente, niguém além de você o entenderá e depois de algum tempo, nem você mesmo entenderá. Basicamente o código encontra o maior divisor para um número fornecido, testando todos os números menores que ele mesmo até que alguma das divisões tenha componente decimal zero.

*[D]* Modifique o código acima para avisar quando números primos são encontrados.

#+BEGIN_COMMENT
#+RESULTS:
#: a = 17
#: i = a-1
#: while i > 1:
#:     print(i)
#:     b = a/i
#:     print(b,b - int(b))
#:     if (b - int(b)) == 0:
#:         print(a, 'é divisível por', i)
#:         break
#:     else:
#:         i -= 1
#:         continue
#: if (i == 1):
#:     print(a,'é primo!')
#+END_COMMENT

*Desafio* Como você faria um código para achar o máximo divisor comum de dois números?

#+BEGIN_COMMENT
#+RESULTS:
#: a = 30
#: b = 20
#:
#: if a > b:
#:     i = b - 1
#: else:
#:     i = a - 1
#: while a > 1:
#:     print(i)
#:     div1 = a/i
#:     div2 = b/i
#:     if ((div1 - int(div1)) == 0) and ((div2 - int(div2)) == 0):
#:         print('O MDC entre', a, 'e', b, 'é', i)
#:         break
#:     else:
#:         i -= 1
#:         continue
#+END_COMMENT

** Laço de repetição usando =for=
#+begin_quote
"/Loop de loop flip flop Santa's got an airplane/" --- Santa's Got an Airplane - The Beach Boys
#+end_quote

A outra maneira de implementarmos loops no Python é utilizando o =for=. Mas antes de entrarmos em seus detalhes, é importante mostrar outra ferramenta do Python, o operador =in=. Com ele podemos checar se um elemento está em uma lista, ou qualquer outro objeto iterável. No exemplo abaixo mostramos sua sintaxe:

#+begin_src python
lista = ["Miojo", "Ovo", "Queijo"]
print("Ovo" in lista)
print("Pão" in lista)
#+end_src

Veja que para o objeto ovo o código retornou =True=, já para pão, o código retornou =False=. Ou seja, ele confirmou que há ovo na lista e que não há pão. Para implementarmos um loop com for, iremos utilizar a seguinte sintaxe: =for item in lista=, desta maneira a variável item assumirá os o valor dos objetos presentes na lista, um a um.

*[A]* Execute o código abaixo e descreva o que observou.
#+begin_src python
lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
for item in lista:
	print(item)
#+end_src

#+BEGIN_COMMENT
#Note que a cada iteração o código imprime a variável item, que assume os valores da lista do primeiro ao último.
#+END_COMMENT

Podemos usar condicionais ou manipular de várias maneiras os dados. Por exemplo, você quer que quando houver pão na sua lista de compras, seja automáticamente incluídos queijo, presunto e manteiga.

*[B]* Crie um operador condicional no seu loop, que confere se um dos itens é pão, caso seja então adicionamos os itens desejados.

#+BEGIN_COMMENT
#+begin_src python
#lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
#for item in lista:
#        print(item)
#        if item == "Pão":
#                lista.append["Queijo", "Presunto", "Manteiga"]
#print(lista)
#+end_src
#+END_COMMENT

Pronto, agora se você adicionar pão a lista serão adicionados os itens queijo, presundo e manteiga, assim você pode fazer seu misto quente! Agora, note que já havia queijo na lista e ele foi adicionado novamente.

*[C]* Faça um código que não adicione o queijo, presunto e manteiga duplicadamente.

#+BEGIN_COMMENT
#+RESULTS:
#: set1 = {"Miojo", "Ovo", "Queijo", "Orégano", "Pão"}
#: set2 = copy.deepcopy(set1)
#: for item in set1:
#:         print(item)
#:         if item == "Pão":
#:                 set2.update({"Queijo", "Presunto", "Manteiga"})
#: print(set2)
#:
#: lista = ["Miojo", "Ovo", "Queijo", "Orégano", "Pão"]
#: for item in lista:
#:         print(item)
#:         if item == "Pão":
#:             if lista.count("Queijo") == 0:
#:                 lista.append("Queijo")
#:             if lista.count("Presunto") == 0:
#:                 lista.append("Presunto")
#:             if lista.count("Manteiga") == 0:
#:                 lista.append("Manteiga")
#: print(lista)
#+END_COMMENT

Além de iterar em listas, o =for loop= pode ser utilizado em faixas de números, para isso devemos utilizar o operador =range=. Por exemplo, se quisermos iterar os números de 0 à 10, podemos fazer o seguinte:

#+begin_src python
for number in range(0,11):
        print(number)
#+end_src

A saída do código lhe dará os números de 0 à 10, um em cada linha. Mas note que a faixa que colocamos é de 0 à 11! Novamente o fato do Python começar a contar do zero leva ao intervalo aberto no final da faixa, como discutido anteriormente. Então, tenha sempre em mente isso para não perder o último número da sua faixa.

Também podemos definir o passo a ser utilizado, como fizemos no fatiamento de listas. O padrão é iterar de um em um, mas podemos mudar isso, veja o exemplo abaixo:

#+begin_src python
for number in range(0,11,2):
	print(number)
#+end_src

O código imprime os números 0, 2, 4, 6, 8 e 10. Ou seja, o passo mudou para 2. Também podemos utilizar um passo negativo, colocando a faixa como (0,11,-1) será impressa a ordem decrescente. Isso é bastante útil em um caso bem simples, o cálculo de fatoriais.

*[D]* Com a dica do passo negativo, escreva um código para calcular o fatorial de um número inteiro qualquer. Dica: Utilize números de dois dígitos, se não o resultado ficará monstruosamente grande!

#+BEGIN_COMMENT
#+begin_src python
#fatorial = 1			#Definimos um valor inicial para o fatorial
#for number in range(4,1,-1):	#Iteramos de 4 à 2, com passo de -1
#    print(number)		#Imprime o número da iteração
#    fatorial = fatorial*number  #Multiplicamos a variável fatorial pelo número sendo iterado
#print(fatorial)			#Imprime o resultado do fatorial
#+end_src

#O código é simples mas tem alguns conceitos novos nele. Já na primeira linha definimos a variável =fatorial = 1=, porque isso, já que a utilizaremos no loop? Comente a primeira linha e confira o que acontece. Outro ponto é que iteramos de 4 a 2 e não de 4 a 1, o fatorial é definido por =4! = 4*3*2*1=, porém, qualquer número multiplicado por 1 é ele mesmo, logo não faz diferença multiplicarmos por 1, já que o resultado não é alterado. Assim, evitando uma multiplicação economizamos tempo computacional, pode parecer pouca coisa, mas, várias dessas otimizações em um código grande podem levar a ganhos significativos de performance.
#+END_COMMENT

*[E]* Refaça o código para encontrar números primos, agora utilizando o =for loop=.

#+BEGIN_COMMENT
#+RESULTS:
#: a = 17
#: for i in range(a-1,0,-1):
#:     c = a % i
#:     if c == 0 and i != 1:
#:         print(a, 'é divisível por', i)
#:         break
#:     elif i == 1:
#:         print(a, 'é primo')
#:     else:
#:         print(a, 'não é divisível por', i)
#+END_COMMENT

** Laços Aninhados
#+begin_quote
"/That Many Dreams Within Dreams Is Too Unstable/" --- Yusuf - Inception
#+end_quote

Além de utilizarmos laços (loops) aliados a condicionais, também podemos ter loops dentro de loops. Vamos voltar a nossas listas de compras, agora precisamos checar o que temos na lista da padaria e do supermercado, para ver se não temos nada repetido, vamos ao exemplo:

#+begin_src python
listadecompras = [['Miojo', 'Queijo', 'Ovo', 'Pasta de Dentes', 'Chocolate'], ['Pão', 'Queijo', 'Presunto', 'Sonho']]   #Definindo uma lista de listas com itens de mercado e da padaria
print('Lista do supermercado antes da conferência:', listadecompras[0])							#Imprime lista do supermercado
print('Lista da padaria antes da conferência:', listadecompras[1])							#Imprime lista da padaria

for item1 in listadecompras[0]:												#Loop nos itens do supermercado
        for item2 in listadecompras[1]:											#Loop nos itens da padaria
                if item1 == item2:											#Checa se os itens são iguais
                        listadecompras[0].remove(item1)									#Se forem iguais, são removidos da lista do supermercado
print('Lista do supermercado após a conferência:', listadecompras[0])							#Imprime a lista do supermercado
print('Lista da padaria após a conferência:', listadecompras[1])							#Imprime a lista da padaria
#+end_src

Note que o =Queijo= foi removido da lista da padaria, que era o único item repetido neste caso.

*[A]* Agora crie mais uma lista, que corresponderia a itens que você já tem no armário de casa. Escreva um código para averiguar se há itens repetidos na lista do supermercado e da padaria, como antes, mas que também confira se há itens repetidos na lista de itens do armário.

*[Desafio]* Escreva um código para encontrar todos números primos de uma faixa de números.
*BONUS* Testaremos esses códigos, o mais rápido ganhará um bonus na nota!

#+BEGIN_COMMENT
#+RESULTS:
#: start = 1
#: end = 1000
#:
#: listadeprimos = set()
#: listadenaoprimos = set()
#: for i in range(start,end+1):
#:         notprime = 0
#:         for j in range(start+1,int(end/2)):
#:                 if i % j == 0 and i != j:
#:                         notprime = 1
#:                         listadenaoprimos.add(i)
#:                         print(i, 'é divisível por', j)
#:                         break
#:         if notprime == 0:
#:                 listadeprimos.add(i)
#:                 print(i, 'é primo')
#:
#: print(sorted(listadenaoprimos), 'não são primos')
#: print(sorted(listadeprimos), 'são primos')
#+END_COMMENT

** Compreensão de listas
#+begin_quote
"/Wise it is to comprehend the whole. - Edward Young/" --- Yusuf - Inception
#+end_quote

Esta ferramenta serve para criarmos novas listas a partir de uma lista existente. Isso pode ser feito com loops por exemplo, mas existe uma forma mais compacta. Vamos primeiro fazer da forma que vocês já foram apresentados:

#+begin_src python
listadecompras = ["Miojo", "Ovo", "Queijo", "Presunto", "Pão", "Orégano", "Papel Higiênico"]
listadapadaria = []
for item in listadecompras:
	if item == "Pão" or item == "Queijo" or item == "Presunto":
		listadapadaria.append(item)
print(listadapadaria)
#+end_src

No código acima definimos a =listadecompras=, mas separamos alguns itens em uma =listadapadaria=, com os itens do misto quente. Foi feito um loop nos itens =listadecompras= e um condicional para os itens do misto quente. Notem que é possível utilizar vários condicionais juntos, o que é bastante útil. No final a =listadapadaria= está com os itens desejados. Outra maneira que pode reduzir o código significativamente é o uso da compreenção de listas. Veja o exemplo no código abaixo:

#+begin_src python
listadecompras = ["Miojo", "Ovo", "Queijo", "Presunto", "Pão", "Orégano", "Papel Higiênico"]
listadapadaria = [item for item in listadecompras if "Pão" in item or "Queijo" in item or "Presunto" in item]
print(listadapadaria)
#+end_src

Temos o mesmo resultado do loop for, com um código de três linhas, frente ao de seis linhas com o loop. A economia de linhas vem aliada a uma sintaxe um pouco complicada, que merece bastante atenção. Basicamente ela consiste no seguinte: novalista = [espressão =for= item =in= iterável =if= condição verdadeira], a =expressão= para ser qualquer coisa, no exemplo anterior utilizamos o próprio =item= na expressão, sem nenhum operador, mas entraremos em mais detalhes em breve. O =item= é o que será analizada a =condição= e aplicada a =expressão=, já o =iterável= pode ser uma lista, tupla, conjunto, entre outros. Vamos a um exemplo onde aplicamos uma expressão:

#+begin_src python
quadradosimpares = [numero**2 for numero in range(10) if numero % 2 != 0]
print(quadradosimpares)
#+end_src

No exemplo acima a =expressão= é =numero**2=, ou seja tiramos o quadrado do =item= da compreensão. O iterável é a faixa de números de 0 a 9. Já a condição é que o resto da divisão entre o =item= (numero) e 2 seja diferente de zero, que será verdade para os números ímpares. Então a lista =quadradosimpares= terá o quadrado de todos os números ímpares na faixa escolhida.

*[A]* Agora faça o seguinte, delete a condição (if numero % 2 != 0) e execute o código, o que acontece?

Mas porque utilizar esta sintaxe de compreenssão de listas e não continuar utilizando loops? Os programadores são tão preguiçosos que querem fazer tudo em uma linha? Na verdade a maior vantagem da compreensão de listas é a performance. Vamos fazer uma rápida comparação para dar uma ideia, com o código abaixo, que calcula quais são os divisores de um número arbitrário.

#+begin_src python
import time								#Importando a biblioteca que irá cronometrar nosso código.
start = time.time()							#Setando o tempo inicial
a = 1000001								#Definimos um número qualquer
divisor = [i for i in range(1,a) if a % i == 0]				#Método de compreenssão de listas para calcular os divisores
print(divisor)								#Imprime os divisores
print("--- Comprehenssion %s seconds ---" % (time.time() - start))	#Imprime o tempo que o código levou para executar

start = time.time()							#Setando novamente o tempo inicial
divisor = []								#Inicializando a lista dos divisores
for i in range(1,a):							#Início do loop
    if a % i == 0:							#Testa o resto da divisão
        divisor.append(i)						#Acrescenta como divisor se o resto é zero
print(divisor)								#Imprime os divisores
print("--- Loop %s seconds ---" % (time.time() - start))		#Imprime o tempo de execução
#+end_src

No código apresentado calculamos todos divisores do número =a=, execute este código, você verá que os tempos de execução são mais rápidos para o método de compreenssão de listas. Mas poxa, um executou em 0.04 segundos e o outro em 0.05 segundos, não é muita diferença. Pois bem, aumente três zeros no =a= e compare novamente, agora temos a compreenssão de listas executando em 45 segundos e o loop em 60 segundos. Quanto maior o seu número, mais importante será essa diferença. Isso pode ser crucial em muitos casos, pois imagine que você queira fazer uma previsão do tempo para amanhã, mas seu código demora 48 horas para rodar e sua previsão fica pronta depois do dia ter passado? Esse e muitos outros casos tem a performance como algo crítico, tornando a aplicação útil ou não.

Maravilha, conseguimos ganhar um pouco de performance, mas, o código apresentado está fazendo várias operações inúteis. Como assim? Bom, vamos pensar nos divisores de um número, eles certamente não serão maiores que a metade do mesmo, mas estamos tentando dividir por esses números maiores que a metade. Ajuste seu código para dividir só até a metade de =a= e veja a diferença na performance. A diferença é grande não? Se compararmos o loop dividindo por todos os números com a compreenssão de listas dividindo até a metade de =a=, o código leva quase um terço do tempo para executar. Se fosse uma previsão do tempo que levava 48 horas, agora ela levaria pouco mais de 16 horas, ficando pronta antes do próximo dia começar, se tornando útil. Logo parar para pensar na matemática ou lógica do problema ajuda muito na otimização, ainda mais aliado as técnicas computacionais adequadas.

*Desafio* Tente otimizar mais a performance do código anterior!


#+BEGIN_COMMENT
** Compreensão de listas aninhadas

Assim como laços, também podemos aninhar compreensão de listas. Neste caso a sintaxe pode ficar bastante complicada, então é interessante ilustrarmos

[[./img/nested-list-comprehension.png]]



* Depuração de programas :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_debug
:EXPORT_OPTIONS: toc:t
:ID:       a822fa0b-e43c-4dc6-99f4-0f4f8a2e97fc
:END:

** Meu programa não roda pois dá um erro, e agora?

#+begin_quote
"YOU DIED" --- Dark Souls
#+end_quote

Existem diversas formas em que algo pode dar errado, e isso /não/ é diferente em programação. Idealmente queremos que nosso código rode e nada dê errado, mas se algo estiver errado é sempre bom que sejamos avisados para poder pelo menos tentar consertar. É exatamente isso que acontece quando o Python exibe uma mensagem de erro! Ele está te avisando que algo estranho aconteceu e precisa ser resolvido antes de prosseguir. Veja o código abaixo.

#+begin_src python -n
  def divisao(x, y):
      """Divide o primeiro valor pelo segundo."""
      return x / y


  print(divisao(100, 0))
#+end_src

#+RESULTS:

Se tentar rodar esse código no JupyterLab, você verá uma mensagem similar a mensagem abaixo:

#+begin_src python -n
  ---------------------------------------------------------------------------
  ZeroDivisionError                         Traceback (most recent call last)
  /tmp/ipykernel_8712/570243516.py in <module>
        4
        5
  ----> 6 print(divisao(100, 0))

  /tmp/ipykernel_8712/570243516.py in divisao(x, y)
        1 def divisao(x, y):
        2     """Divide o primeiro valor pelo segundo."""
  ----> 3     return x / y
        4
        5

  ZeroDivisionError: division by zero
#+end_src

Se você nunca tinha visto uma mensagem dessas, meus parabéns! Esta é uma mensagem de erro e seu objetivo é informar quem executou o código que algo errado aconteceu. Veja que logo no início da mensagem de erro conseguimos identificar o tipo do erro: ~ZeroDivisionError~ que significa que uma divisão por zero aconteceu em algum lugar. Mas onde isso aconteceu? Logo abaixo do nome do erro temos um ~---->~ na linha 6, indicando qual instrução estava rodando quando o problema foi encontrado. Essa instrução tem duas funções: ~print~ e ~divisao~. O erro em si poderia ter ocorrido em qualquer uma delas, mas na linha 8 fica claro que o erro ocorreu na função ~divisao~. Mais abaixo encontramos um segundo ~---->~ que finalmente mostra onde que o erro efetivamente aconteceu! Foi na divisão de ~x~ por ~y~! Nós passamos o valor ~y=0~ quando executamos a função ~divisao~ e isso resultou em uma divisão por zero!

Saber ler as mensagens de erro é tão importante quanto saber programar em si. É muito fácil cometer pequenos erros durante a escrita de qualquer código. Quanto mais código você escrever mais chances tem de errar! Como vemos corriqueiramente nas notícias, mesmo programadores experientes de grandes empresas cometem erros! Afinal, errar é humano! Entender o erro e conseguir consertá-lo é uma habilidade que se ganha com prática, então aproveite cada mensagem de erro para afinar suas habilidades!

*[A]* Todos os blocos de código abaixo resultam em um erro quando executados. Execute-os, identifique o erro, escreva uma breve explicação sobre o que o erro significa (busque na documentação do Python) e reescreva cada bloco de código para que ele execute sem erros.

#+begin_src python -n
  piratas = {
      "Ruffy": "Homem borracha",
      "Zoro": "Espadachim",
      "Nami": "Navegadora",
      "Sanji": "Cozinheiro",
  }

  print(piratas["Ussop"])
#+end_src

#+RESULTS:

#+begin_src python -n
  filmes = [
      "Meu vizinho Totoro",
      "Nausicaä no país dos ventos",
      "Princesa Mononoke",
  ]

  print(filmes[4])
#+end_src

#+RESULTS:

#+begin_src python -n
  soma = "4" + 2
#+end_src

#+RESULTS:

#+begin_src python -n
  valor = int('abc')
#+end_src

#+RESULTS:

#+begin_src python -n
  print(abcdefghij)
#+end_src

#+RESULTS:

#+begin_src python -n
  for n in [1, 2, 3]:
  print(n)
#+end_src

#+RESULTS:

** Tratamento de exceções

#+begin_quote
"/Fazer ou não fazer. Tentativa não há./" --- Mestre Yoda
#+end_quote

Vimos na seção anterior que quando um erro é identificado durante a execução de um código, o erro é exibido ao usuário e o programa interrompe imediatamente a sua execução. Entretanto, em certos casos nós gostaríamos que o programa não interrompesse sua execução ao encontrar um erro. Esse comportamente é possível em Python com as instruções ~try~/~except~ e o nome dessa estratégia é /tratamento de exceções/. Veja um exemplo abaixo.

#+begin_src python -n
  def divisao(x, y):
      """Divide o primeiro valor pelo segundo."""
      return x / y


  try:
      print(divisao(100, 10))
      print(divisao(100, 2))
      print(divisao(100, 0))
      print(divisao(100, -1))

  except ZeroDivisionError:
      print("Ocorreu uma divisão por zero durante a execução do código!")

  print("FIM")
#+end_src

#+RESULTS:
: 10.0
: 50.0
: Ocorreu uma divisão por zero durante a execução do código!
: FIM

Neste exemplo, um bloco ~try~ é declarado na linha 6. "Try" vem do verbo tentar em inglês e pode ser traduzido como "tente" neste contexto. O Python irá tentar executar todos os comandos dentro do bloco ~try~ normalmente (note que os comandos do bloco ~try~ devem ser indentados!). Caso alguma instrução dentro do bloco ~try~ acuse um erro, a execução do bloco ~try~ é interrompida e o erro é "capturado", isto é, o tipo do erro é armazenado na memória. Este erro capturado é então comparado com todos os erros declarados nos blocos ~except~ seguintes do bloco ~try~ ("except" significa "exceto" em português). Neste caso temos apenas um bloco ~except~ na linha 12, e ele corresponde ao erro do tipo ~ZeroDivisionError~. Se existir um bloco ~except~ correspondente ao erro capturado, então as instruções deste bloco são executadas e a execução do programa não para! Se não existir um bloco ~except~ correspondente ao erro capturado, então a execução do programa para e o erro é exibido ao usuário da mesma forma que vimos na seção anterior. Execute o código acima e veja o que acontece.

Podemos criar instruções ~try~/~except~ complexas considerando diversos tipos de erros diferentes. Quando um bloco ~except~ deve identificar mais de um tipo de erro, então é necessário agrupar todos os erros em parênteses (ver linha 7 no código abaixo). Podemos escrever quantos blocos ~except~ desejarmos para um mesmo bloco ~try~ (veja as linhas 10 e 13 abaixo).

#+begin_src python -n
  try:
      print("4" + 2)
      print(abcdefghij)
      print(1 / 0)
      print(int("abc"))

  except (ZeroDivisionError, TypeError):
      print("Tente não dividir por zero e se atente aos tipos das variáveis!")

  except ValueError:
      print("Tem algum valor inválido aí! Tome cuidado!")

  except NameError:
      print("Você tem certeza que definiu todas as suas variáveis?")

  print("FIM")
#+end_src

#+RESULTS:
: Tente não dividir por zero e se atente aos tipos das variáveis!
: FIM

O bloco ~try~ também admite duas outras instruções: ~else~ e ~finally~. A instrução ~else~ é apenas executada se o bloco ~try~ é executado até o fim, sem que haja nenhum erro! A instrução ~finally~ é sempre executada ao final do bloco ~try~, independente do que aconteceu (ela é executada mesmo caso um erro não contemplado pelas instruções ~except~ ocorra!). Veja um exemplo abaixo.

exemplo

Como você pode perceber, o tratamento de exceções em Python é bastante poderoso e nos permite um enorme controle sobre a execução do código. Além disso, este não é um processo computacionalmente custoso[fn:: Mas cuidado! Tratamento de exceções pode ser computacionalmente custoso em outras linguagens de programação. É sempre bom se informar antes!]. Desta forma, diversos programadores avançados de Python recomendam fortemente o uso do tratamento de exceções com a estratégia "faça primeiro e peça desculpas depois". Um exemplo desta estratégia é ilustrado no código abaixo. Neste código, digamos que não sabemos se a variável ~pode_ser_uma_lista~ é uma lista. No bloco ~try~ nós /assumimos/ que esta variável é uma lista e seguimos em frente. Caso ela não seja, nós "pedimos desculpas" no bloco ~except~ e realizamos uma conversão da variável em lista (linha 7).

#+begin_src python -n
  pode_ser_uma_lista = 10

  try:
      pode_ser_uma_lista.append(20)

  except AttributeError:
      pode_ser_uma_lista = [pode_ser_uma_lista]
      pode_ser_uma_lista.append(20)

  print(pode_ser_uma_lista)
#+end_src

#+RESULTS:
: [10, 20]

Se nenhum tipo de erro é declarado no bloco ~except~ então este bloco passa a ser executado caso _qualquer erro ocorra_ durante a execução do bloco ~try~! Isso pode parecer conveniente, mas não se deixe enganar: é melhor declarar explicitamente todos os erros que devem ser tratados do que aceitar _qualquer_ erro. Isto pois existem muitos tipos de erros que podem ocorrer durante a execução do seu código, juntar todos os erros "num mesmo saco" aumenta muito a chance de seu código não se comportar da forma como você gostaria. Blocos ~except~ sem declaração do tipo do erro são altamente desencorajados.

** Meu programa não faz o que eu queria que ele fizesse, e agora?

#+begin_quote
"Em última análise, é o desejo, não o desejado, que nós amamos." --- Friedrich Nietzsche
#+end_quote

Muitas pessoas ficam chateadas quando seu código exibe um erro ao ser executado... isso é normal. Mas veja pelo lado positivo: quando um erro é exibido você /sabe/ que tem algo de errado e tem a oportunidade de corrigir! Um problema que usualmente é /muito/ mais complicado é quando seu código roda sem erros, porém não faz o que você gostaria que ele fizesse...

Se esse é seu problema, a técnica mais fundamental de todas é checar linha por linha do seu código em busca do problema. Será que você esqueceu um operador em algum lugar? Será o valor de uma variável foi alterado em uma função sem que você tenha percebido? Será que faltou atualizar uma variável booleana? São tantas possibilidades do que pode dar errado que é impossível listar todas elas aqui. É necessário entender bem o propósito de seu código e entender bem todas linhas de instruções do mesmo para conseguir avaliar onde está o problema. Chamamos de _depuração_ ou _debug_ a busca por erros (também chamados de /bugs/) no código.

A técnica de /depuração linha por linha/ pode ser utilizada sempre, porém a energia gasta nessa tarefa aumenta com o número de linhas de código que devem ser avaliadas. Além disso, esta técnica exige que você tenha todas as informações das variáveis na sua memória e literalmente "rode" o código na sua mente. Esta é uma habilidade bastante útil que se adquire ao longo do tempo. Uma forma mais "visual" de usar esta técnica é com a ferramenta online Python Tutor disponível em https://pythontutor.com/visualize.html#mode=edit.

Uma forma mais eficiente de depurar seu programa é restringir o local de busca. Vamos supor que seu código tenha três funções diferentes. Uma estratégia possível é testar cada uma destas funções isoladamente em busca de comportamentos fora do esperado (isso pode ser feito em uma nova célula de código no Jupyter). Se um comportamento fora do esperado for detectado, então restringimos a busca do erro, neste caso será restrito para o corpo da função que teve comportamento fora do esperado. Se a nova área de busca é razoávelmente pequena, a técnica de avaliação linha por linha pode ser utilizada, do contrário é interessante utilizar outras ferramentas.

Uma forma de encontrar erros em muitas linhas de código é a /depuração interativa/. Este tipo de depuração consiste em avaliar o comportamento do seu código durante a sua execução.

1) O código roda normalmente até atingir um /ponto de parada/ definido pelo usuário;
2) Ao atingir um ponto de parada, a execução do código cessa e o controle volta ao usuário;
   a. Nesta etapa, o usuário pode executar qualquer comando válido de Python (por isso que chamamos de /depuração interativa/);
   b. É usual executar comandos para checar valores e tipos de variáveis, bem como testar o comportamento de funções;
3) Após o término de todas as checagens desejadas, é necessário escolher o próximo passo:
   a. Se um erro foi identificado, podemos sair do modo de depuração com a instrução ~exit~ e corrigir o erro;
   b. Se o erro não foi identificado, podemos seguir em frente com a depuração. A instrução ~continue~ faz com que o código continue sua execução a partir do ponto que parou e só ira parar novamente se encontrar algum ponto de parada. A instrução ~step~ executa a próxima linha de código a partir do ponto de parada e para logo em seguida, devolvendo o controle ao usuário.

Pontos de parada em Python são declarados com a função ~breakpoint~ (lembre-se de incluir parênteses no final do nome da função para executá-la!).

Outra forma de depuração é a /depuração com mensagens de registro/. Nesta modalidade, incluímos instruções no nosso código cujo objetivo é mostrar alguma informação ao usuário durante a sua execução (que ocorre sem pausas). A estratégia mais simples é incluir instruções ~print~ ao longo do código para exibir informações críticas ao usuário como, por exemplo, mostrar o valor de uma variável e seu tipo. Apesar de ser bastante utilizada, esta estratégia com a instrução ~print~ não é recomendada pois ao final da depuração devemos excluir todas as instruções ~print~ que usamos para depurar o código (afinal, esta informação não é pertinente ao usuário final). A forma recomendada para realizar a depuração com mensagens de registro é utilizando o módulo embutido ~logging~, que veremos na seção de Biblioteca padrão.

Não se esqueça que é sempre possível buscar ajuda quando nos deparamos com problemas no nosso código! Releia a seção /Buscando ajuda/ caso queira refrescar a memória.

** Controle o erro para ele não controlar você

#+begin_quote
"/E o meu erro foi crer que estar ao seu lado, bastaria./" --- Meu Erro, Paralamas do Sucesso
#+end_quote

É possível comandar o Python a acusar um erro com a instrução ~raise~. A vantagem de /você/ programar quando um erro é acusado é que, quando bem usado, isso aumenta seu controle sobre o código que é executado e evita comportamentos que não são desejados. Por exemplo, digamos que você vá escrever uma função que calcula o logarítmo natural de um número real usando uma série de Taylor. A série de Taylor abaixo funciona para valores de $x$ que satisfaçam $0 < x \leq 2$. Neste caso não podemos permitir que o usuário use valores que não satisfaçam essa inequação. Veja como podemos implementar isso no exemplo abaixo.

\[ \ln(x) = \sum_{k=1}^{\infty} (-1)^{k+1} \frac{(x-1)^k}{k} \]

#+begin_src python -n
  def log_natural(x, num_elementos=10000):
      """Calcula o logaritmo natural do valor recebido.

      Args:
        x:
          Valor real maior que zero e menor ou igual a dois.
        num_elementos:
          Número de elementos a serem considerados na soma infinita da série de
          Taylor.

      Returns:
        Logarítmo natural de `x`.

      Raises:
        ValueError: ocorre caso o valor de x não satisfaça a inequação 0 < x <= 2.
      """

      if not (0 < x <= 2):
          raise ValueError("O valor de x deve ser maior que 0 e menor ou igual a 2!")

      soma = 0
      for k in range(1, num_elementos + 1):
          soma = soma + (-1) ** (k + 1) * (x - 1) ** k / k

      return soma


  print(log_natural(1))
  print(log_natural(2))
  print(log_natural(10))
  print(log_natural(-3))
#+end_src

#+RESULTS:
: 0.0
: 0.6930971830599583


Na linha 19 do código acima temos a instrução ~raise~ responsável por acusar o erro. Ela só é executada caso o valor de $x$ esteja fora do intervalo esperado (checado pelo ~if~ da linha 18). Como o erro neste caso tem a ver com o /valor/ de uma variável, o erro que deve ser acusado pelo ~raise~ é o ~ValueError~. Observe que podemos escrever uma mensagem personalizada para ajudar o usuário a corrigir o problema caso encontre esse erro durante seu uso do código.

Checar uma condição e acusar um erro caso esta condição seja falsa é uma estrutura bastante comum no início do corpo de funções. Afinal, assim que o corpo da função inicia sua execução nós temos acesso a todos os argumentos e já podemos checar se eles têm valores dentro do esperado. A instrução ~assert~ facilita esse tipo de checagem. Veja no exemplo abaixo o uso da instrução ~assert~ para realizar a mesma tarefa do exemplo anterior.

#+begin_src python -n
  def log_natural(x, num_elementos=10000):
      """Calcula o logaritmo natural do valor recebido.

      Args:
        x:
          Valor real maior que zero e menor ou igual a dois.
        num_elementos:
          Número de elementos a serem considerados na soma infinita da série de
          Taylor.

      Returns:
        Logarítmo natural de `x`.

      Raises:
        ValueError: ocorre caso o valor de x não satisfaça a inequação 0 < x <= 2.
      """

      assert 0 < x <= 2, "O valor de x deve ser maior que 0 e menor ou igual a 2."

      soma = 0
      for k in range(1, num_elementos + 1):
          soma = soma + (-1) ** (k + 1) * (x - 1) ** k / k

      return soma


  print(log_natural(1))
  print(log_natural(2))
  print(log_natural(10))
  print(log_natural(-3))
#+end_src

#+RESULTS:
: 0.0
: 0.6930971830599583


A sintaxe da instrução ~assert~ requer uma condição a ser checada logo após a instrução. Caso a condição retorne ~False~ o código é interrompido e acusa um ~AssertionError~. Caso queira exibir uma mensagem ao usuário para ajudá-lo a entender o que ocorre, escreva uma string e coloque ela após uma vírgula. A mensagem não é obrigatória mas altamente recomendada.

Uma forma mais fácil de entender a instrução ~assert~ é lendo ela como "assegure-se que". Na linha 18 do código acima podemos ler como "assegure-se que o valor de ~x~ é maior que zero e menor ou igual a dois, do contrário, exiba uma mensagem de erro ao usuário alertando ele que esse é um requerimento necessário para executar a função".

* JAMES Dicionários :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_dicionarios
:EXPORT_OPTIONS: toc:t
:ID:       982992c4-400b-4d79-a738-e86116b14ebc
:END:

** Associando objetos com dicionários
Dicionários são mais uma maneira de guardarmos informações, que pode ser bastante interessante para organização. Vamos dar um exemplo que já foi tratado nesse curso, as listas de compras. Lembram do nosso miojo incrementado, os itens para comprar na papelaria e os da padaria para fazer o misto quente? Estavamos os guardando em listas de listas, mas, podemos os guardar em dicionários também e com uma melhor organização. Vamos para um exemplo onde mostramos a sintaxe e a estrutura dos dicionários:

#+begin_src python
dicionariodecompras = {						#Iniciamos a definição do dicionário
  "mercado": ["Miojo", "Ovo", "Orégano", "Papel Higiênico"],	#Definimos a primeira chave do dicionário, com seu valro associado, que no caso é uma lista
  "padaria": ["Pão", "Queijo", "Presunto"],			#Definimos a segunda chave e seu valor
  "papelaria": ["Caderno", "Caneta", "Lápis"]			#Terceira chave e valor definidos
}								#Término do dicionário
print(dicionariodecompras)					#Imprimimos o dicionário todo
print(dicionariodecompras['mercado'])				#Imprimimos apenas a chave mercado do dicionário
print(dicionariodecompras['padaria'])                           #Imprimimos a chave padaria
print(dicionariodecompras['papelaria'])                         #Por fim, a chava papelaria é impressa
#+end_src

Notem a sintaxe, os dicionários ficam entre chaves ={ }=, assim como os conjuntos, então cuidado, pois isso pode trazer ambiguidades no código, por exemplo para inicializar um conjunto vazio. Na definição interna do dicionário temos a seguinte sintaxe: ="chave": valor=, onde as chaves vão funcionar como se fossem índices do dicionário, e os valores são os itens associados a chave. No exemplo acima definimos cada chave como uma lista, convenientemente organizadas, sendo uma chave para cada lista de compras. Os valores dos dicionários não precisam ser listas, podem ser números, strings e misturadas. Vamos a mais um exemplo para ilustrar isto:

#+begin_src python
print(aluno)
print(aluno["Nome"])
print(aluno["Nota 1"])
print(aluno["Nome"], 'teve as seguintes notas:', aluno["Nota 1"], aluno["Nota 2"], aluno["Nota 3"], 'com média final', ((aluno["Nota 1"]+aluno["Nota 2"]+aluno["Nota 3"])/3))
#+end_src

** Métodos de dicionários
Assim como listas e conjuntos, os dicionários também possuem métodos associados. Como sempre os métodos facilitam a vida na programação, por fazer diretamente uma função que poderia ser extensa de implementar. Abaixo os principais métodos de dicionários são apresentados:

+ keys: Retorna uma lista contendo todas as chaves do dicionário. Sintaxe: dicionario.keys()
+ get: Retorna o valor da chave especificada. Sintaxe: dicionario.get("chave")
+ items: Retorna uma lista contendo uma tupla para cada par chave-valor. Sintaxe: dicionario.items()
+ values: Retorna uma lista com todos os valores no dicionário. Sintaxe: dicionario.values()
+ update: Insere um par chave-valor no dicionário. Sintaxe: dicionario.update({"chave": "valor"})
+ pop: Assim como já visto em listas e conjuntos,

** Modificando e desempacotando dicionários


+ método =pop=
+ adicionando nova chave
+ deletando uma chave

** Iterando sobre dicionários
+ métodos =items=, =get=, =keys=, =values=

** Funções com argumentos estrela \ast{}args e \ast\ast{}kwargs

* DANIEL Strings e processamento de texto :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_strings
:EXPORT_OPTIONS: toc:t
:ID:       6feb275c-31de-49dd-87a1-d3576f4dbfc2
:END:

** Agrupando caracteres com strings

Já vimos que strings são objetos que armazenam texto e que para declarar strings usamos aspas simples ou aspas duplas. Texto nada mais é do que uma lista de zero ou mais letras. Assim como listas, podemos segmentar strings usando a notação dos índices dentro de colchetes. Veja no exemplo abaixo.

#+begin_src python -n
  string_com_zero_letras = ""
  string_com_uma_letra = "a"
  string_com_varias_letras = "abcdefghijklmnopqrstuvwxyz"

  print(string_com_varias_letras[0])
  print(string_com_varias_letras[1])
  print(string_com_varias_letras[2])

  print(string_com_varias_letras[3:8])
  print(string_com_varias_letras[8:])

  print(string_com_varias_letras[::2])
#+end_src

#+RESULTS:
: a
: b
: c
: defgh
: ijklmnopqrstuvwxyz
: acegikmoqsuwy

Como strings são listas de letras, também podemos usar o ~for~ da mesma maneira que usamos em listas! Veja no exemplo abaixo.

#+begin_src python -n
  texto = "Bravo, Vince!"

  for letra in texto:
      print(letra)
#+end_src

#+RESULTS:
#+begin_example
B
r
a
v
o
,

V
i
n
c
e
!
#+end_example

É possível converter objetos que não são texto para texto usando a função ~str~.

#+begin_src python -n
  numero = 1234
  texto_a_partir_do_numero = str(1234)

  print(numero)
  print(texto_a_partir_do_numero)

  try:
      # agora que temos um texto, é fácil separar os digitos do número
      print(texto_a_partir_do_numero[0])  # este é o digito 1 do número 1234

      # note que essa sintaxe não funciona para variáveis numéricas
      print(numero[0])

  except TypeError:
      print('Variáveis numéricas não permitem usar a notação de índices '
            'com chaves.')
#+end_src

#+RESULTS:
: 1234
: 1234
: 1
: Variáveis numéricas não permitem usar a notação de índices com chaves
: 1234
: 1234

Também podemos converter texto numérico em variáveis numéricas usando as funções ~int~ e ~float~. Veja o exemplo abaixo:

#+begin_src python -n
  texto = "1234"
  numero_a_partir_do_texto = int(texto)

  print(texto)
  print(numero_a_partir_do_texto)

  try:
      # agora que temos um nlumero, podemos fazer contas
      print(numero_a_partir_do_texto + 4321)

      # note que não podemos fazer contas com variáveis que são texto
      print(texto + 4321)

  except TypeError:
      print('Não podemos fazer contas com variáveis tipo string, mesmo'
            'que elas tenham um número armazenado nelas.')

#+end_src

#+RESULTS:
: 1234
: 1234
: 5555
: Não podemos fazer contas com variáveis tipo string, mesmoque elas tenham um número armazenado nelas.

Uma diferença muito importante entre strings e listas é que strings são variáveis imutáveis (assim como tuplas) e listas são variáveis mutáveis. Isso significa que após uma string ser criada não é possível altera-la.

** Métodos condicionais de strings

Existem diversos métodos de strings. Você pode checar todos eles [[https://docs.python.org/3/library/stdtypes.html?highlight=startswith#text-sequence-type-str][na documentação oficial]]. Existem dois métodos para checar strings que são particularmente muito utilizados: o ~startswith~ e o ~endswith~


+ checando prefixos e sufixos com =startswith= e =endswith=
+ checando caracteres com =isnumeric=, =isupper=, =islower=

** Recebendo informações do usuário com o comando =input=

** Tipos de strings
+ utf-8
  - caracteres especiais tipo \n e \t
+ raw
+ fstring

** Processamento de texto
+ =split= e =join=
+ =translate= e =maketrans=
+ =capitalize=, =title=, =lower=, =upper=, =swapcase=
+ =replace=

** Expressões regulares
* JAMES Scripts de python, bash e HPC :noexport:
* TODO Programação orientada a objetos :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_classes
:EXPORT_OPTIONS: toc:t
:ID:       59343370-093c-4c7c-b549-9e102aed7b5b
:END:

** Agrupando objetos com classes
+ classes como um único objeto para tratar de dados e funções
+ sintaxe
+ instância
+ parâmetros
+ =self=

** Classes e seus métodos
** Métodos mágicos
+ dunders
+ __init__
+ __str__
+ __repr__

** Herança de classes

~isinstance~

* TODO Biblioteca padrão :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_bibpadrao
:EXPORT_OPTIONS: toc:t
:ID:       a5a1dec7-4ac1-4c97-a064-75b93b837a5c
:END:

** O que são e como importar módulos de Python
+ sintaxe para importar um módulo (com ou sem apelido)
+ sintaxe para importar objetos de um módulo
+ conceito de namespace ("espaço de nome")
+ reforçar que cada módulo tem sua documentação (ou deveria ter...)
+ Módulos para usar como exemplo: =math= e =random=

** Módulos embutidos
+ os que eu acho mais interessantes são:
  + os
  + sys
  + functools
  + itertools
  + math
  + pathlib
  + pdb
  + pprint
  + random
  + re
  + statistics
  + pickle
  + abc?
  + collections
  + datetime
  + logging

* TODO Leitura e manipulação de dados com o módulo =pandas= :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_pandas
:EXPORT_OPTIONS: toc:t
:ID:       94937cb1-718d-4eee-a3be-611c4badeb4b
:END:

** Criando e manipulando DataFrames a partir de arquivos
** Análise dos dados
+ Estatística descritiva
** Criando e exportando um DataFrame a partir de listas
+ Criando um dataframe usando listas de python
+ Exportar para csv
+ Exportar para xlsx

* TODO Graficando dados :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_graficos
:EXPORT_OPTIONS: toc:t
:ID:       5c9942b1-d397-4d59-9891-6f6bfee01809
:END:

** Graficando dados de um DataFrame
** Graficando dados usando =matplotlib=

* TODO Controle de versão usando =git= :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_git
:EXPORT_OPTIONS: toc:t
:ID:       7ec34a02-1c92-4a3f-940a-955daab7050f
:END:

* TODO Computação científica com =numpy= e =scipy= :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: PC1/PC1_numpy
:EXPORT_OPTIONS: toc:t
:ID:       fc29118f-e0b5-4816-9034-4a83e7b520b4
:END:
* TODO Álgebra simbólica com =sympy= :noexport:
* TODO Propagação de erros com =uncertainties= :noexport:
* TODO Tópicos avançados :noexport:
** Funções anônimas

#+begin_quote
/Não sei por que as pessoas estão tão interessadas em colocar os detalhes de sua vida privada em público; elas esquecem que a invisibilidade é um superpoder./ --- Banksy
#+end_quote

Existe uma outra forma de declarar funções em Python, utilizando a instrução ~lambda~. Funções declaradas desta forma são chamadas de /funções anônimas/, /funções em linha/ ou simplesmente /funções lambda/. A função ~ola~ abaixo pode ser escrita como uma função não-anônima (linha 1) ou anônima (linha 8). Ambas fazem a mesma tarefa.

#+begin_src python -n
  def ola():
      """Retorna a string `Olá!`."""
      return "Olá!"


  print(ola())

  ola = lambda: "Olá"

  print(ola())
#+end_src

Perceba que uma função anônima ocupa apenas uma linha e não tem o valor de retorno explícito: a instrução que está após o "~lambda:~" é o retorno.

Funções anônimas podem ter argumentos e estes são declarados após o ~lambda~ e antes do dois-pontos (veja a linha 8 do código abaixo). Se existir mais de um argumento, eles devem ser separados por vírgulas (linha 20 do código abaixo).

#+begin_src python -n
  def multiplica_por_100(x):
      """Multiplica o valor recebido por 100."""
      return x * 100


  print(multplica_por_100(2))

  multiplica_por_100 = lambda x: x * 100

  print(multplica_por_100(2))


  def divide_um_pelo_outro(x, y):
      """Divide o primeiro valor recebido pelo segundo."""
      return x / y


  print(divide_um_pelo_outro(20, 5))

  divide_um_pelo_outro = lambda x, y: x / y

  print(divide_um_pelo_outro(20, 5))
#+end_src

Nos exemplos acima nós armazenamos as funções anônimas em variáveis. Mesmo esta sintaxe sendo perfeitamente válida, a PEP 8 recomenda que isso _não seja feito_. Sempre que precisar declarar uma função com nome utilize a instrução ~def~. Fica a pergunta: para que servem funções anônimas? Funções anônimas são excelentes em situações onde precisamos de funções simples de uso único. Exemplos incluem certos argumentos das funções ~sorted~, ~filter~ e ~map~.

A função ~sorted~, por exemplo, é capaz de ordenar os números de uma lista. Quando ela é usada com seu argumento ~key~ padrão, a função ordena os elementos em ordem crescente. O argumento ~key~, se utilizado, deve ser uma função com apenas um argumento que será aplicado aos números da lista antes de ordená-los. Veja o exemplo abaixo. Na linha 3, a função ~sorted~ utiliza o argumento ~key~ padrão (pois não recebeu ele quando foi chamada) e retorna os valores da lista em ordem crescente. Na linha 5, a função ~sorted~ recebeu o argumento ~key~: neste caso é uma função anônima que retorna o valor absoluto do argumento recebido. Com isso, a função ~sorted~ primeiro aplica essa função anônima para cada elemento da lista, ordena a lista levando em conta estes novos elementos, e depois "converte" os elementos para seus valores originais. O resultado final é que os números foram ordenados levando em conta seu valor absoluto.

#+begin_src python -n
  lista = [0, 1, -2, 3, -4, 5, -6]

  print(sorted(lista))  # resulta em [-6, -4, -2, 0, 1, 3, 5]

  print(sorted(lista, key=lambda x: abs(x)))  # resulta em [0, 1, -2, 3, -4, 5, -6]
#+end_src

#+RESULTS:
: [-6, -4, -2, 0, 1, 3, 5]
: [0, 1, -2, 3, -4, 5, -6]

Apenas para deixar claro, o exemplo anterior usou uma função anônima para o argumento ~key~ pois é uma função simples de uso único. Entretanto, poderíamos também usar uma função declarada com a instrução ~def~ como mostra o código abaixo. Nesse caso, o uso de uma função anônima é preferível por facilitar a leitura do código.

#+begin_src python -n
  lista = [0, 1, -2, 3, -4, 5, -6]

  def absoluto(x):
      """Retorna o valor absoluto."""
      return abs(x)

  print(sorted(lista, key=absoluto))  # resulta em [0, 1, -2, 3, -4, 5, -6]
#+end_src

#+RESULTS:
: [0, 1, -2, 3, -4, 5, -6]
** Decoradores

* TODO Exercícios :noexport:

https://github.com/azl397985856/leetcode/blob/9afe2386ce804beb263f1d6b27a86af2ee2e0546/README.en.md
https://github.com/azl397985856/leetcode
https://github.com/haoel/leetcode
https://github.com/rougier/numpy-100/blob/master/100_Numpy_exercises.md
https://github.com/zhiwehu/100_plus_Python_Projects_Challenge
https://github.com/topics/python-exercises
https://github.com/zhiwehu/Python-programming-exercises/blob/master/100%2B%20Python%20challenging%20programming%20exercises.txt
https://github.com/jerry-git/learn-python3

+ Computar numericamente a soma de uma PA ou PG
+ Checar os números divisíveis por 5 em uma lista
+ Contar quais são as palavras mais comuns em um texto
+ Dadas duas listas, montar uma terceira com os maiores números de cada (element-wise)
+ mostrar a sequencia de fibonacci até o número n
+ checar se um número é primo
+ função que soma todos os números do 1 até o n
+ programa que conta quantos digitos existem em um numero inteiro
+ inverter a ordem de uma lista
+ programa que calcula o fatorial de um inteiro positivo
+ programa que cria uma lista apenas com os itens nas posições impares de uma lista original
+ função que conta quantas letras, dígitos e caracteres especiais tem em uma string
+ histograma de contagem de caracteres em uma string
+ encontrar números em uma string e armazena-los em uma lista
+ histograma de valores em uma lista
+ criar uma lista sem itens repetidos
+ identificar os elementos em comum entre duas listas
+ separar valores e chaves de dicionários em duas listas
+ concatenar duas listas de string element-wise
+ Create a program that asks the user to enter their name and their age. Print out a message addressed to them that tells them the year that they will turn 100 years old.
+ use compreensão de lista para identificar números impares em uma lista
+ criar um jogo de jokenpo a ser jogado por duas pessoas
+ exercicio onde o computador escolhe um numero aleatorio e o usuario deve adivinhar com dicas de maior ou menor


intermediário:
+ reverter cada palavra de uma lista
  - 'My Name is Jessa'
  - yM emaN si asseJ
+ inverter chave e valores de um dicionário
+ mostrar todos os itens duplicados em uma lista

* TODO Comprehensive guides :noexport:
https://bas.codes/posts/python-slicing

* TODO Ideias de tópicos :noexport:

+ criando módulos de python
+ geradores
+ decoradores
